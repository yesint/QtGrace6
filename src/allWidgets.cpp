/***************************************************************************
 *   Copyright (C) 2008-2022 by Andreas Winter                             *
 *   andreas.f.winter@web.de                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include "allWidgets.h"

#include "undo_module.h"
#include "editWidgets.h"
#include "appearanceWidgets.h"
#include "MainWindow.h"
#include "windowWidgets.h"
#include "events.h"
#include "device.h"
#include "globals.h"
#include "t1fonts.h"
#include "t1lib.h"
#include "ssdata.h"
#include "graphutils.h"
#include "events.h"
#include "parser.h"
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <fcntl.h>
#include <QSvgRenderer>
#include <QProgressBar>
#include <QMessageBox>
#include "svgdrv.h"
#include "cmath.h"
#include "external_libs.h"

#ifdef _MSC_VER
#include "windows.h"
#endif

/* nonlprefs.load possible values */
#define LOAD_VALUES         0
#define LOAD_RESIDUALS      1
#define LOAD_FUNCTION       2

#define  WEIGHT_NONE    0
#define  WEIGHT_Y       1
#define  WEIGHT_Y2      2
#define  WEIGHT_DY      3
#define  WEIGHT_CUSTOM  4

struct komplex one={1.0,0.0};
struct komplex zero={0.0,0.0};
struct komplex i_one={0.0,1.0};
int new_set_no;
int * new_set_nos=NULL;
int * new_graph_nos=NULL;
int new_set_blocks;
int * new_set_block_size=NULL;
#ifdef __cplusplus
extern "C" {
#endif
extern int current_origin_graph,current_origin_set;
extern int current_target_graph,current_target_set;
extern int error_count;
#ifdef __cplusplus
}
#endif
extern QCursor * wait_cursor;
extern void clear_new_set_ids(void);
extern double rint_v2(double x);

int default_Print_Device=-1;//-1=last one
bool ApplyError=false;
bool GlobalInhibitor=false;
bool immediateUpdate=false;
bool updateRunning=false;
bool silent_nonl_fit=false;
//int replace_souce_sno,replace_souce_gno,replace_dest_sno,replace_dest_gno;
//int by_souce_sno,by_souce_gno,by_dest_sno,by_dest_gno;

extern int lastPrintDevice;
extern bool useQtFonts;
extern bool symbol_font_is_special;
extern bool use_print_command;
extern bool activate_id_replacing;
extern CanvasAction action_flag;
extern int replace_o_set_ids,replace_n_set_ids;//number of set ids (original and new set ids - meaning right and left hand side of an equation)
//if set-id is '-1' a new set is to be allocated and the new id is writen in the id-arrays
//gnos always have to be real ids and no '-1'
extern int * replace_o_gnos;
extern int * replace_o_snos;
extern int * replace_n_gnos;
extern int * replace_n_snos;
extern bool printing_in_file;
extern int print_target;
//extern bool use_new_print_dialog;
extern int stdOutputFormat;//actually: last Output Format
extern char dummy[];
extern char last_formula[];
extern char saved_formula[];
extern double last_fit_falues[];
extern double saved_value;
extern int DefaultFont;
extern char default_grace_file[];

QStringList ListOfChanges;
QStringList ListOfOldStates;

extern bool use_new_icons;
extern int dirtystate;
extern bool exchange_point_comma;
extern bool display_help_externally;
//extern long orig_page_w,orig_page_h;
extern double GeneralPageZoomFactor;
extern Device_entry *device_table;
extern MainWindow * mainWin;
extern frmCommands * FormCommands;
extern bool useQPrinter;
extern QPrinter * stdPrinter;
extern frmDeviceSetup * FormDeviceSetup;
extern frmUserDefaultGeometries * FormUserDefaultGeometries;
extern frmReportOnFitParameters * FormReportFitParameters;
extern frmSetAppearance * FormSetAppearance;
extern frmTextProps * TextProps;
extern frmTextProps * EditTextProps;
extern frmLineProps * LineProps;
extern frmLineProps * EditLineProps;
extern frmEllipseProps * BoxProps;
extern frmEllipseProps * EditBoxProps;
extern frmEllipseProps * EllipseProps;
extern frmEllipseProps * EditEllipseProps;
extern frmDrawObjects * FormDrawObjects;
extern frmConsole * FormConsole;
extern frmEditColumnProp * EditColumn;
extern frmFontTool * FormFontTool;
extern frmIOForm * FormReadNetCDF;
extern QPixmap * GraceIcon;
extern QBitmap * patterns[MAXPATTERNS];
extern QBitmap * Qt_justifications[12];
extern frmIOForm * FormSelectOutputFile;
extern int number_of_opened_spreadsheets;
extern frmSpreadSheet ** FormSpreadSheets;
extern QPainter * GeneralPainter;
extern QImage * MainPixmap;
extern QBitmap * Qt_justifications[12];
extern QBitmap * Qt_matrixOrder[8];
extern void HelpCB(char *data);
extern int get_cg(void);
extern frmGraphApp * FormGraphAppearance;
extern frmAxisProp * FormAxisProperties;
extern frmSetEditor * FormSetEditor;
extern frm_Preferences * Form_Preferences;
extern frmAgrInfos * Form_AgrInfo;
extern frmProgressWin * FormProgress;
extern frmQuestionDialog * FormQuestion;
extern frmSimpleListSelectionDialog * FormSimpleListSel;
extern frmUndoList * FormUndoList;
extern frmEditBlockData * FormEditBlockData;

extern int max_history;
extern int current_history;
extern QString history[MAX_HISTORY];
extern QList<QByteArray> avcod;
//extern QTextCodec * FileCodec;

extern int nr_of_current_linestyles;
extern int * lenghts_of_linestyle_patterns;
extern char ** current_linestyle_patterns;
extern QIcon ** LineIcons;
extern QPixmap ** LinePixmaps;
extern QVector<qreal> ** PenDashPattern;

extern QLocale * comma_locale;//a setting where ',' is the decimal separator (we use the setting for Germany here)
extern QLocale * dot_locale;//a setting where '.' is the decimal separator (we use the setting for the USA here)

extern int current_language;
extern QTranslator translator[nr_of_translations];
extern char translator_files[nr_of_translations][64];
extern char translator_languages[nr_of_translations][64];
extern void change_language(int index);
extern void update_default_props(void);
extern char *next_token(char *s, char **token, int *quoted);
extern void exchangePointComma(char * token);
extern void exchangePointCommaInFormat(char * token,int type);
extern void convert_Grace_Strings(void);
extern void copy_LaTeX_to_Grace(void);
extern void convert_all_strings_from_encoding_to_UTF8(void);
extern void copy_Grace_to_LaTeX(void);
extern void check_external_lib_usability(void);
extern void setExportTypeDescription(const char * ext);
extern void read_bin_file_by_current_settings(bool halt_autoscale);
extern int interpolate(double *mesh, double *yint, int meshlen,double *x, double *y, int len, int method);
extern void parse_qtGrace_Additions(char * s);
extern QString WriteFit2DString(int type,int gno,int sno,int t_set,double x0,double y0,double r1,double r2,double angle,double phi0,double phi1,int n_phi,int region,int reg_inv);
extern void generate_string_Qt_aware(char * str,QString text);

//extern QBitmap generate_Bitmap_form_Bits(unsigned char * bits,int length,int rows,int cols);
extern void UpdateAllWindowContents(void);
extern void updateAllSelectors(void);

extern imageinfo bg_fill_image;
extern imageinfo bg_box_fill_image;
extern imageinfo bg_ellipse_fill_image;

int nr_of_set_concerned=0;
int * sets_concerned_g=NULL;
int * sets_concerned_s=NULL;

int fit_destination_graph,fit_destination_set;

/*extern int arrange_graphs(int *graphs, int ngraphs,
                          int nrows, int ncols, int order, int snake,
                          double loff, double roff, double toff, double boff,
                          double vgap, double hgap,
                          int hpack, int vpack, int move_legend, double legendX, double legendY);*/
extern void complete_LaTeX_to_Grace_Translator(QString & text);
extern void update_grace_string_from_UTF8_static(char * string);
extern void replace_set_ids_in_command(QString & commandString,int o_gno,int o_sno,int n_gno,int n_sno,int relative);//only replace-operations, no command execution
extern void copy_line_style_patterns_to_current(int n_length,int * n_style_lengths,char ** n_patterns);
extern void copy_line_style_patterns_to_target(int n_length,int * n_style_lengths,char ** n_patterns,int target);
extern void update_line_style_selectors(void);
extern void update_sliders(void);
extern void update_Line_Editors(void);
extern void create_line_Patterns(void);
extern void update_PatternSelectors(void);
extern void update_OrderSelectors(void);
extern void update_AlignmentSelectors(void);
extern void update_JustificationSelectors(void);
extern void read_basic_icons(void);
extern void replaceSuffix(QString & fpath,QString n_suffix);
extern int guess_bin_format(QString filename,int & std_format_nr,bool & is_header);
extern int nr_of_std_bin_import_settings;
extern struct importSettings * std_bin_import_settings;
extern struct importSettings current_bin_import_settings;
extern void drawSimpleSymbol(QPainter & paint1,int x,int y,int w,int sym,char sym_c=65);
extern void calculate_fit_accuracy(double * yp,double * y_saved,int n,double * cor,double * chisq,double * theil,bool * rms_ok,double * rms_pe);
extern void anchor_point(int curx, int cury, VPoint curvp);
extern void select_line(int x1, int y1, int x2, int y2, int erase);
extern void xlibVPoint2dev(VPoint vp, int *x, int *y);
extern void split_ini_keys(QStringList & keys,QStringList & sections,QList<QStringList> & sec_vals);
extern void evaluateCounters(struct importSettings & imp_set);
extern void evaluatePreprocessors(struct importSettings & imp_set);
extern int evaluateSingleCounter(QStringList sections,QList<QStringList> sec_vals,int type, QString section, QString text);
extern double processString(QString text,int type,QString cA,QString cB,int multA,int multB,QString & result);
extern void removeLineWidthSelector(LineWidthSelector * selector);

#ifdef __cplusplus
extern "C" {
#endif
extern int qtspecial_scanner(char * command, int * errors);
extern void prepare_strings_for_saving(void);
extern void resume_strings_after_load_or_save(void);
extern double rint_2(double v);
#ifdef __cplusplus
}
#endif

extern int regiontype;
extern bool wait_till_update;

extern int curformat;
extern int curdevice;
extern unsigned long page_scale;
extern double pixel_size;
extern float page_scalef;
extern int page_orientation;
extern int * psfont_status;
extern int ps_color;
extern int ps_pattern;
extern double ps_linew;
extern int ps_lines;
extern int ps_linecap;
extern int ps_linejoin;
extern int ps_grayscale;
extern int ps_level2;
extern int docdata;
extern int ps_setup_offset_x;
extern int ps_setup_offset_y;
extern int ps_setup_grayscale;
extern int ps_setup_level2;
extern int ps_setup_docdata;
extern int ps_setup_feed;
extern int ps_setup_hwres;
extern int eps_setup_grayscale;
extern int eps_setup_level2;
extern int eps_setup_tight_bb;
extern int eps_setup_docdata;
extern int tight_bb;
extern int pnm_setup_format;
extern int pnm_setup_rawbits;

extern graph * g;
extern int maxgraph;
extern char print_file[];
//extern char desired_hardcopy_filename[GR_MAXPATHLEN];
extern int png_setup_res;

extern defaults d_d;
extern defaults file_defaults;
extern defaults ini_defaults;
extern defaults tmp_defaults;

extern view d_v;
extern view file_view;
extern view ini_view;
extern view tmp_view;

int current_page_units = 0;
#if defined WITH_XMHTML || defined WITH_LIBHELP
extern int force_external_viewer;
#endif

extern void xdrawgraph(void);
extern void sort(int number,int * items);
extern const char *set_types(int it);
extern nonlparms nonl_parms[];
extern nonlopts nonl_opts;
extern char SystemsDecimalPoint;
extern char OldDecimalPoint;
extern char DecimalPointToUse;
extern QFile path_to_fftw3_lib,path_to_libharu;
extern int AAGrayLevelsOK;
extern QString Last_Dialog_Path[NR_OF_FILE_DIALOGS];
extern UserDeviceGeometry DefaultUserDeviceGeometry[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES];
extern UserDeviceGeometry DefaultSystemDeviceGeometry[NR_OF_QUICKSELECTOPTIONS];

extern struct ColumnFormat binaryImportFormat[NUMBER_OF_COLUMN_FORMATS];
extern char binaryImportFormatName[NUMBER_OF_COLUMN_FORMATS][32];
extern int ImportDestination[NUMBER_OF_IMPORT_DESTINATIONS];
extern char ImportDestinationName[NUMBER_OF_IMPORT_DESTINATIONS][32];
extern signed char ImportDestinationType[NUMBER_OF_IMPORT_DESTINATIONS];
extern void copy_bin_settings_to_current_bin_import(QString filename,bool is_header,importSettings * imp_set);
extern void update_font_selectors(bool appearance);
extern int get_QtFontID_from_Grace_Name(const char * name,int whatlist);

extern void SetDecimalSeparatorToUserValue(char * str,bool remove_space=true);
extern void ReplaceDecimalSeparator(char * str,bool remove_space=true);
extern void RedisplayString(char * str);
extern void PrepareFormula(char * str);
extern void RedisplayFormula(char * str);

extern void generateCommentAndLegendAfterImport(const char * filename,int set,int col1,int col2,char * new_comment,char * new_legend);
extern void create_one_line_pattern(int len,char * linestyle_pattern,QPixmap ** pm,QIcon ** ic,QVector<qreal> ** pendash);
extern void copy_std_line_style_patterns(int * length,int ** style_lengths,char *** patterns);
extern void update_one_line_style_selector(LineStyleSelector * selStyles,int len,QPixmap ** pix);
extern int find_import_destination(char * name,signed char type);
extern int find_import_format(char * name);
extern void updateUniLists(void);
extern void changeDragInUniLists(void);
extern int openPipe(char * pname,int * fd);

extern int n_linestyles_ini,n_linestyles_tmp,n_linestyles_file,nr_of_current_linestyles;
extern int *l_linestyle_pat_ini,*l_linestyle_pat_tmp,*l_linestyle_pat_file,*lenghts_of_linestyle_patterns;
extern char **linestyle_pat_ini,**linestyle_pat_tmp,**linestyle_pat_file,**current_linestyle_patterns;

extern QSize LastSize_FormEvalExpr;
extern QSize LastSize_FormNonlinCurveFit;
extern QSize LastSize_Form2DFit;
extern QSize LastSize_FormInterpolation;
extern QSize LastSize_FormDeviceOptions;
extern QSize LastSize_FormDeviceSetup;
extern QSize LastSize_FormUserDefaultDevice;
extern QSize LastSize_FormSetOPS;
extern QSize LastSize_FormFeatureExtraction;
extern QSize LastSize_FormHistograms;
extern QSize LastSize_FormFourier;
extern QSize LastSize_FormFourier2;
extern QSize LastSize_FormLoadAndEvaluate;
extern QSize LastSize_FormIntegration;
extern QSize LastSize_FormSeasonDiff;
extern QSize LastSize_FormDifferences;
extern QSize LastSize_FormAverages;
extern QSize LastSize_FormRegression;
extern QSize LastSize_FormCorrelation;
extern QSize LastSize_FormConvolution;
extern QSize LastSize_FormDigitalFilter;
extern QSize LastSize_FormPruneData;
extern QSize LastSize_FormSamplePoints;
extern QSize LastSize_FormGeometricTransform;
extern QSize LastSize_FormNetCDF;
extern QSize LastSize_FormReadSets;
extern QSize LastSize_FormReadNetCDF;
extern QSize LastSize_FormWriteSets;
extern QSize LastSize_FormOpenProject;
extern QSize LastSize_FormSaveProject;
extern QSize LastSize_FormReadParameters;
extern QSize LastSize_FormWriteParameters;
extern QSize LastSize_FormSelectOutputFile;
extern QSize LastSize_FormOpenFitPara;
extern QSize LastSize_FormSaveFitPara;
extern QSize LastSize_FormReadBinary;
extern QSize LastSize_FormWriteBinary;
extern QSize LastSize_FormCSVImport;
extern QSize LastSize_FormCSVImportV2;
extern QSize LastSize_FormProgress;
extern QSize LastSize_FormQuestion;
extern QSize LastSize_FormSimpleListSel;
extern QSize LastSize_FormReportFitParameters;
extern QSize LastSize_FormGeometricEvaluation;
extern QSize LastSize_FormBinaryImportFilter;
extern QSize LastSize_FormEditBlockData;

extern QSize LastSize_FormSetEditor;
extern QSize LastSize_DeviceActivator;
extern QSize LastSize_Form_Preferences;
extern QSize LastSize_Form_AgrInfo;
extern QSize LastSize_Form_SetupWizard;
extern QSize LastSize_Form_InitWizard;
extern QSize LastSize_FormIOForm;
extern QSize LastSize_EditColumnProp;
extern QSize LastSize_Spreadsheets;
extern QSize LastSize_FormSelectHotLink;

//the following two lists are for the generation of new sets by commands lie G0.S5N
//for new sets allocated during command execution
/*extern QStringList NewGraphCommands;//commands used to create a new graph
extern QStringList NewGraphReplacement;//the replacement for the commands (i.e. the new graph id)
extern QStringList NewSetCommands;//commands used to create a new set
extern QStringList NewSetReplacement;//the replacement for the commands (i.e. the new set id)
extern QList<int> newSetIds;//new numbers of the new set-ids
extern QList<int> newGraphIds;//the graphs the new sets are allocated in
extern int current_target_graph;

//this function tries to find the "newCommand" like G0.S5N in "NewSetCommands"; if it does not exist, a new set will be generated and added to the list
QString find_new_set_command(QString newCommand)
{
QString ret;
ret.clear();
int index=NewSetCommands.indexOf(newCommand);
if (index==-1)//not present yet
{
    int d1,d2,d3,r2;
    char * dummy=new char[16+newCommand.length()];
    strcpy(dummy,newCommand.toLocal8Bit().constData());
    sscanf(dummy,"G%d.S%dN",&d1,&d2);
    d3=nextset(d1);
    r2=activateset(d1,d3);
    if (r2==RETURN_SUCCESS)
    {
    sprintf(dummy,"G%d.S%d",d1,d3);
    ret=QString(dummy);
    NewSetCommands << newCommand;
    NewSetReplacement << ret;
    }
    delete[] dummy;
}
else//found
{
ret=NewSetReplacement.at(index);
}
return ret;
}
*/

#ifdef __cplusplus
extern "C" {
#endif
extern void prepare_strings_for_saving(void);
extern void resume_strings_after_load_or_save(void);
#ifdef __cplusplus
}
#endif

/* prefs for non-linear fit */
typedef struct {
    int autoload;       /* do autoload */
    int load;           /* load to... */
    int npoints;        /* # of points to evaluate function at */
    double start;       /* start... */
    double stop;        /* stop ... */
} nonlprefs;

char buf[1024];
char command[1024];
nonlprefs nonl_prefs = {TRUE, LOAD_VALUES, 10, 0.0, 1.0};

int outputQuality=75;
bool outputGrayscale=false;
int init_null(void){return 0;}	    /* function to initialize device */
int parser_null(const char * v){(void)v;return 0;}  /* function to parse device-specific commands */
void setup_null(void){;}    /* function (GUI interface) to setup device */
void define_region(int nr, int rtype);

/*
void read_INI_header(struct importSettings & imp_set,struct importSettings & imp_schema);
void read_BINARY_Header(struct importSettings & imp_set,struct importSettings & imp_schema);
void read_ASCII_Header(struct importSettings & imp_set,struct importSettings & imp_schema);
int postprocess_bin_import_data(struct importSettings & imp_set,int & nr_of_new_sets,int ** n_gnos,int ** n_snos);
*/

OptionItem fmt_option_items[NUM_FMT_OPTION_ITEMS] =
{
    {FORMAT_DECIMAL,        "Decimal"             },
    {FORMAT_EXPONENTIAL,    "Exponential"         },
    {FORMAT_GENERAL,        "General"             },
    {FORMAT_POWER,          "Power"               },
    {FORMAT_SCIENTIFIC,     "Scientific"          },
    {FORMAT_ENGINEERING,    "Engineering"         },
    {FORMAT_COMPUTING,      "Computing (K,M,G,...)"},
    {FORMAT_DDMMYY,         "DD-MM-YY"            },
    {FORMAT_MMDDYY,         "MM-DD-YY"            },
    {FORMAT_YYMMDD,         "YY-MM-DD"            },
    {FORMAT_MMYY,           "MM-YY"               },
    {FORMAT_MMDD,           "MM-DD"               },
    {FORMAT_MONTHDAY,       "Month-DD"            },
    {FORMAT_DAYMONTH,       "DD-Month"            },
    {FORMAT_MONTHS,         "Month (abrev.)"      },
    {FORMAT_MONTHSY,        "Month (abrev.)-YY"   },
    {FORMAT_MONTHL,         "Month"               },
    {FORMAT_DAYOFWEEKS,     "Day of week (abrev.)"},
    {FORMAT_DAYOFWEEKL,     "Day of week"         },
    {FORMAT_DAYOFYEAR,      "Day of year"         },
    {FORMAT_HMS,            "HH:MM:SS"            },
    {FORMAT_MMDDHMS,        "MM-DD HH:MM:SS"      },
    {FORMAT_MMDDYYHMS,      "MM-DD-YY HH:MM:SS"   },
    {FORMAT_YYMMDDHMS,      "YY-MM-DD HH:MM:SS"   },
    {FORMAT_DEGREESLON,     "Degrees (lon)"       },
    {FORMAT_DEGREESMMLON,   "DD MM' (lon)"        },
    {FORMAT_DEGREESMMSSLON, "DD MM' SS.s\" (lon)" },
    {FORMAT_MMSSLON,        "MM' SS.s\" (lon)"    },
    {FORMAT_DEGREESLAT,     "Degrees (lat)"       },
    {FORMAT_DEGREESMMLAT,   "DD MM' (lat)"        },
    {FORMAT_DEGREESMMSSLAT, "DD MM' SS.s\" (lat)" },
    {FORMAT_MMSSLAT,        "MM' SS.s\" (lat)"    },
    {FORMAT_YYYY,           "Year (YYYY)"         },
    {FORMAT_YYDYHMS,        "YY/YDAY/HH:MM:SS.sss"}
};

const char * get_format_option_item_label(int i)
{
if (i<0 || i>FORMAT_YYDYHMS) return NULL;
else return fmt_option_items[i].label;
}

bool get_file_infos(QString file,bool & readable,bool & writeable,long & kB)//returns true if file exists, otherwise false
{
    if (file.isEmpty())
    {
    readable=writeable=false;
    kB=0;
    return false;
    }
QFileInfo fi(file);
readable=fi.isReadable();
writeable=fi.isWritable();
kB=fi.size()/1024;
return fi.exists();
}

void Replace_Dec_Sep_In_Single_String(QString & te)
{
    if (te.isEmpty()) return;
    if (OldDecimalPoint=='.')//.-->,
    {
    te.replace(QChar(','),QChar('|'));
    te.replace(QChar(OldDecimalPoint),QChar(DecimalPointToUse));
    }
    else//,-->.
    {
    te.replace(QChar(OldDecimalPoint),QChar(DecimalPointToUse));
    te.replace(QChar('|'),QChar(','));
    }
}

QString get_text_in_quotations(QString text)//returns only the text inside the quotation marks (the last(!) 2 quotations)
{
QString ret("");
QString tmp;
int st_op=text.lastIndexOf("\"");
if (st_op!=-1)
{
tmp=text.left(st_op);
st_op=tmp.lastIndexOf("\"");
    if (st_op!=-1)
    {
    ret=tmp.right(tmp.length()-st_op-1);
    }
}
return ret;
}

QString get_text_in_first_quotations(QString text)//returns only the text inside the quotation marks (the first(!) 2 quotations)
{
QString ret("");
QString tmp;
int st_op=text.indexOf("\"");
if (st_op!=-1)
{
tmp=text.right(text.length()-st_op-1);
st_op=tmp.indexOf("\"");
    if (st_op!=-1)
    {
    ret=tmp.left(st_op);
    }
}
return ret;
}

QString get_text_in_first_last_quotations(QString text)//returns only the text inside the quotation marks (beginning with the first(!) quotation and ending with the last(!) quotation)
{
QString ret("");
QString tmp;
int st_op=text.indexOf("\"");
if (st_op!=-1)
{
tmp=text.mid(st_op+1);
st_op=tmp.lastIndexOf("\"");
    if (st_op!=-1)
    {
    ret=tmp.left(st_op);
    }
}
return ret;
}

QList<int> get_text_positions(QString text,QString subtext)//get all starting positions of subtext in text
{
QList<int> pos;
int delta=subtext.length();
int cur_pos=0,next_pos=0;
pos.clear();
while ((next_pos=text.indexOf(subtext,cur_pos))>=0)
{
pos << next_pos;
cur_pos=next_pos+delta;
}
return pos;
}

void get_text_from_to(char * original,int f,int t,char * text)//gets the text between positions f and t (without f and t)
{
int len=t-f;
strncpy(text,original+f+1,len);
text[len-1]='\0';
}

QList<int> comments_from_set,comments_from_graph;
QStringList orig_saved_comment;
QStringList std_saved_comment;
QStringList orig_saved_legend;
QStringList std_saved_legend;

void save_set_comments(QList<int> & gnos,QList<int> & snos)
{
comments_from_set.clear();
comments_from_graph.clear();
orig_saved_comment.clear();
std_saved_comment.clear();
orig_saved_legend.clear();
std_saved_legend.clear();
    for (int i=0;i<gnos.length();i++)
    {
        if (is_set_active(gnos.at(i),snos.at(i)))
        {
        orig_saved_legend << g[gnos.at(i)].p[snos.at(i)].orig_lstr;
        std_saved_legend << g[gnos.at(i)].p[snos.at(i)].lstr;
        orig_saved_comment << g[gnos.at(i)].p[snos.at(i)].orig_comments;
        std_saved_comment << g[gnos.at(i)].p[snos.at(i)].comments;
        comments_from_set << snos.at(i);
        comments_from_graph << gnos.at(i);
        }
    }
}

void restore_set_comments(int c)//0=comments only, 1=legends only, 2=comments and legends
{
    for (int i=0;i<comments_from_set.length();i++)
    {
        if (is_set_active(comments_from_graph.at(i),comments_from_set.at(i)))
        {
            if (c==0 || c==2)
            {
            strcpy(g[comments_from_graph.at(i)].p[comments_from_set.at(i)].orig_comments,orig_saved_comment.at(i).toLocal8Bit().constData());
            strcpy(g[comments_from_graph.at(i)].p[comments_from_set.at(i)].comments,std_saved_comment.at(i).toLocal8Bit().constData());
            }
            if (c==1 || c==2)
            {
            strcpy(g[comments_from_graph.at(i)].p[comments_from_set.at(i)].orig_lstr,orig_saved_legend.at(i).toLocal8Bit().constData());
            strcpy(g[comments_from_graph.at(i)].p[comments_from_set.at(i)].lstr,std_saved_legend.at(i).toLocal8Bit().constData());
            }
        //g[comments_from_graph.at(i)].p[comments_from_set.at(i)].orig_lstr=copy_string(g[comments_from_graph.at(i)].p[comments_from_set.at(i)].orig_lstr,orig_saved_comment.at(i).toLocal8Bit().constData());
        //g[comments_from_graph.at(i)].p[comments_from_set.at(i)].lstr=copy_string(g[comments_from_graph.at(i)].p[comments_from_set.at(i)].lstr,std_saved_comment.at(i).toLocal8Bit().constData());
        }
    }
}

void initSettings(struct importSettings & iset,bool remove_old_settings=true)
{
    iset.valid_status=-1;//uninitialized
    if (remove_old_settings && iset.title)
        delete[] iset.title;
    if (remove_old_settings && iset.subtitle)
        delete[] iset.subtitle;
    if (remove_old_settings && iset.x_title)
        delete[] iset.x_title;
    if (remove_old_settings && iset.y_title)
        delete[] iset.y_title;
    if (remove_old_settings && iset.first_data)
        delete[] iset.first_data;
    if (remove_old_settings && iset.channel_format)
        delete[] iset.channel_format;
    if (remove_old_settings && iset.channel_size)
        delete[] iset.channel_size;
    if (remove_old_settings && iset.channel_target)
        delete[] iset.channel_target;
    if (remove_old_settings && iset.format_suggestion)
        delete[] iset.format_suggestion;
    for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
    {
        if (remove_old_settings && iset.set_title[i])
            delete[] iset.set_title[i];
    }
    iset.format_suggestion=NULL;
    iset.channel_format=NULL;
    iset.channel_size=NULL;
    iset.channel_target=NULL;
    //iset.channel_format_known=false;
    iset.first_data=NULL;
    iset.title=NULL;
    iset.subtitle=NULL;
    iset.x_title=NULL;
    iset.y_title=NULL;
    iset.first_data=NULL;
    iset.read_to_eof=false;
    iset.multiple_header_files=true;
    iset.data_is_compressed=0;
    iset.string_end_char=0;
    iset.setorder=0;
    iset.x0set=iset.deltaxset=iset.fset=false;
    iset.contains_trigger=false;
    iset.trigger_channel=-1;
    iset.trigger_type=-1;
    iset.triggervalue=0.0;
    iset.trigger_is_percent=false;
    //iset.keep_trigger=false;
    /*iset.title=new char[2];
    iset.subtitle=new char[2];*/
    iset.x0=-1.0;//negative values suggest, that this value has not been set
    iset.deltax=-1.0;
    iset.f=-1.0;
    iset.bytesize=-1;
    iset.bitsize=-1;
    iset.whole_size=-1;
    iset.single_size=-1;
    iset.channels=-1;
    iset.points=-1;
        for (int i=0;i<7;i++)//one for every column in a set
        iset.factors[i]=1.0;
        for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
        {
        iset.channel_factors[i]=1.0;//one for every set to be imported
        iset.channel_offsets[i]=0.0;
        iset.set_title[i]=NULL;
        }
    /*iset.x_title=new char[2];
    iset.y_title=new char[2];
    iset.title[0]=iset.subtitle[0]=iset.y_title[0]=iset.x_title[0]='\0';*/
    iset.target_gno=0;
    iset.set_type=0;

    iset.setorder=0;//tabDataInfo->selOrder->currentIndex();
    char dummy[8];
    strncpy(dummy,"\n",2);//tabHeader->lenEndChar->text().toLocal8Bit(),2);
    iset.string_end_char=dummy[0];
    iset.read_to_eof=false;//tabDataInfo->chkReadToEOF->isChecked();

    iset.nr_of_import_tokens=0;
    if (remove_old_settings && iset.token_target) delete[] iset.token_target;
    iset.token_target=NULL;
    iset.HeaderSuffix=QString("ini");
    iset.DataSuffix=QString("dat");

    iset.nr_of_header_values=0;
    if (remove_old_settings && iset.header_value_format) delete[] iset.header_value_format;
    if (remove_old_settings && iset.header_value_size) delete[] iset.header_value_size;
    if (remove_old_settings && iset.header_value_import) delete[] iset.header_value_import;
    iset.header_value_format=NULL;
    iset.header_value_size=NULL;
    iset.header_value_import=NULL;

    if (remove_old_settings)
    {
    iset.nr_of_counters=0;
    iset.counterTypes.clear();
    iset.counterTargets.clear();
    iset.counterSections.clear();
    iset.counterText.clear();
    iset.counterSets.clear();
    }
    iset.counterValues.clear();
    iset.preprocessingValue.clear();
    iset.preprocessingString.clear();
    if (remove_old_settings)
    {
    iset.nr_of_preprocessors=0;
    iset.preprocessingType.clear();
    iset.preprocessingSet.clear();
    iset.preprocessingTarget.clear();
    iset.preprocessingKey.clear();
    iset.preprocessingCharA.clear();
    iset.preprocessingCharB.clear();
    iset.preprocessingMultipleA.clear();
    iset.preprocessingMultipleB.clear();
    }
}

void copy_import_settings(struct importSettings * from, struct importSettings * to)
{
to->name=from->name;
to->filename=from->filename;
to->valid_status=from->valid_status;
to->header_present=from->header_present;
to->header_format=from->header_format;
to->string_end_char=from->string_end_char;
    if (from->title!=NULL)
    {
        if (to->title!=NULL) delete[] to->title;
        to->title=new char[strlen(from->title)+2];
        strcpy(to->title,from->title);
    }
    else to->title=NULL;
    if (from->subtitle!=NULL)
    {
        if (to->subtitle!=NULL) delete[] to->subtitle;
        to->subtitle=new char[strlen(from->subtitle)+2];
        strcpy(to->subtitle,from->subtitle);
    }
    else to->subtitle=NULL;
to->x0set=from->x0set;
to->deltaxset=from->deltaxset;
to->fset=from->fset;
to->read_to_eof=from->read_to_eof;
to->contains_trigger=from->contains_trigger;
//to->keep_trigger=from->keep_trigger;
to->trigger_channel=from->trigger_channel;
to->multiple_header_files=from->multiple_header_files;
to->x0=from->x0;
to->deltax=from->deltax;
to->f=from->f;
to->triggervalue=from->triggervalue;
to->trigger_is_percent=from->trigger_is_percent;
to->trigger_type=from->trigger_type;
to->bytesize=from->bytesize;
to->bitsize=from->bitsize;
to->whole_size=from->whole_size;
to->single_size=from->single_size;
to->channels=from->channels;
to->points=from->points;
to->autoscale=from->autoscale;
to->setorder=from->setorder;
    for (int i=0;i<7;i++)
    {
    to->factors[i]=from->factors[i];
    to->offsets[i]=from->offsets[i];
    }
    for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
    {
    to->channel_factors[i]=from->channel_factors[i];
    to->channel_offsets[i]=from->channel_offsets[i];
    }
    if (from->x_title!=NULL)
    {
        if (to->x_title!=NULL) delete[] to->x_title;
        to->x_title=new char[strlen(from->x_title)+2];
        strcpy(to->x_title,from->x_title);
    }
    else to->x_title=NULL;
    if (from->y_title!=NULL)
    {
        if (to->y_title!=NULL) delete[] to->y_title;
        to->y_title=new char[strlen(from->y_title)+2];
        strcpy(to->y_title,from->y_title);
    }
    else to->y_title=NULL;
    for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
    {
        if (from->set_title[i]!=NULL)
        {
        if (to->set_title[i]!=NULL) delete[] to->set_title[i];
        to->set_title[i]=new char[strlen(from->set_title[i])+2];
        strcpy(to->set_title[i],from->set_title[i]);
        }
        else
        {
        to->set_title[i]=NULL;
        }
    }
to->target_gno=from->target_gno;
to->set_type=from->set_type;
    if (from->first_data!=NULL)
    {
        if (to->first_data!=NULL) delete[] to->first_data;
        /*to->first_data=new double*[...];
            for (int i=0;i<...;i++)
            {
            to->first_data[i]=new double[...];
            memcpy(to->first_data[i],from->first_data[i],sizeof(double)*...);
            }
        */
    }
    else to->first_data=NULL;
    if (to->channels>0)
    {
        if (from->channel_format!=NULL)
        {
            if (to->channel_format!=NULL) delete[] to->channel_format;
            to->channel_format=new int[to->channels];
            memcpy(to->channel_format,from->channel_format,sizeof(int)*to->channels);
        }
        else to->channel_format=NULL;
        if (from->channel_size!=NULL)
        {
            if (to->channel_size!=NULL) delete[] to->channel_size;
            to->channel_size=new int[to->channels];
            memcpy(to->channel_size,from->channel_size,sizeof(int)*to->channels);
        }
        else to->channel_size=NULL;
        if (from->channel_target!=NULL)
        {
            if (to->channel_target!=NULL) delete[] to->channel_target;
            to->channel_target=new int[to->channels];
            memcpy(to->channel_target,from->channel_target,sizeof(int)*to->channels);
        }
        else to->channel_format=NULL;
    }
//to->channel_format_known=from->channel_format_known;
to->nr_of_header_values=from->nr_of_header_values;
if (to->nr_of_header_values>0)
{
if (from->header_value_format!=NULL)
{
    if (to->header_value_format!=NULL) delete[] to->header_value_format;
    to->header_value_format=new int[to->nr_of_header_values];
    memcpy(to->header_value_format,from->header_value_format,sizeof(int)*to->nr_of_header_values);
}
else
to->header_value_format=NULL;
if (from->header_value_size!=NULL)
{
    if (to->header_value_size!=NULL) delete[] to->header_value_size;
    to->header_value_size=new int[to->nr_of_header_values];
    memcpy(to->header_value_size,from->header_value_size,sizeof(int)*to->nr_of_header_values);
}
else
to->header_value_size=NULL;
if (from->header_value_import!=NULL)
{
    if (to->header_value_import!=NULL) delete[] to->header_value_import;
    to->header_value_import=new int[to->nr_of_header_values];
    memcpy(to->header_value_import,from->header_value_import,sizeof(int)*to->nr_of_header_values);
}
else
to->header_value_import=NULL;
}
else
{
to->header_value_format=NULL;
to->header_value_size=NULL;
to->header_value_import=NULL;
}
to->nr_of_import_tokens=from->nr_of_import_tokens;
/*cout << "nr_of_import_tokens=" << endl;
cout << "from:" << from->nr_of_import_tokens << endl;
cout << "to:  " << to->nr_of_import_tokens << endl;*/
        if (to->token_target!=NULL) delete[] to->token_target;
        to->token_target=new int[to->nr_of_import_tokens+2];
    for (int i=0;i<to->nr_of_import_tokens;i++)
    to->token_target[i]=from->token_target[i];
to->vals=from->vals;
to->keys=from->keys;
to->DataSuffix=from->DataSuffix;
to->HeaderSuffix=from->HeaderSuffix;
to->import_dest=from->import_dest;
to->import_channel_dest=from->import_channel_dest;
to->read_to_eof=from->read_to_eof;
to->data_is_compressed=from->data_is_compressed;

//qDebug() << "Copy Schema: counters=" << from->nr_of_counters << "preprocessors=" << from->nr_of_preprocessors;

to->nr_of_counters=from->nr_of_counters;
to->counterTypes=from->counterTypes;
to->counterTargets=from->counterTargets;
to->counterSections=from->counterSections;
to->counterValues=from->counterValues;
to->counterText=from->counterText;
to->counterSets=from->counterSets;

to->nr_of_preprocessors=from->nr_of_preprocessors;
to->preprocessingValue=from->preprocessingValue;
to->preprocessingString=from->preprocessingString;
to->preprocessingType=from->preprocessingType;
to->preprocessingSet=from->preprocessingSet;
to->preprocessingTarget=from->preprocessingTarget;
to->preprocessingKey=from->preprocessingKey;
to->preprocessingCharA=from->preprocessingCharA;
to->preprocessingCharB=from->preprocessingCharB;
to->preprocessingMultipleA=from->preprocessingMultipleA;
to->preprocessingMultipleB=from->preprocessingMultipleB;

}

QString get_filename_with_extension(int device)//generates a filename from the name of the document, using the extension of the given device
{
    Device_entry dev = get_device_props(device);
    /*char printfile[GR_MAXPATHLEN];
strcpy(printfile,get_docname());*/

    QFileInfo fi(QString::fromLocal8Bit(get_docname()));

/*cout << endl;
//cout << "DocName = #" << printfile << "# abs=" << fi.isAbsolute() << endl;
cout << "AbsFilePath = #" << fi.absoluteFilePath().toLocal8Bit().constData() << "#" << endl;
cout << "FileNameOnly = #" << fi.fileName().toLocal8Bit().constData() << "#" << endl;
cout << "PathOnly = #" << fi.absolutePath().toLocal8Bit().constData() << "#" << endl;
cout << "ComplBaseName = #" << fi.completeBaseName().toLocal8Bit().constData() << "#" << endl;*/

    QString fwe;
    fwe=fi.absolutePath() + QDir::separator() + fi.completeBaseName() + QString(".") + QString(dev.fext);
    //cout << "newFileName = #" << fwe.toLocal8Bit().constData() << "#" << endl;

    fwe.replace(QString("/\\"),QDir::separator());
    return fwe;

    /*if (!fi.isAbsolute())
{
strcpy(printfile,fi.absoluteFilePath().toLocal8Bit().constData());
}

char * bufptr = strrchr(printfile, '.');//search for the last '.'
if (!strcmp(get_docname(),"Untitled") || bufptr==NULL)//no real document-name, just the default OR document-name does not contain a '.'
{
strcat(printfile,".");//add a '.' at the end
}
else if (bufptr)
{
*(bufptr + 1) = '\0';//remove extensions
}
strcat(printfile,dev.fext);//add the appropriate extension
return QString(printfile);*/
}

int nr_of_true_changes(QStringList & list)
{
    static int nr,len;
    static QString ref("with");
    nr=list.length();
    len=nr;
    for (int i=0;i<nr;i++)
    {
        if (list.at(i).indexOf(ref)==0)//contains with at the beginning
            len--;
    }
    return len;
}

void prependAllSetID(QString * text,int sno,int gno)
{
static const char * tosuppl[7]={"X","Y","Y0","Y1","Y2","Y3","Y4"};
    QString str(text->toLocal8Bit());
    QString l1;
    QString toinsert;
//#if QT_VERSION >= 0x060000
    QRegularExpressionMatch rm;
    QRegularExpression regex1("G\\d+.S\\d+.$");//what we search for as a regular expression
    QRegularExpression regex2("S\\d+.$");//I changed the expression to '+' from '*' because we want to find at least one digit (0 digits is not allowed)
    QRegularExpression regex3("G\\d+N{1}.S\\d+N{1}$");//generate a new graph and / or a set
    QRegularExpression regex4("G\\d+N{1}$");//generate just a new graph
    QRegularExpression regex5("S\\d+N{1}$");//generate just a new set
/*#else
    QRegExp regex1("G\\d+.S\\d+.$");//what we search for as a regular expression
    QRegExp regex2("S\\d+.$");//I changed the expression to '+' from '*' because we want to find at least one digit (0 digits is not allowed)
    QRegExp regex3("G\\d+N{1}.S\\d+N{1}$");//generate a new graph and / or a set
    QRegExp regex4("G\\d+N{1}$");//generate just a new graph
    QRegExp regex5("S\\d+N{1}$");//generate just a new set
#endif*/
//QString find_new_set_command(QString newCommand)


    char dummy1[128];
    char dummy2[128];
    sprintf(dummy1,"G%d.",gno);
    sprintf(dummy2,"G%d.S%d.",gno,sno);
    int pos=0,t_pos=0,inlen;//last=0
    int p1,pos_1,pos_2;
    char c1;
    pos_1=text->indexOf("\"");
    if (pos_1<0)//no quotation marks found
    {
    pos_2=pos_1;
    }
    else
    {
    pos_2=text->indexOf("\"",pos_1+1);
        if (pos_2<0)
        {
        errmsg(QObject::tr("Opening quotation mark without closing mark found in command.").toLocal8Bit().constData());
        errmsg(text->toLocal8Bit().constData());
        return;
        }
    }
//qDebug() << "prepend: start=" << str;
    for (int i=0;i<2;i++)//find replacements for all sus (Y0...Y4 are automatically replaced during the search for Y)
    {
        pos=0;
        while (pos<str.length())
        {
            //last=pos;//last is position at beginning of search
            //we search here for X,Y,Y0,Y1,...,Y4
            pos=str.indexOf(tosuppl[i],pos);//pos is now the position of the string we search for
//qDebug() << "str=" << str << " pos=" << pos;
            //we have to ingore values with '_' before or after, because these are commands not set-ids
            if (pos==0 && str.length()>1)
            {
                if (str.at(pos+1).toLatin1()=='_')//we have a '_' after it
                {
                pos++;
                continue;
                }
            }
            else if (pos>0 && pos<=str.length()-1)
            {
                if (pos<str.length()-1 && (str.at(pos+1).toLatin1()=='_' || str.at(pos-1).toLatin1()=='_'))//not the last character
                {
                    pos++;
                    continue;
                }
                else if (isalpha(str.at(pos-1).toLatin1()) || str.at(pos-1).toLatin1()=='.')//there is a character in front of it --> ignore it
                {
                    pos++;
                    continue;
                }
                else if (pos<=str.length()-2 && isalpha(str.at(pos+1).toLatin1()))//there is a character after it --> ignore it
                {
                    pos++;
                    continue;
                }
                else if (pos==str.length()-1)//the last character
                {
                    if (str.at(pos-1).toLatin1()=='_')
                    {
                    pos++;
                    continue;
                    }
                }
            }
            //cout << "pos=" << pos << endl;
            //ok, we ignored the ones with '_' in front or after
            if (pos==-1)//nothing found
            {
                //last=
                pos=str.length()+1;//nothing found-->set current position to the end of the string
            }
            else
            {
                l1=str.left(pos);
                rm=regex1.match(l1,0);
                p1=rm.capturedStart();
                //p1=regex1.indexIn(l1);
                if (p1==-1)//expression not found --> id not complete
                {
                    rm=regex1.match(l1,0);
                    p1=rm.capturedStart();
                    //p1=regex2.indexIn(l1);
                    rm=regex3.match(l1,0);
                    t_pos=rm.capturedStart();
                    //t_pos=regex3.indexIn(l1);
                    //cout << "p1=" << p1 << " t_pos=" << t_pos << endl;
                        if (p1==t_pos && p1!=-1)//S0N and S0 are at the same position --> ignore this!
                        {
                        pos++;
                        continue;
                        }
                    if (p1==-1)//no usual set-id --> search for S$ and S_
                    {
                    p1=l1.indexOf("S$");
                        if (p1==-1)
                        p1=l1.indexOf("S_");
                    }
                    if (p1==-1)//expression not found --> no id at all
                    {
                    //cout << "expression found at#" << str.mid(pos).toLatin1().constData() << "#" << endl;
                        c1='\0';
                        if (pos>0)//there are characters in front
                        {
                            c1=str.at(pos-1).toLatin1();
                            if (!isalpha(c1))
                                c1='\0';
                        }
                        if (pos_1>=0)//there are some quotation-marks present
                        {
                            if (pos>=pos_1 && pos<=pos_2)//found index inside quotations
                            {
                            c1='\0';
                            }
                        }
                        if (c1=='\0')//do the replacement
                        {
                            toinsert=QString(dummy2);
                            inlen=toinsert.length();
                            //cout << "full: str=" << str.toAscii().constData() << " pos=" << pos << endl;
                            str.insert(pos,toinsert);
                            pos+=inlen+1;
                        }
                        else//no replacement --> go on searching, starting with the next character
                        {
                            pos++;
                        }
                    }
                    else//expression found --> id only simplified --> 'G0.' missing
                    {
                        toinsert=QString(dummy1);
                        inlen=toinsert.length();
                        //cout << "only G: str=" << str.toAscii().constData() << " pos=" << pos << endl;
                        str.insert(p1,toinsert);
                        pos+=inlen+1;
                    }
                }
                else//complete id found --> do nothing
                {
                    pos=pos+1;//search on from last position
                }
            }//end of if
        }//end while
    }//end of go throught all substrings
    *text=str;
}

void prependSetID_single(QString & text,int leftset,int leftgraph,int rightset,int rightgraph)
{
QString leftpart,rightpart,result;
int len,eq_pos;
    len=text.length();
    eq_pos=text.indexOf(QString("="));
        if (eq_pos==-1)
        {
        result=text;
        prependAllSetID(&result,leftset,leftgraph);
        }
        else
        {
        leftpart=text.left(eq_pos);
        rightpart=text.right(len-eq_pos-1);
//qDebug() << "Left:  G[" << leftgraph << "].S[" << leftset << "]";
//qDebug() << "Right: G[" << rightgraph << "].S[" << rightset << "]";
//qDebug() << "#" << leftpart.toLocal8Bit().constData() << "#=#" << rightpart.toLocal8Bit().constData() << "#";
        prependAllSetID(&leftpart,leftset,leftgraph);
        prependAllSetID(&rightpart,rightset,rightgraph);
        result=leftpart+QString("=")+rightpart;
        }
text=result;
}

void prependAllIDs_V2(QString & text,int n_gno,int n_sno)//just complete incomplete IDs (no replacement and no resolvement of S0N or S# or similar)
{
int f_ret,f_pos,g_no,s_no,st_len;
char control1,control2,col;
int st_pos=0;
QString newText,tmpText;
newText.clear();
qDebug() << "Make IDs complete: before=" << text;
while ( (f_ret=searchTextForFirstID(text,st_pos,f_pos,g_no,s_no,control1,control2,col,st_len))!=ID_NONE )//as long as we find something
{
qDebug() << "st_pos=" << st_pos << " type=" << f_ret << " found ID at " << f_pos << ": " << text.mid(f_pos,st_len) << " st_len=" << st_len;
tmpText=createCompleteID(f_ret,n_gno,n_sno,g_no,s_no,control1,control2,col);
qDebug() << "   new ID=" << tmpText;
qDebug() << "   text before=" << text.mid(st_pos,f_pos-st_pos);
newText+=text.mid(st_pos,f_pos-st_pos);
/*
if (st_pos==0 && f_pos>0)
newText+=text.mid(st_pos,f_pos);//add text before found ID
*/
    if (tmpText.isEmpty())//no replacement needed
    {
    newText+=text.mid(f_pos,st_len);
    qDebug() << "   adding=" << text.mid(f_pos,st_len);
    }
    else
    {
    newText+=tmpText;//insert new (complete ID)
    qDebug() << "   adding=" << tmpText;
    }
st_pos=f_pos+st_len;
qDebug() << "newText so far=" << newText;
qDebug() << "searching in  =" << text.mid(st_pos);
}
newText+=text.mid(st_pos,f_pos);//add text at the end
qDebug() << "   finally adding=" << text.mid(st_pos,f_pos);
text=newText;
qDebug() << "Make IDs complete: after=" << text;
}

void replaceAllIDs_V2(QString & text,int n_gno,int n_sno)//assumes all IDs are complete --> just replace the IDs and resolve things like S0N and S#
{
int f_ret,f_pos,g_no,s_no,st_len;
char control1,control2,col;
int st_pos=0;
QString newText,tmpText;
newText.clear();
qDebug() << "Replace IDs: before=" << text;
while ( (f_ret=searchTextForFirstID(text,st_pos,f_pos,g_no,s_no,control1,control2,col,st_len))!=ID_NONE )//as long as we find something
{
qDebug() << "st_pos=" << st_pos << " type=" << f_ret << " found ID at " << f_pos << ": " << text.mid(f_pos,st_len) << " st_len=" << st_len;
    tmpText=createReplacementID(f_ret,n_gno,n_sno,g_no,s_no,control1,control2,col);
qDebug() << "   new ID=" << tmpText;
qDebug() << "   text before=" << text.mid(st_pos,f_pos-st_pos);
    newText+=text.mid(st_pos,f_pos-st_pos);
        if (tmpText.isEmpty())//no replacement needed
        {
        newText+=text.mid(f_pos,st_len);
qDebug() << "   adding=" << text.mid(f_pos,st_len);
        }
        else
        {
        newText+=tmpText;//insert new (complete ID)
qDebug() << "   adding=" << tmpText;
        }
    st_pos=f_pos+st_len;
qDebug() << "newText so far=" << newText;
qDebug() << "searching in  =" << text.mid(st_pos);
    }
    newText+=text.mid(st_pos,f_pos);//add text at the end
qDebug() << "   finally adding=" << text.mid(st_pos,f_pos);
text=newText;
qDebug() << "Replace IDs: after=" << text;
}

void prependSetID(char * text,int leftset,int leftgraph,int rightset,int rightgraph);

void prependSetID(QString & text,int leftset,int leftgraph,int rightset,int rightgraph)
{
char * original=new char[text.length()*2+8];
strcpy(original,text.toLocal8Bit().constData());
prependSetID(original,leftset,leftgraph,rightset,rightgraph);
text=QString::fromLocal8Bit(original);
}

void prependSetID(char * text,int leftset,int leftgraph,int rightset,int rightgraph)
{
    //QString leftpart,rightpart
    QString result,final_result;
    QString before,inside,after;
    QList<int> quot_list;
    //int len,eq_pos
    int nr_of_quotations;
//left id is target id
//right id is source id
    QString original(text);
    original=original.toUpper();
    QStringList list1=original.split(";");
//qDebug() << "PrependSetID=" << original;
//qDebug() << "Left=G" << leftgraph << ".S" << leftset << " Right=G" << rightgraph << ".S" << rightset;
    final_result.clear();
    for (int i=0;i<list1.length();i++)//work through every commant in the list separately
    {
    original=list1.at(i);
    //first find quotations
    quot_list=get_text_positions(original,QString("\""));
    nr_of_quotations=quot_list.length();
//qDebug() << "nr_of_quotations=" << nr_of_quotations;
        if (nr_of_quotations % 2)//number of quotation marks does not match!
        {
        errmsg(QObject::tr("Opening quotation mark without closing mark found in command.").toLocal8Bit().constData());
        errmsg(original.toLocal8Bit().constData());
        //no replacing if quotations do not match! (because we cannot be sure what to do)
        result=original;
        }
        else if (nr_of_quotations==0)//no quotation-marks
        {
        result=original;
        prependSetID_single(result,leftset,leftgraph,rightset,rightgraph);
        }
        else//there are quotation-marks
        {
        before=original.left(quot_list.at(0));
        prependSetID_single(before,leftset,leftgraph,rightset,rightgraph);

        inside=get_text_in_first_quotations(original);
        prependSetID_single(inside,leftset,leftgraph,rightset,rightgraph);

        after=original.right(original.length()-1-quot_list.at(1));
        quot_list=get_text_positions(after,QString("\""));
            if (quot_list.length()==0)
            {
            prependSetID_single(after,leftset,leftgraph,rightset,rightgraph);
            }
            else
            {
            prependSetID(after,leftset,leftgraph,rightset,rightgraph);
            }
        result=before+QString("\"")+inside+QString("\"")+after;
        }
//qDebug() << i << ": " << list1.at(i);
/*
        result=original;
prependSetID_single(result,leftset,leftgraph,rightset,rightgraph);

    len=original.length();
    eq_pos=original.indexOf(QString("="));
        if (eq_pos==-1)
        {
        result=original;
        prependAllSetID(&result,leftset,leftgraph);
        }
        else
        {
        leftpart=original.left(eq_pos);
        rightpart=original.right(len-eq_pos-1);
//qDebug() << "Left:  G[" << leftgraph << "].S[" << leftset << "]";
//qDebug() << "Right: G[" << rightgraph << "].S[" << rightset << "]";
//qDebug() << "#" << leftpart.toLocal8Bit().constData() << "#=#" << rightpart.toLocal8Bit().constData() << "#";
        prependAllSetID(&leftpart,leftset,leftgraph);
        prependAllSetID(&rightpart,rightset,rightgraph);
        result=leftpart+QString("=")+rightpart;
        }
*/
    final_result+=result;
    if (i<list1.length()-1) final_result+=QString(";");
    }
    strcpy(text,final_result.toLocal8Bit().constData());
//qDebug() << "result=#" << text << "#";
}

/*int find_pos_of_inclomplete_setid(char * text,char * tofind,char ** pos)
{
int ret=-1;//-1=nothing found; 0=fully incomplete; 1=only GraphId missing; 2=found and complete
int pos2;
*pos=strstr(text,tofind);
while (pos!=NULL)//go on until suitable command found
{//we found a position
ret=*pos-text;
if (ret>0)
{
pos2=ret-1;
    if (text[pos2]!='.')//-->incomplete, ret is position of incomplete description
    {
    ret=0;
    break;
    }
    else//may be incomplete, but '.' before
    {
    pos2--;
    while (pos2>0 && isdigit(text[pos2])) pos2--;//try to find description before Column-Description
        if (pos2<=1)//incomplete
        {
        *pos=text;
        ret=0;
        }
        else//we presume: we have found a 'S'
        {
        pos2--;
        if (text[pos2]!='.')
        {
        ret=1;
        *pos=text+pos2+1;
        break;
        }
        else
        {
        ret=2;
        break;
        }
        }
    }
}
else
{
ret=0;
break;//found at first character --> not complete!
}
*pos=strstr(*pos+1,tofind);
}
return ret;
}

void include_str(char * text,char * pos,char * toinclude)
{
if (!pos) return;
char * dummy=new char[strlen(text)+strlen(toinclude)+2];
//cout << "include#" << text << "#" << pos << "#" << toinclude << "#" << endl;
strcpy(dummy,text);
strcpy(dummy+(pos-text),toinclude);
strcpy(dummy+(pos-text+strlen(toinclude)),pos);
strcpy(text,dummy);
delete[] dummy;
}

void correct_formula(char * text,int gno,int sno)//takes a formula and supplements all x,y,y1,y2,y3,y4 by 'G0.S0.' or something apropriate according to gno and sno
{
static char suppl[32], suppl2[16], temp[1024];
static char * tosuppl[7]={"X","Y","Y0","Y1","Y2","Y3","Y4"};
static char * n_pos,*n_pos2;
static unsigned int len;
static int pos,retu;
sprintf(suppl,"G%d.S%d.",gno,sno);
sprintf(suppl2,"G%d.",gno);
len=strlen(text);
char result[128+strlen(text)];
    for (unsigned int i=0;i<len;i++)
    result[i]=toupper(text[i]);
for (int i=0;i<7;i++)
{//supplement the entries
n_pos2=result;
while (n_pos2)
{
retu=find_pos_of_inclomplete_setid(n_pos2,tosuppl[i],&n_pos);
cout << "text=#" << result << "#retu=" << retu << endl;
    switch (retu)
    {
    case 0://0=fully incomplete
    include_str(result,n_pos,suppl);
        if (n_pos)
        n_pos+=strlen(suppl);
    break;
    case 1://1=only GraphId missing
    include_str(result,n_pos,suppl2);
        if (n_pos)
        n_pos+=strlen(suppl2);
    break;
    default:
    n_pos=NULL;
    break;
    }
cout << "text=#" << result << "#retu=" << retu << endl;
if (n_pos) cout << "npos=#" << n_pos << "#" << endl;
        if (n_pos)
        n_pos2=n_pos+1;
        else
        n_pos2=NULL;
}//end while loop

}//end supplements
strcpy(text,result);
}*/

int should_open_grace_file_dialog(void)
{//returns TRUE if the Grace-file-dialog is to be used and FALSE if the dialog of the operating system should be used directly
static int ret=TRUE;
Qt::KeyboardModifiers modif=Qt::NoModifier;
        #if QT_VERSION >= 0x050000
        modif=QApplication::queryKeyboardModifiers();
        #endif
    if (general_behavior==0)//Grace-behavior
    {
    ret=TRUE;
    }
    else//QtGrace-behavior
    {
    ret=FALSE;
    }
    if (modif & Qt::ControlModifier)
    {
    ret=!ret;
    }
return ret;
}

/* 'Legacy' FFT code from Grace v5.99*/
int bit_swap_v6(int i, int nu);
int ilog2_v6(int n);
int fft_v6(double *jr, double *ji, int n, int nu, int iflag);

int fourier_v6(double *jr, double *ji, int n, int iflag)
{
    int i2= ilog2(n);

    /*if ((i2 = ilog2(n)) > 0) {*/
    return fft_v6(jr, ji, n, i2, iflag);
    /*} else {
        return dft(jr, ji, n, iflag);
    }*/
}

/*
   real_data ... ptr. to real part of data to be transformed
   imag_data ... ptr. to imag  "   "   "   "  "      "
   inv ..... Switch to flag normal or inverse transform
   n_pts ... Number of real data points
   nu ...... logarithm in base 2 of n_pts e.g. nu = 5 if n_pts = 32.
*/
int fft_v6(double *real_data, double *imag_data, int n_pts, int nu, int inv)
{
    int n2, i, ib, mm, k;
    int sgn, tstep;
    double tr, ti, arg; /* intermediate values in calcs. */
    double c, s;        /* cosine & sine components of Fourier trans. */
    static double *sintab = NULL;
    static int last_n = 0;

    n2 = n_pts / 2;

    if (n_pts != last_n) { /* allocate new sin table */
        arg = 2*M_PI/n_pts;
        last_n = 0;
        sintab = (double *)xrealloc(sintab, n_pts*sizeof(double));
        if (sintab == NULL) {
            return RETURN_FAILURE;
        }
        for (i = 0; i < n_pts; i++) {
            sintab[i] = sin(arg*i);
        }
        last_n = n_pts;
    }

    /*
 * sign change for inverse transform
 */
    sgn = inv ? 1:-1;

    /* do bit reversal of data in advance */
    for (k = 0; k != n_pts; k++) {
        ib = bit_swap_v6(k, nu);
        if (ib > k) {
            fswap((real_data + k), (real_data + ib));
            fswap((imag_data + k), (imag_data + ib));
        }
    }
    /*
* Calculate the componets of the Fourier series of the function
*/
    tstep = n2;
    for (mm = 1; mm < n_pts; mm *= 2) {
        int sinidx = 0, cosidx = n_pts/4;
        for (k=0; k<mm; k++) {
            c = sintab[cosidx];
            s = sgn*sintab[sinidx];
            sinidx += tstep;
            cosidx += tstep;
            if (sinidx >= n_pts) {
                sinidx -= n_pts;
            }
            if (cosidx >= n_pts) {
                cosidx -= n_pts;
            }
            for (i = k; i < n_pts; i += mm*2) {
                double re1, re2, im1, im2;
                re1 = real_data[i];
                im1 = imag_data[i];
                re2 = real_data[i + mm];
                im2 = imag_data[i + mm];

                tr = re2*c + im2*s;
                ti = im2*c - re2*s;
                real_data[i+mm] = re1 - tr;
                imag_data[i+mm] = im1 - ti;
                real_data[i] = re1 + tr;
                imag_data[i] = im1 + ti;
            }
        }
        tstep /= 2;
    }

    return RETURN_SUCCESS;
}

/*
* Bit swapping routine in which the bit pattern of the integer i is reordered.
* See Brigham's book for details
*/
int bit_swap_v6(int i, int nu)
{
    int ib, i1, i2;

    ib = 0;

    for (i1 = 0; i1 != nu; i1++) {
        i2 = i/2;
        ib = ib*2 + i - 2*i2;
        i = i2;
    }
    return (ib);
}

/*
 * log base 2
 */
int ilog2_v6(int n)
{
    int i = 0;
    int n1 = n;

    while (n1 >>= 1) {
        i++;
    }
    if (1 << i != n) {
        return -1;
    } else {
        return i;
    }
}

int monospaced_v6(double *array, int len, double *space)
{
    int i;
    double eps;
    if (len < 2) {
        //errmsg(tr("Monospacing of an array of length < 2 is meaningless").toLocal8Bit().constData());
        return FALSE;
    }
    *space = array[1] - array[0];
    eps = fabs((array[len - 1] - array[0]))*1.0e-6; /* FIXME */
    for (i = 2; i < len; i++) {
        if (fabs(array[i] - array[i - 1] - *space) > eps) {
            return FALSE;
        }
    }
    return TRUE;
}

void remove_whitespaces(char * tar,char * ch)
{
    int len=strlen(ch),pos=0;
    int text_counter=0;
    tar[0]='\0';
    for (int i=0;i<len;i++)
    {
        if (ch[i]=='\"')
        {
        text_counter=!text_counter;
        continue;
        }
            if (!isspace(ch[i]) && text_counter==0)
            tar[pos++]=ch[i];
    }
    tar[pos++]='\0';
}

void remove_a_character(char * tar,char * ch,char a)//removes character 'a' from ch and write resulte to tar
{
    int len=strlen(ch),pos=0;
    tar[0]='\0';
    for (int i=0;i<len;i++)
    {
        if (ch[i]==a) continue;
    tar[pos++]=ch[i];
    }
    tar[pos++]='\0';
}

void remove_beginning_whitespaces(QString & text)
{
QString text2;
text2.clear();
bool first_non_space=false;
//qDebug() << "Text=" << text << "length=" << text.length();
    for (int i=0;i<text.length();i++)
    {
        if (!text.at(i).isSpace() || first_non_space)
        {
        text2+=text.at(i);
        first_non_space=true;
        }
    }
text=text2;
}

void remove_beginning_whitespaces2(char * text)
{
QString str(text);
remove_beginning_whitespaces(str);
strcpy(text,str.toLatin1().constData());
}

void strToUpper(char * tar,const char * ch)
{
    int len=strlen(ch);
    for (int i=0;i<len;i++)
        tar[i]=toupper(ch[i]);
    tar[len]=ch[len];
}

int find_dev_nr(const char * dev_name)/*my own number of devices*/
{
    int nr=-1;
    if (!strcmp(dev_name,"JPEG"))
    {
        nr=DEVICE_JPEG;
    }
    else if (!strcmp(dev_name,"BMP"))
    {
        nr=DEVICE_BMP;
    }
    else if (!strcmp(dev_name,"EPS"))
    {
        nr=DEVICE_EPS;
    }
    else if ((!strcmp(dev_name,"PS")) || (!strcmp(dev_name,"PostScript")))
    {
        nr=DEVICE_PS;
    }
    else if (!strcmp(dev_name,"PNM"))
    {
        nr=DEVICE_PNM;
    }
    else if (!strcmp(dev_name,"PNG"))
    {
        nr=DEVICE_PNG;
    }
    else if ((!strcmp(dev_name,"X11")) || (!strcmp(dev_name,"SCREEN")))
    {
        nr=DEVICE_SCREEN;
    }
    else if (!strcmp(dev_name,"PDF"))
    {
        nr=DEVICE_PDF;
    }
    else if (!strcmp(dev_name,"TIFF"))
    {
        nr=DEVICE_TIFF;
    }
    return nr;
}

/*with QT the JPG and PNG and BMP file types are easily accessible, but only very few options are available*/
static Device_entry dev_jpg = {DEVICE_FILE,
                               "JPEG",
                               init_null,
                               parser_null,
                               setup_null,
                               "jpg",
                               FALSE,
                               TRUE,
                               {DEFAULT_PAGE_WIDTH, DEFAULT_PAGE_HEIGHT, 72.0},
                               NULL,
                               1,
                               "JPG"
                              };

static Device_entry dev_png = {DEVICE_FILE,
                               "PNG",
                               init_null,
                               parser_null,
                               setup_null,
                               "png",
                               FALSE,
                               TRUE,
                               {DEFAULT_PAGE_WIDTH, DEFAULT_PAGE_HEIGHT, 72.0},
                               NULL,
                               1,
                               ""
                              };

static Device_entry dev_bmp = {DEVICE_FILE,
                               "BMP",
                               init_null,
                               parser_null,
                               setup_null,
                               "bmp",
                               FALSE,
                               TRUE,
                               {DEFAULT_PAGE_WIDTH, DEFAULT_PAGE_HEIGHT, 72.0},
                               NULL,
                               1,
                               ""
                              };

static Device_entry dev_tif = {DEVICE_FILE,
                               "TIFF",
                               init_null,
                               parser_null,
                               setup_null,
                               "tif",
                               FALSE,
                               TRUE,
                               {DEFAULT_PAGE_WIDTH, DEFAULT_PAGE_HEIGHT, 72.0},
                               NULL,
                               1,
                               "TIF"
                              };

extern int register_high_png_drv(void);

#define cg get_cg()

void register_qt_devices(void)
{
    register_device(dev_jpg);
    register_device(dev_png);
    //register_high_png_drv();
    register_device(dev_bmp);
    register_device(dev_tif);//added in v0.26
}

frmEditColumnProp::frmEditColumnProp(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Edit set properties"));
    setWindowIcon(QIcon(*GraceIcon));
    int number;
    QString entr[MAX_SET_COLS+2>NUM_FMT_OPTION_ITEMS+2?MAX_SET_COLS+2:NUM_FMT_OPTION_ITEMS+2];
    number=MAX_SET_COLS;
    entr[0]=QString("X");
    entr[1]=QString("Y");
    for (int i=2;i<MAX_SET_COLS;i++)
    {
    entr[i]=QString("Y")+QString::number(i-1);
    }
    selColumn=new StdSelector(this,tr("Column:"),number,entr);
    /*number=4;
    entr[0]=tr("Decimal");
    entr[1]=tr("General");
    entr[2]=tr("Exponential");
    entr[3]=tr("Date/time");*/
    number=NUM_FMT_OPTION_ITEMS;
    for (int i=0;i<number;i++)
    {
    entr[i]=QString(fmt_option_items[i].label);
    }
    selFormat=new StdSelector(this,tr("Format:"),number,entr);
    selFormat->setCurrentIndex(SpreadsheetColumnFormat);
    selPrecision=new stdIntSelector(this,tr("Precision:"),0,20);
    selPrecision->setValue(SpreadsheetColumnPrecision);
    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));

    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->addWidget(selColumn);
    layout->addWidget(selFormat);
    layout->addWidget(selPrecision);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    resize(LastSize_EditColumnProp);
    setModal(TRUE);
}

frmEditColumnProp::~frmEditColumnProp()
{
    LastSize_EditColumnProp=this->size();
}

void frmEditColumnProp::doApply(void)
{
    ApplyError=false;
    int col=selColumn->currentIndex();
    int format=selFormat->currentValue();
    int prec=selPrecision->value();
    col_format[col]=format;
    col_precision[col]=prec;
    emit(newColumnFormat(col,format,prec));
}

void frmEditColumnProp::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmEditColumnProp::doClose(void)
{
    hide();
}

void frmEditColumnProp::initToColumn(int i)
{
    selColumn->setCurrentIndex(i);
    selFormat->setCurrentIndex(col_format[i]);
    selPrecision->setValue(col_precision[i]);
}

frmSpreadSheet::frmSpreadSheet(QWidget * parent,int g_no,int s_no):QDialog(parent)
{
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Spreadsheet dataset editor"));
    setWindowIcon(QIcon(*GraceIcon));
    CreateActions();
    gno=g_no;
    sno=s_no;
    parentList=NULL;
    EditColumn=new frmEditColumnProp(this);
    EditColumn->hide();
    connect(EditColumn,SIGNAL(newColumnFormat(int,int,int)),SLOT(setColumnFormat(int,int,int)));

    menuBar=new QMenuBar(this);
    mnuFile=new QMenu(tr("&File"));
    mnuFile->setTearOffEnabled(TRUE);
    mnuFile->addAction(actClose);
    mnuEdit=new QMenu(tr("&Edit"));
    mnuEdit->setTearOffEnabled(TRUE);
    mnuEdit->addAction(actAddRow);
    mnuEdit->addAction(actDelSelRow);
    mnuEdit->addSeparator();
    mnuEdit->addAction(actColumnFormat);
    mnuEdit->addSeparator();
    mnuEdit->addAction(actSelectEven);
    mnuEdit->addAction(actSelectOdd);
    mnuEdit->addAction(actCopySelected);
    mnuHelp=new QMenu(tr("&Help"));
    mnuHelp->setTearOffEnabled(TRUE);
    mnuHelp->addAction(actHelpOnContext);
    mnuHelp->addSeparator();
    mnuHelp->addAction(actHelpOnDataSetEditor);
    menuBar->addMenu(mnuFile);
    menuBar->addMenu(mnuEdit);
    menuBar->addSeparator();
    menuBar->addMenu(mnuHelp);

    for (int i=0;i<MAX_SET_COLS;i++)
    {
        col_format[i]=SpreadsheetColumnFormat;
        col_precision[i]=SpreadsheetColumnPrecision;
        EditColumn->col_format[i]=col_format[i];
        EditColumn->col_precision[i]=col_precision[i];
    }

    sprintf(dummy," G%d.S%d",gno,sno);
    fraDataset=new QGroupBox(tr("Dataset") + QString(dummy),this);

    int number=NUMBER_OF_SETTYPES;
    QString entr[NUMBER_OF_SETTYPES>NUM_FMT_OPTION_ITEMS?NUMBER_OF_SETTYPES:NUM_FMT_OPTION_ITEMS];
    for (int i=0;i<NUMBER_OF_SETTYPES;i++)
    {
        strToUpper(dummy,set_types(i));
        entr[i]=QString(dummy);
    }
    selType=new StdSelector(fraDataset,tr("Type:"),number,entr);
    connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(changeDataSet(int)));

    ledComment=new stdLineEdit(fraDataset,tr("Comment:"),true);
    ledComment->lenText->setText(tr("Editor"));

    chkShowStrings=new QCheckBox(tr("Show string column"),fraDataset);
    chkShowStrings->setToolTip(tr("Show column with hidden strings"));
    chkShowStringOperations=new QCheckBox(tr("Show string operations"),fraDataset);
    chkShowStringOperations->setToolTip(tr("Show possible operations for strings"));
    number=2;
    entr[0]=QString("A");
    entr[1]=QString("B");
    selConvertTo=new StdSelector(fraDataset,tr("   Target column:"),number,entr);
    selConvertTo->setToolTip(tr("When trying to convert the strings write the results to this column"));
    number=NUM_FMT_OPTION_ITEMS;
    for (int i=0;i<number;i++)
    {
        entr[i]=QString(fmt_option_items[i].label);
    }
    selFormat=new StdSelector(fraDataset,tr("   String data format:"),number,entr);
    selFormat->setToolTip(tr("When trying to convert the strings into numbers or dates assume the strings to be in this format."));
    number=2;
    entr[0]=QString(".");
    entr[1]=QString(",");
    selDecSep=new StdSelector(fraDataset,tr("Decimal separator:"),number,entr);
    selDecSep->setToolTip(tr("The decimal separator to be used for the conversion of the String-column."));

    selInvalidVal=new LineWidthSelector(this);
    selInvalidVal->lblText->setText(tr("Value for invalid data:"));
    selInvalidVal->setToolTip(tr("This value will be used whenever a data-entry could not be read.\nYou should put something here that is very obviously outside of the usual range of data-values."));
    selInvalidVal->spnLineWidth->setRange(-1000000.0,1000000.0);
    selInvalidVal->spnLineWidth->setSingleStep(1.0);
    selInvalidVal->setValue(-100.0);

    cmdConvertStrings=new QPushButton(tr("Strings --> target column"),fraDataset);
    cmdConvertStrings->setToolTip(tr("Convert the strings and put the values in the selected column"));
    cmdRemoveStrings=new QPushButton(tr("Remove string column"),fraDataset);
    cmdRemoveStrings->setToolTip(tr("Pressing this button will remove the string-column and all strings in it"));
    layout0=new QGridLayout;
    //layout0->setMargin(STD_MARGIN);
    layout0->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout0->setSpacing(STD_SPACING);
    layout0->addWidget(selType,0,0,1,2);
    layout0->addWidget(ledComment,1,0,1,2);
    layout0->addWidget(chkShowStrings,2,0,1,1);
    layout0->addWidget(chkShowStringOperations,2,1,1,1);
    layout0->addWidget(selConvertTo,3,0,1,2);
    layout0->addWidget(selFormat,4,0,1,2);
    layout0->addWidget(selDecSep,5,0,1,1);
    layout0->addWidget(selInvalidVal,5,1,1,1);
    layout0->addWidget(cmdConvertStrings,6,0,1,1);
    layout0->addWidget(cmdRemoveStrings,6,1,1,1);
    fraDataset->setLayout(layout0);

    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(chkShowStrings,SIGNAL(toggled(bool)),this,SLOT(showStringsToggled(bool)));
    connect(chkShowStringOperations,SIGNAL(toggled(bool)),this,SLOT(showStringsOperationsToggled(bool)));
    connect(cmdConvertStrings,SIGNAL(clicked()),this,SLOT(doConvertStrings()));
    connect(cmdRemoveStrings,SIGNAL(clicked()),this,SLOT(doRemoveStrings()));

    model=new SetTableModel(gno,sno,col_format,col_precision,this);
    model->setStringsEnabled(false);
    table=new QTableView(this);
    table->setModel(model);
    table->setSelectionBehavior(QAbstractItemView::SelectRows);
    connect(model,SIGNAL(item_entry_changed(int,int,bool)),this,SLOT(itemChanged(int,int,bool)));
    connect(model,SIGNAL(row_or_col_count_changed()),this,SLOT(minimalItemChanged()));
    connect(table->horizontalHeader(),SIGNAL(sectionClicked(int)),SLOT(HHeaderClicked(int)));
    connect(model,SIGNAL(newStringColumn()),this,SLOT(stringDataChanged()));

    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(0);
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar);
#endif
    layout->addWidget(fraDataset);
    layout->addWidget(table);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    showStringsToggled(false);
    buttonGroup->cmdClose->setDefault(true);
    resize(LastSize_Spreadsheets);
    update_entries();
}

frmSpreadSheet::~frmSpreadSheet()
{
    removeLineWidthSelector(selInvalidVal);
    LastSize_Spreadsheets=this->size();
}

void frmSpreadSheet::HHeaderClicked(int i)
{
    EditColumn->initToColumn(i);
    EditColumn->show();
    EditColumn->raise();
}

void frmSpreadSheet::init(int g_no,int s_no)
{
    if (model->blockUpdate==true) return;
    gno=g_no;
    sno=s_no;
    disconnect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(changeDataSet(int)));
    disconnect(chkShowStrings,SIGNAL(toggled(bool)),this,SLOT(showStringsToggled(bool)));
    disconnect(chkShowStringOperations,SIGNAL(toggled(bool)),this,SLOT(showStringsOperationsToggled(bool)));
    selType->setCurrentIndex(dataset_type(g_no,s_no));
    for (int i=0;i<MAX_SET_COLS;i++)
    {
        if (is_valid_setno(gno,sno))//existing set
        {
        col_format[i]=g[gno].p[sno].pref_col_format[i];
        col_precision[i]=g[gno].p[sno].pref_col_prec[i];
        }
        else
        {// new set
        col_format[i]=SpreadsheetColumnFormat;
        col_precision[i]=SpreadsheetColumnPrecision;
        }
    EditColumn->col_format[i]=col_format[i];
    EditColumn->col_precision[i]=col_precision[i];
    }
        if (get_set_strings(gno,sno)==NULL)
        chkShowStrings->setChecked(false);
        else
        chkShowStrings->setChecked(true);
        chkShowStringOperations->setChecked(false);
    model->setStringsEnabled(chkShowStrings->isChecked());
    setPossibleColumns();
    connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(changeDataSet(int)));
    connect(chkShowStrings,SIGNAL(toggled(bool)),this,SLOT(showStringsToggled(bool)));
    connect(chkShowStringOperations,SIGNAL(toggled(bool)),this,SLOT(showStringsOperationsToggled(bool)));
    model->init(gno,sno);
    update_entries();
    showStringsToggled(get_set_strings(gno,sno)==NULL?false:true);
}

void frmSpreadSheet::CreateActions(void)
{
    actClose= new QAction(tr("&Close"), this);
    actClose->setShortcut(tr("Esc"));
    connect(actClose, SIGNAL(triggered()), this, SLOT(doClose()));
    actAddRow= new QAction(tr("&Add row"), this);
    connect(actAddRow, SIGNAL(triggered()), this, SLOT(doAddRow()));
    actDelSelRow= new QAction(tr("&Delete selected rows"), this);
    connect(actDelSelRow, SIGNAL(triggered()), this, SLOT(doDelSelRow()));
    actColumnFormat= new QAction(tr("&Column format..."), this);
    connect(actColumnFormat, SIGNAL(triggered()), this, SLOT(doColumnFormat()));
    actHelpOnContext= new QAction(tr("On conte&xt"), this);
    actHelpOnContext->setShortcut(tr("Shift+F1"));
    connect(actHelpOnContext, SIGNAL(triggered()), this, SLOT(doHelpOnContext()));
    actHelpOnDataSetEditor= new QAction(tr("On datas&et editor"), this);
    connect(actHelpOnDataSetEditor, SIGNAL(triggered()), this, SLOT(doHelpOnDataSetEditor()));
    actSelectEven= new QAction(tr("Select even rows"), this);
    connect(actSelectEven, SIGNAL(triggered()), this, SLOT(doSelectEven()));
    actSelectOdd= new QAction(tr("Select odd rows"), this);
    connect(actSelectOdd, SIGNAL(triggered()), this, SLOT(doSelectOdd()));
    actCopySelected= new QAction(tr("Copy selection to clipboard"), this);
    connect(actCopySelected, SIGNAL(triggered()), this, SLOT(doCopySelected()));
}

void frmSpreadSheet::changeDataSet(int type)//to change the set-type
{
    if (!is_valid_setno(gno,sno)) return;//do nothing if set is invalid
//qDebug() << "Change Set type";
    bool is_string_col_vis=chkShowStrings->isChecked();
    int nsets=1;
    int * gnos=new int[2],*snos=new int[2];
    SaveSetStatesPrevious(nsets,gnos,snos,UNDO_COMPLETE);
    set_dataset_type(this->gno, this->sno, type);
    gnos[0]=this->gno;
    snos[0]=this->sno;
    SetsModified(nsets,gnos,snos,UNDO_COMPLETE);
    sprintf(dummy," (G%d.S%d)",gnos[0],snos[0]);
    addAditionalDescriptionToLastNode(-1,QObject::tr("Data set type changed") + QString(dummy),QString());
    setPossibleColumns();
    mainWin->mainArea->completeRedraw();
    chkShowStrings->setChecked(is_string_col_vis);
    delete[] gnos;
    delete[] snos;
}

void frmSpreadSheet::itemChanged(int row,int col,bool really_new_value)
{
//qDebug() << "itemChanged: row=" << row << "col=" << col << "reallyNew=" << really_new_value;
    (void)row;
    (void)col;
    /*static char setPrec[8];
    static char out_format[16];
    static char dummy[128];
    static int graphnr,setnr;*/
if (!really_new_value || !is_valid_setno(gno,sno)) return;
    /*char dummy2[128];
    QModelIndex modind=model->index(row,col);*/
    gno=model->graphnr;
    sno=model->setnr;
    /*strcpy(dummy2,model->data(modind).toString().toLocal8Bit());
    sprintf(setPrec,"%%.%d",col_precision[col]);
    switch (col_format[col])
    {
    case 0://decimal
    sprintf(out_format,"%sf",setPrec);
    break;
    case 1://general
    sprintf(out_format,"%sg",setPrec);
    break;
    case 2://exponential
    sprintf(out_format,"%se",setPrec);
    break;
    case 3://Date/time
    sprintf(out_format,"%%t");///NOT CORRECT
    break;
    }
    sprintf(dummy,out_format,g[graphnr].p[setnr].data.ex[col][row]);*/
//qDebug() << "G1";
    ledComment->SetMemoryToText(g[gno].p[sno].comments,g[gno].p[sno].orig_comments);
//qDebug() << "G2";
    set_dirtystate();
    mainWin->mainArea->completeRedraw();
//qDebug() << "G3";
    if (parentList!=NULL)
    {
//qDebug() << "Parent!";
    parentList->set_new_selection(1,&sno);
    emit(parentList->new_selection());
    }
//qDebug() << "G4";
}

void frmSpreadSheet::minimalItemChanged(void)
{
//qDebug() << "MINIMAL CHANGED";
char dum[128];
int rows,cols;
    rows=getsetlength(gno,sno);
    cols=settype_cols(dataset_type(gno,sno));
sprintf(dum," G%d.S%d ( %d x %d )",gno,sno,rows,cols);
fraDataset->setTitle(tr("Dataset") + QString(dum));
}

void frmSpreadSheet::setColumnFormat(int col,int format,int precision)
{
    col_format[col]=format;
    col_precision[col]=precision;
    bool dirty=false;
    if (is_valid_setno(gno,sno))
    {
        if (g[gno].p[sno].pref_col_format[col]!=col_format[col]) dirty=true;
    g[gno].p[sno].pref_col_format[col]=col_format[col];
        if (g[gno].p[sno].pref_col_prec[col]!=col_precision[col]) dirty=true;
    g[gno].p[sno].pref_col_prec[col]=col_precision[col];
    }
    if (dirty==true) set_dirtystate();
    update_entries();
}

void frmSpreadSheet::doApply(void)
{
    ApplyError=true;
    if (!is_valid_setno(gno,sno)) return;//do nothing if set is invalid
    ApplyError=false;
    ledComment->SetMemoryToText(g[model->graphnr].p[model->setnr].comments,g[model->graphnr].p[model->setnr].orig_comments);
    mainWin->mainArea->completeRedraw();
}

void frmSpreadSheet::doAccept(void)
{
    ApplyError=false;
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmSpreadSheet::doClose(void)
{
    hide();
}

void frmSpreadSheet::doAddRow(void)
{
    int * sels;
    int nsels,gno,sno;
    int * gnos=new int[3];
    int * snos=new int[3];
    getSelection(&nsels,&sels);
    if (nsels<=0)
    {
        errmsg(tr("No rows selected!").toLocal8Bit().constData());
        delete[] gnos;
        delete[] snos;
        return;
    }
    gnos[0]=gno=model->graphnr;
    snos[0]=sno=model->setnr;
    SaveSetStatesPrevious(1,gnos,snos,UNDO_DATA);
    //for (int ii=0;ii<nsels;ii++)
    for (int ii=nsels-1;ii>=0;ii--)
    {
        int i=sels[ii], k;
        int nrows=getsetlength(gno,sno), ncols=dataset_cols(gno,sno);
        char **s;
        char **orig_s;
        Datapoint dpoint;
        if (i > nrows || i < 0)
        {
            errmsg(tr("Selected row out of range!").toLocal8Bit().constData());
            delete[] gnos;
            delete[] snos;
            return;
        }
        zero_datapoint(&dpoint);
        if (i < nrows)
        {
            for (k = 0; k < ncols; k++)
            {
                dpoint.ex[k] = g[gno].p[sno].data.ex[k][i];//*(getcol(gno, sno, k) + i);
            }
            if ((s = get_set_strings(gno, sno)) != NULL)
            {
                orig_s=get_set_original_strings(gno, sno);
                dpoint.s = s[i];
                dpoint.orig_s = orig_s[i];
            }
            add_point_at(gno, sno, i+1, &dpoint);
            //model->insertRow(i+1);
        }
        else
        {
            add_point_at(gno, sno, i, &dpoint);
            //model->insertRow(i);
        }
        update_set_lists(gno);
        /// init(gno, setno);
        update_entries();
        mainWin->mainArea->completeRedraw();
    }
    SetsModified(1,gnos,snos,UNDO_DATA);
    delete[] sels;
    delete[] gnos;
    delete[] snos;
}

void frmSpreadSheet::doDelSelRow(void)
{
    int i;
    int * srows;
    int nsrows;
    int * gnos=new int[3];
    int * snos=new int[3];
    char buf[64];
    getSelection(&nsrows,&srows);
    gnos[0]=model->graphnr;
    snos[0]=model->setnr;
    if (srows[0] < 0 || srows[0] >= getsetlength(gnos[0],snos[0]) || nsrows<=0)
    {
        errmsg(tr("Nothing to delete").toLocal8Bit().constData());
        delete[] gnos;
        delete[] snos;
        return;
    }
    sprintf(buf, "Delete %d selected row(s)?", nsrows);
    if (yesno(buf, NULL, NULL, NULL))
    {
        SaveSetStatesPrevious(1,gnos,snos,UNDO_DATA);
        for (i = nsrows - 1; i >= 0; i--)
        {
            if (srows[i]>=0 && srows[i]<getsetlength(gnos[0],snos[0]))
            {
                del_point(gnos[0],snos[0],srows[i]);
                //model->removeRow(srows[i]);
            }
        }
        update_set_lists(gnos[0]);
        /// init(gno, setno);
        update_entries();
        mainWin->mainArea->completeRedraw();
        SetsModified(1,gnos,snos,UNDO_DATA);
    }
    delete[] srows;
    delete[] gnos;
    delete[] snos;
}

void frmSpreadSheet::doColumnFormat(void)
{
    EditColumn->initToColumn(0);
    EditColumn->show();
    EditColumn->raise();
}

void frmSpreadSheet::doHelpOnContext(void)
{
    setCursor(QCursor(Qt::WhatsThisCursor));
}

void frmSpreadSheet::doHelpOnDataSetEditor(void)
{
    HelpCB("doc/UsersGuide.html#SSEditor");
}

void frmSpreadSheet::getSelection(int * n_of_sel,int ** sel)
{
    QModelIndexList list=table->selectionModel()->selectedIndexes();
    *sel=new int[list.length()];
    int counter=0;
    int current;
    bool found;
    for (int i=0;i<list.length();i++)
    {
        current=list.at(i).row();
        found=false;
        for (int j=0;j<counter;j++)
        {
            if ((*sel)[j]==current)
            {
                found=true;
                break;
            }
        }
        if (found==false)
            (*sel)[counter++]=current;
    }
    *n_of_sel=counter;
    sort(*n_of_sel,*sel);
}

void frmSpreadSheet::setSelection(int n_of_sel,int * sel)
{
    QModelIndex index;
    table->clearSelection();
    for (int i=0;i<n_of_sel;i++)
    {
        index=table->model()->index(sel[i],0);
        table->selectionModel()->select(index,QItemSelectionModel::Select|QItemSelectionModel::Rows);
    }
}

void frmSpreadSheet::update_entries(void)
{
static int rows,cols;
static char dum[64];
//qDebug() << "update_entries";
    if (is_valid_setno(gno,sno))
    {
        gno=model->graphnr;
        sno=model->setnr;
        rows=getsetlength(gno,sno);
        cols=dataset_cols(gno,sno);
        sprintf(dum," G%d.S%d ( %d x %d )",gno,sno,rows,cols);
        fraDataset->setTitle(tr("Dataset") + QString(dum));
        ledComment->SetTextToMemory(g[gno].p[sno].comments,g[gno].p[sno].orig_comments);
        model->major_changes();
    }
    else//no valid data present
    {
        sprintf(dum," Invalid set!");
        fraDataset->setTitle(tr("Dataset") + QString(dum));
    }
}

void frmSpreadSheet::doSelectEven(void)
{
    int nr,*sel=new int[2];
    getSelection(&nr,&sel);
    int rows=getsetlength(gno,sno);
    int * n_sel=new int[nr+rows/2+2];
    memcpy(n_sel,sel,nr*sizeof(int));
    for (int i=0;i<rows;i+=2)
    {
        n_sel[nr++]=i;
    }
    setSelection(nr,n_sel);
    delete[] sel;
    delete[] n_sel;
}

void frmSpreadSheet::doSelectOdd(void)
{
    int nr,*sel=new int[2];
    getSelection(&nr,&sel);
    int rows=getsetlength(gno,sno);
    int * n_sel=new int[nr+rows/2+2];
    memcpy(n_sel,sel,nr*sizeof(int));
    for (int i=1;i<rows;i+=2)
    {
        n_sel[nr++]=i;
    }
    setSelection(nr,n_sel);
    delete[] sel;
    delete[] n_sel;
}

void frmSpreadSheet::doCopySelected(void)
{
    int nr,*sel=new int[2];
    getSelection(&nr,&sel);

    QString text;
    text.clear();
    //int rows=getsetlength(gno,sno);
    int col=dataset_cols(gno,sno);

    for (int k=0;k<nr;k++)
    {
        for (int j=0;j<col;j++)
        {
            //sprintf(dummy,"%.8g\t",g[gno].p[sno].data.ex[j][sel[k]]);
            //text+=QString(dummy);
            sprintf(dummy,sformat,g[gno].p[sno].data.ex[j][sel[k]]);
            text+=QString(dummy)+QString("\t");
        }
        text+=QString("\n");
    }

    if (SystemsDecimalPoint!='.') text.replace(QString("."),QString(SystemsDecimalPoint));
    QApplication::clipboard()->setText(text);

    delete[] sel;
}

void frmSpreadSheet::showStringsToggled(bool a)
{
    (void) a;
    if (chkShowStrings->isChecked()==true)
    {
    //selConvertTo->setVisible(true);
    //cmdConvertStrings->setVisible(true);
    //selFormat->setVisible(true);
    //cmdRemoveStrings->setVisible(true);
        //if (g[gno].p[sno].data.s==NULL)
        //cmdRemoveStrings->setEnabled(false);
        //else
        //cmdRemoveStrings->setEnabled(true);
    setPossibleColumns();
    chkShowStringOperations->setVisible(true);
    showStringsOperationsToggled(chkShowStringOperations->isChecked());
    }
    else
    {
    selConvertTo->setVisible(false);
    cmdConvertStrings->setVisible(false);
    selFormat->setVisible(false);
    cmdRemoveStrings->setVisible(false);
    chkShowStringOperations->setVisible(false);
    selDecSep->setVisible(false);
    selInvalidVal->setVisible(false);
    }
    model->setStringsEnabled(chkShowStrings->isChecked());
    update_entries();
}

void frmSpreadSheet::showStringsOperationsToggled(bool a)
{
    (void) a;
    if (chkShowStringOperations->isChecked()==true)
    {
    selConvertTo->setVisible(true);
    cmdConvertStrings->setVisible(true);
    selFormat->setVisible(true);
    selDecSep->setVisible(true);
    selInvalidVal->setVisible(true);
    cmdRemoveStrings->setVisible(true);
        if (g[gno].p[sno].data.s==NULL)
        cmdRemoveStrings->setEnabled(false);
        else
        cmdRemoveStrings->setEnabled(true);
    }
    else
    {
    selConvertTo->setVisible(false);
    cmdConvertStrings->setVisible(false);
    selFormat->setVisible(false);
    selDecSep->setVisible(false);
    selInvalidVal->setVisible(false);
    cmdRemoveStrings->setVisible(false);
    }
}

void frmSpreadSheet::doConvertStrings(void)
{
int ret=QMessageBox::question(this,tr("Overwrite?"),tr("Convert strings and overwrite Target column (")+QString(dataset_colname(selConvertTo->currentIndex()))+QString(")?"), QMessageBox::Yes | QMessageBox::No,QMessageBox::No);
    if (ret==QMessageBox::Yes)
    {
    int dec_sep_index=selDecSep->currentIndex();
    int target_col=selConvertTo->currentIndex();
    int source_format=selFormat->currentValue();
    int endpos,emptyresidual,ok;
    char tmp_c_str[1024];
    QString tmp_str;
    double value,inv_val=selInvalidVal->value();
    int inval_counter=0;
        if (target_col>=get_number_of_columns(gno,sno))
        {
        errmsg(tr("Target column does not exist!").toLocal8Bit().constData());
        return;
        }

        SaveSingleSetStatePrevious(gno,sno,UNDO_TYPE_SET_MODIFIED);
    for (int i=0;i<g[gno].p[sno].data.len;i++)
    {
        if (dec_sep_index!=0)
        {
        tmp_str=QString(g[gno].p[sno].data.s[i]);
        tmp_str.replace('.','|');
        tmp_str.replace(',','.');
        strcpy(tmp_c_str,tmp_str.toLocal8Bit().constData());
        }
        else
        {
        strcpy(tmp_c_str,g[gno].p[sno].data.s[i]);
        }
    ok=read_date_or_number_in_format(tmp_c_str,source_format,FALSE,&value,&endpos,&emptyresidual);
        if (ok==RETURN_FAILURE)
        {
        g[gno].p[sno].data.ex[target_col][i]=inv_val;
        inval_counter++;
        }
        else
        g[gno].p[sno].data.ex[target_col][i]=value;
    }
    if (inval_counter>0)
    {
        if (inval_counter==1)
        tmp_str=QString::number(inval_counter)+tr(" value could not be read correctly. Wrong data format?");
        else
        tmp_str=QString::number(inval_counter)+tr(" values could not be read correctly. Wrong data format?");
    errmsg(tmp_str.toLocal8Bit().constData());
    }
        SingleSetModified(gno,sno,UNDO_TYPE_SET_MODIFIED);
    set_dirtystate();
    mainWin->mainArea->completeRedraw();
    }
    /*else
    {
    qDebug() << "No";
    }*/
}

void frmSpreadSheet::doRemoveStrings(void)
{
    if (g[gno].p[sno].data.s==NULL) return;
int ret=QMessageBox::question(this,tr("Remove string column?"),tr("Do you really want to remove all strings from this set?"), QMessageBox::Yes | QMessageBox::No,QMessageBox::No);
    if (ret==QMessageBox::Yes)
    {
    int len=getsetlength(gno,sno);
        for (int k = 0; k < len; k++)
        {
        XCFREE(g[gno].p[sno].data.s[k]);
        XCFREE(g[gno].p[sno].data.orig_s[k]);
        }
        XCFREE(g[gno].p[sno].data.s);
        XCFREE(g[gno].p[sno].data.orig_s);
    set_dirtystate();
    mainWin->mainArea->completeRedraw();
    chkShowStrings->setChecked(true);
    }
    /*else
    {
    qDebug() << "No";
    }*/
}

void frmSpreadSheet::setPossibleColumns(void)
{
int old_sel=selConvertTo->currentIndex();
int nr_of_cols = settype_cols(dataset_type(gno, sno));
if (nr_of_cols<=0) nr_of_cols=0;
int * values=new int[2+nr_of_cols];
QString * entries=new QString[2+nr_of_cols];
for (int i=0;i<nr_of_cols;i++)
{
values[i]=i;
entries[i]=QString(dataset_colname(i));
}
selConvertTo->setNewEntries(nr_of_cols,entries,values);
selConvertTo->setCurrentIndex(old_sel);
delete[] entries;
delete[] values;
}

void frmSpreadSheet::stringDataChanged(void)
{
showStringsToggled(chkShowStrings->isChecked());
}

void frmSpreadSheet::keyPressEvent(QKeyEvent * e)
{
    if (e->key()==Qt::Key_Delete)
    doDelSelRow();
}

frmSpreadSheet2::frmSpreadSheet2(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Spreadsheet dataset editor"));
    setWindowIcon(QIcon(*GraceIcon));
    number_of_rows=50;//visible rows --> this should be enough...
    start_row=0;
    number_of_columns=3;
    allocated_rows=number_of_rows;
    visible_row_count=5;
    length=0;
    initiated=false;
    g_no=s_no=-1;
    table=new QTableWidget(number_of_rows,number_of_columns,this);
    table->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    table->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
    Items=new QTableWidgetItem**[number_of_rows];
    for (int i=0;i<number_of_rows;i++)
    {
        Items[i]=new QTableWidgetItem*[number_of_columns];
        for (int j=0;j<number_of_columns;j++)
        {
            Items[i][j]=new QTableWidgetItem(QString(dummy),QTableWidgetItem::Type);
            table->setItem(i, j, Items[i][j]);
        }
    }
    QStringList vertHeads;
    QStringList horHeads;
    horHeads << "X" << "Y";
    for (int i=0;i<number_of_rows;i++)
    {
        sprintf(dummy,"%7d",i);
        vertHeads << QString(dummy);
    }
    table->setHorizontalHeaderLabels(horHeads);
    table->setVerticalHeaderLabels(vertHeads);
    scroll=new QScrollBar(Qt::Vertical,this);
    scroll->setSingleStep(1);
    fraDataset=new QGroupBox(tr("Dataset"),this);
    selType=new stdSetTypeSelector(this);
    ledComment=new stdLineEdit(fraDataset,tr("Comment:"),true);
    ledComment->lenText->setText(tr("Editor"));
    layout0=new QVBoxLayout;
    //layout0->setMargin(STD_MARGIN);
    layout0->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout0->addWidget(selType);
    layout0->addWidget(ledComment);
    fraDataset->setLayout(layout0);

    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));

    layout=new QGridLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    //layout->addWidget(menuBar);
    layout->addWidget(fraDataset,0,0,1,2);
    layout->addWidget(table,1,0,1,1);
    layout->addWidget(scroll,1,1,1,1);
    layout->addWidget(buttonGroup,2,0,1,1);
    setLayout(layout);
    connect(scroll,SIGNAL(valueChanged(int)),SLOT(position_changed(int)));
    /*QTableWidget * table;
QTableWidgetItem *** Items;//the Entries!
stdSetTypeSelector *selType
QGroupBox * fraDataset;
stdLineEdit * ledComment;
QVBoxLayout * layout0;
stdButtonGroup * buttonGroup;
QVBoxLayout * layout;*/
}

void frmSpreadSheet2::resizeEvent(QResizeEvent * event)
{
    static double guessed_number_of_rows;
//static int real_height;
    event->accept();
    //QSize si=event->size();
//real_height=Items[0][0]->tableWidget()->height();
    //cout << si.width() << " x " << si.height() << "/" << real_height << " one line=" << table->horizontalHeader()->height() << "/";
    //cout << "rowHeight()=" << table->rowHeight(1) << " WidgetHeight=" << table->height() << " scrollHeight=" << table->horizontalScrollBar()->height();
    guessed_number_of_rows=(table->height()-table->horizontalHeader()->height()-table->horizontalScrollBar()->height()-STD_SPACING)*1.0/(table->rowHeight(1));
    //cout << " --> " << guessed_number_of_rows << endl;
    visible_row_count=int(guessed_number_of_rows+1);
    scroll->setRange(0,length-visible_row_count+6);
    scroll->setPageStep(visible_row_count);
    //cout << length << " / " << int(guessed_number_of_rows) << endl;
}

void frmSpreadSheet2::position_changed(int pos)
{
    start_row=pos;
    update_entries();
}

void frmSpreadSheet2::init(int gno,int sno)
{
    g_no=gno;
    s_no=sno;
    start_row=0;
    length=getsetlength(gno,sno);
    initiated=true;
    update_entries();
}

void frmSpreadSheet2::update_entries(void)
{
    static char dummy[128];
    static QStringList vertHeads;
    static QString emptyEntry("");
    if (initiated==false) return;
    vertHeads.clear();
    for (int i=start_row;i<start_row+visible_row_count;i++)
    {
        sprintf(dummy,"%7d",i);
        vertHeads << QString(dummy);
        for (int j=0;j<2;j++)
        {
            //sprintf(dummy,out_format,p.data.ex[col][ro]);
            if (i<length)
            {
                sprintf(dummy,"%g",g[g_no].p[s_no].data.ex[j][i]);
                Items[i-start_row][j]->setText(QString(dummy));
            }
            else
            {
                Items[i-start_row][j]->setText(emptyEntry);
            }
        }
    }
    table->setVerticalHeaderLabels(vertHeads);
}

void frmSpreadSheet2::doApply(void)
{

}

void frmSpreadSheet2::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmSpreadSheet2::doClose(void)
{
    hide();
}

myTableWidget::myTableWidget(int r, int c,QWidget * parent):QTableWidget(r,c,parent)
{
}

void myTableWidget::wheelEvent(QWheelEvent * e)
{
    e->accept();
    /*emit(wheeled(e->delta()));*/
    emit(wheeled(e->angleDelta().manhattanLength()));
}

void myTableWidget::keyPressEvent(QKeyEvent * event)
{
    static int keynr;
    event->accept();
    keynr=event->key();
    //cout << "press " << char(event->key()) << "|" << event->key() << endl;
    //if (!(keynr==Qt::Key_Tab || keynr==Qt::Key_Backtab || keynr==Qt::Key_Return || keynr==Qt::Key_Enter || keynr==Qt::Key_PageUp || keynr==Qt::Key_PageDown || keynr==Qt::Key_Down || keynr==Qt::Key_Up || keynr==Qt::Key_Home || keynr==Qt::Key_End))
    if (!(keynr==Qt::Key_Tab || keynr==Qt::Key_Backtab || keynr==Qt::Key_PageUp || keynr==Qt::Key_PageDown || keynr==Qt::Key_Down || keynr==Qt::Key_Up || keynr==Qt::Key_Home || keynr==Qt::Key_End))
        QTableWidget::keyPressEvent(event);
    else
        emit newDirection(keynr);
}

void myTableWidget::keyReleaseEvent(QKeyEvent * event)
{
    static int keynr;
    event->accept();
    keynr=event->key();
    //cout << "release " << char(event->key()) << " | " << event->key() << " | row= " << currentRow() << endl;
    //if (!(keynr==Qt::Key_Tab || keynr==Qt::Key_Backtab || keynr==Qt::Key_Return || keynr==Qt::Key_Enter || keynr==Qt::Key_PageUp || keynr==Qt::Key_PageDown || keynr==Qt::Key_Down || keynr==Qt::Key_Up || keynr==Qt::Key_Home || keynr==Qt::Key_End))
    if (!(keynr==Qt::Key_Tab || keynr==Qt::Key_Backtab || keynr==Qt::Key_PageUp || keynr==Qt::Key_PageDown || keynr==Qt::Key_Down || keynr==Qt::Key_Up || keynr==Qt::Key_Home || keynr==Qt::Key_End))
        QTableWidget::keyReleaseEvent(event);
    //else
    //emit newDirection(keynr);
}

frmSpreadSheet3::frmSpreadSheet3(QWidget * parent):QDialog(parent)
{
    working=false;
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Spreadsheet dataset editor"));
    setWindowIcon(QIcon(*GraceIcon));

    CreateActions();

    EditColumn=new frmEditColumnProp(this);
    EditColumn->hide();
    connect(EditColumn,SIGNAL(newColumnFormat(int,int,int)),SLOT(setColumnFormat(int,int,int)));

    int number;
    char dummy[50];
    QString entr[NUMBER_OF_SETTYPES+2];
    menuBar=new QMenuBar(this);
    mnuFile=new QMenu(tr("&File"));
    mnuFile->setTearOffEnabled(TRUE);
    mnuFile->addAction(actClose);
    mnuEdit=new QMenu(tr("&Edit"));
    mnuEdit->setTearOffEnabled(TRUE);
    mnuEdit->addAction(actAddRow);
    mnuEdit->addAction(actDelSelRow);
    mnuEdit->addSeparator();
    mnuEdit->addAction(actColumnFormat);
    mnuHelp=new QMenu(tr("&Help"));
    mnuHelp->setTearOffEnabled(TRUE);
    mnuHelp->addAction(actHelpOnContext);
    mnuHelp->addSeparator();
    mnuHelp->addAction(actHelpOnDataSetEditor);

    menuBar->addMenu(mnuFile);
    menuBar->addMenu(mnuEdit);
    menuBar->addSeparator();
    menuBar->addMenu(mnuHelp);

    /*scroll=new QScrollArea(this);
spread=new spreadSheet(scroll,0,5,3);
scroll->setWidget(spread);*/

    //4number_of_rows=100;//std-Row-count
    //filled_rows=0;
    number_of_visible_entries=5;//just a guess
    number_of_columns=6;//maximum number of columns
    //setColumnHidden( int column, bool hide );

    for (int i=0;i<6;i++)
    {
        col_format[i]=1;
        col_precision[i]=5;
        EditColumn->col_format[i]=col_format[i];
        EditColumn->col_precision[i]=col_precision[i];
    }

    strcpy(dummy,"");

    //table=new QTableWidget(number_of_rows,number_of_columns,this);
    //the number of lines will not change later!!!
    table=new myTableWidget(MAX_NUMBER_OF_LINES_IN_SPREADSHEET,number_of_columns,this);
    connect(table,SIGNAL(newDirection(int)),this,SLOT(changeDirection(int)));
    table->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    //table->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
    table->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
    Items=new QTableWidgetItem**[MAX_NUMBER_OF_LINES_IN_SPREADSHEET+1];
    for (int i=0;i<=MAX_NUMBER_OF_LINES_IN_SPREADSHEET;i++)
    {
        Items[i]=new QTableWidgetItem*[number_of_columns+1];
        for (int j=0;j<=number_of_columns;j++)
        {
            Items[i][j]=new QTableWidgetItem(QString(dummy),QTableWidgetItem::Type);
            table->setItem(i, j, Items[i][j]);
        }
    }
    connect(table,SIGNAL(currentCellChanged(int,int,int,int)),SLOT(currentCellChangedWrapper(int,int,int,int)));
    connect(table,SIGNAL(cellChanged(int,int)),SLOT(itemChanged(int,int)));
    connect(table,SIGNAL(wheeled(int)),SLOT(wheel_used(int)));
    QStringList vertHeads;
    QStringList horHeads;
    horHeads << "X" << "Y";
    for (int i=0;i<MAX_NUMBER_OF_LINES_IN_SPREADSHEET;i++)//initialize everything here
    {
        sprintf(dummy,"%7d",i);
        vertHeads << QString(dummy);
    }
    table->setHorizontalHeaderLabels(horHeads);
    table->setVerticalHeaderLabels(vertHeads);
    connect(table->horizontalHeader(),SIGNAL(sectionClicked(int)),SLOT(HHeaderClicked(int)));

    scroll=new QScrollBar(Qt::Vertical,this);
    //scroll=table->verticalScrollBar();
    scroll->setSingleStep(1);
    connect(scroll,SIGNAL(valueChanged(int)),SLOT(position_changed(int)));

    fraDataset=new QGroupBox(tr("Dataset"),this);

    number=NUMBER_OF_SETTYPES;
    for (int i=0;i<NUMBER_OF_SETTYPES;i++)
    {
        strToUpper(dummy,set_types(i));
        entr[i]=QString(dummy);
    }
    selType=new StdSelector(fraDataset,tr("Type:"),number,entr);
    connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(changeDataSet(int)));
    //selType=new stdSetTypeSelector(this);

    ledComment=new stdLineEdit(fraDataset,tr("Comment:"),true);
    ledComment->lenText->setText(tr("Editor"));
    layout0=new QVBoxLayout;
    //layout0->setMargin(STD_MARGIN);
    layout0->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout0->addWidget(selType);
    layout0->addWidget(ledComment);
    fraDataset->setLayout(layout0);

    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));

    layout=new QGridLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(0);
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar,0,0,1,2);
#endif
    layout->addWidget(fraDataset,1,0,1,2);
    layout->addWidget(table,2,0,1,1);
    layout->addWidget(scroll,2,1,1,1);
    layout->addWidget(buttonGroup,3,0,1,2);
    setLayout(layout);
    start_row=0;
    inited=false;
}

void frmSpreadSheet3::HHeaderClicked(int i)
{
    EditColumn->initToColumn(i);
    EditColumn->show();
    EditColumn->raise();
}

void frmSpreadSheet3::init(int g_no,int set_no)
{
    if (inited==true && isVisible()==false) return;//do nothing, as long as nothing is visible!
    inited=true;//just for the first init...
    start_row=0;
    disconnect(table,SIGNAL(cellChanged(int,int)), this, SLOT(itemChanged(int,int)));
    char dummy[64];
    QString ds1=tr("Dataset");
    sprintf(dummy," G%d.S%d",g_no,set_no);
    QString ds2=ds1+QString(dummy);
    fraDataset->setTitle(ds2);
    //set new graph- and set-number
    gno=g_no;
    setno=set_no;
    plotarr p;
    //get set data
    get_graph_plotarr(g_no, set_no, &p);
    //Set the comment
    ledComment->SetTextToMemory(g[g_no].p[set_no].comments,g[g_no].p[set_no].orig_comments);
    //ledComment->lenText->setText(getcomment(g_no, set_no));

    //delete everything
    //for (int i=number_of_columns-1;i>=0;i--)
    //table->removeColumn(i);
    //for (int i=0;i<number_of_rows;i++)
    //delete[] Items[i];
    //delete[] Items;

    //renew all entries
    setLength=getsetlength(g_no, set_no);

    /*
if (filled_rows<30)//Minimum is 30 lines (see below)
number_of_rows=30;
else
number_of_rows=5+filled_rows;//at least 5 more than needed
*/

    number_of_columns=settype_cols(p.type);
    if (number_of_columns<2)
    {
        cout << "WARNING: number_of_columns=" << number_of_columns << endl;
        number_of_columns=2;
    }
    table->setColumnCount(number_of_columns);

    //recreate whole spreadsheet
    /*
table->setRowCount(number_of_rows);
table->setColumnCount(number_of_columns);
    Items=new QTableWidgetItem**[number_of_rows];
    for (int i=0;i<number_of_rows;i++)
    {
    Items[i]=new QTableWidgetItem*[number_of_columns];
        for (int j=0;j<number_of_columns;j++)
        {
        Items[i][j]=new QTableWidgetItem(QString(""),QTableWidgetItem::Type);
        table->setItem(i, j, Items[i][j]);
        }
        }
*/
    disconnect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(changeDataSet(int)));
    selType->setCurrentIndex(p.type);
    connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(changeDataSet(int)));
    connect(table,SIGNAL(cellChanged(int,int)),this,SLOT(itemChanged(int,int)));
    //resize(this->size());
    //update_entries(); --> will be done in 'position_changed(0);' below
    scroll->setValue(0);
    position_changed(0);
}

void frmSpreadSheet3::changeDataSet(int type)
{
    set_dataset_type(this->gno, this->setno, type);
    mainWin->mainArea->completeRedraw();
}

void frmSpreadSheet3::setColumnFormat(int col,int format,int precision)
{
    col_format[col]=format;
    col_precision[col]=precision;
    update_entries();
}

void frmSpreadSheet3::resizeEvent(QResizeEvent * event)
{
    event->accept();
    static double guessed_number_of_visible_entries;
    guessed_number_of_visible_entries=(table->size().height()-table->horizontalHeader()->height()-table->horizontalScrollBar()->height())*1.0/table->rowHeight(1);
    number_of_visible_entries=int(guessed_number_of_visible_entries);//before: '+1'
    scroll->setPageStep(number_of_visible_entries);
    scroll->setRange(0,setLength-number_of_visible_entries+12);//'+10' because 10 empty rows at the end
    //cout << "number_of_visible_entries = " << number_of_visible_entries << endl;
    update_entries();
}

void frmSpreadSheet3::wheel_used(int d)//translate mouse-wheel to scroll events
{
    if (d<0)
        scroll->setValue(scroll->value()+1);
    else
        scroll->setValue(scroll->value()-1);
}

void frmSpreadSheet3::position_changed(int pos)
{
    start_row=pos;//only start_row actually changed here!
    update_entries();
}

void frmSpreadSheet3::update_entries(void)//show data in table
{
    if (working==true) return;
    working=true;
    static double guessed_number_of_visible_entries;
    guessed_number_of_visible_entries=(table->size().height()-table->horizontalHeader()->height()-table->horizontalScrollBar()->height())*1.0/table->rowHeight(1);
    number_of_visible_entries=int(guessed_number_of_visible_entries);//'+1'

    disconnect (table,SIGNAL(cellChanged(int,int)), this, SLOT(itemChanged(int,int)));
    char setPrec[5];
    char out_format[16];
    char dummy[128];
    plotarr * p=NULL;
    QString emptyEntry("");
    //get_graph_plotarr(gno, setno, &p);//we do not need a copy here, we only read data
    if (is_valid_gno(gno) == TRUE && is_valid_setno(gno,setno) == TRUE)
    {
        p=g[gno].p+setno;
    }

    /*
int setcolumns=settype_cols(p->type);
if (setcolumns!=number_of_columns)
{
    cout << "wrong column-count: " << setcolumns << "<->" << number_of_columns << endl;
    return;
}
*/

    QStringList vertHeads;
    QStringList horHeads;
    horHeads << QString("X") << QString("Y");
    for (int i=1;i<number_of_columns-1;i++)
    {
        sprintf(dummy,"Y%d",i);
        horHeads << QString(dummy);
    }
    for (int i=0;i<=number_of_visible_entries+5;i++)//we will only update what is visible!
    {
        sprintf(dummy,"%7d",i+start_row);
        vertHeads << QString(dummy);
        /*if (i<number_of_visible_entries)
    table->setRowHidden(i,false);
    else
    table->setRowHidden(i,true);*/
    }
    table->setHorizontalHeaderLabels(horHeads);
    table->setVerticalHeaderLabels(vertHeads);

    if (is_valid_setno(gno,setno) == FALSE || p->data.len<=0)//entries not valid any more since set not valid
    {
        //table->clearContents();
        for (int i=0;i<=number_of_visible_entries+1;i++)//deleting the visible entries
        {
            for (int j=0;j<number_of_columns;j++)
            {
                Items[i][j]->setText(emptyEntry);
            }
        }
    }
    else//valid set
    {
        setLength=getsetlength(gno,setno);
        //if (filled_rows<0) filled_rows=0;
        //else if (filled_rows>100) filled_rows=100;//filled rows is the maximum number of entries to be filled...probably
        for (int col=0;col<number_of_columns;col++)
        {
            table->setColumnHidden(col,false);
            sprintf(setPrec,"%%.%d",col_precision[col]);
            switch (col_format[col])
            {
            case 0://decimal
                sprintf(out_format,"%sf",setPrec);
                break;
            case 1://general
                sprintf(out_format,"%sg",setPrec);
                break;
            case 2://exponential
                sprintf(out_format,"%se",setPrec);
                break;
            case 3://Date/time
                sprintf(out_format,"%%t");///NOT CORRECT
                break;
            }
            for (int ro=0;ro<=number_of_visible_entries+5;ro++)//fill the visible rows
            {
                if (ro+start_row<setLength)//fill only entries that are realy present
                {
                    sprintf(dummy,out_format,p->data.ex[col][ro+start_row]);
                    Items[ro][col]->setText(QString(dummy));
                }
                else//otherwise fill in empty entries
                    Items[ro][col]->setText(emptyEntry);
            }
        }
        /*for (int col=number_of_columns;col<6;col++)//--> we have set row- and column-count separately --> this is unneccessary
    table->setColumnHidden(col,true);*/
        table->resizeColumnsToContents();
    }
    connect(table,SIGNAL(cellChanged(int,int)),SLOT(itemChanged(int,int)));
    updateScrollBar();//we have to update this, because the number of entries could have changed
    working=false;
}

void frmSpreadSheet3::itemChanged(int row,int c)
{
    setLength=getsetlength(gno,setno);
    if (working==true || row>setLength || row<0 || c>table->columnCount() || c<0)
    {//do not disturb while working or with useless indices
        return;
    }
    ///working=true;
    ApplyError=false;
    //cout << "item changed " << row << "|" << c << endl;
    QString dummy1=Items[row][c]->text();
    double dummy2=atof(dummy1.toLocal8Bit());
    Datapoint * ps=NULL;
    int * nrs=NULL;
    Datapoint dpoint;
    int r=atoi(table->verticalHeaderItem(row)->text().toLocal8Bit().constData());//we determine the real row-number here
    zero_datapoint(&dpoint);
    if ( r < setLength )
    {
        ///Undo-Stuff
        for (int i=0;i<settype_cols(g[gno].p[setno].type);i++)
        {
        dpoint.ex[i]=g[gno].p[setno].data.ex[i][r];
        }
            if (g[gno].p[setno].data.s!=NULL)
            {
            dpoint.s=copy_string(NULL,g[gno].p[setno].data.s[r]);
            dpoint.orig_s=copy_string(NULL,g[gno].p[setno].data.orig_s[r]);
            }
        dpoint.ex[c]=dummy2;
        ps=new Datapoint[2];
        memcpy(ps,&dpoint,sizeof(Datapoint));
        nrs=new int[2];
        nrs[0]=r;
        DataPointEdited(gno,setno,nrs,1,ps,2);
        delete[] ps;
        delete[] nrs;
        g[gno].p[setno].data.ex[c][r]=dummy2;
    }
    else
    {
        //char dummy[128];
        //char setPrec[5];
        //char out_format[16];
        //int n_rows=(number_of_rows-filled_rows+1)-number_of_rows+r;
        //int n_rows=r-setLength+1;
        //int ret;
        //cout << "n_rows=" << n_rows << endl;
        for (int i=setLength;i<r;i++)
        {
            //ret=add_point_at(gno, setno, i, &dpoint);
            (void)add_point_at(gno, setno, i, &dpoint);
        }
        dpoint.ex[c]=dummy2;
        //ret=add_point_at(gno, setno, r, &dpoint);
        (void)add_point_at(gno, setno, r, &dpoint);
        //filled_rows+=n_rows;
        setLength=getsetlength(gno,setno);
        /*if (number_of_rows>=filled_rows+5)
{
;//enough space
}
else
{//in the current state: number of items is not changes
QTableWidgetItem *** Items_d=new QTableWidgetItem**[number_of_rows];
for (int i=0;i<number_of_rows+n_rows;i++)
Items_d[i]=new QTableWidgetItem*[number_of_columns];
for (int i=0;i<number_of_rows;i++)
{
    for (int j=0;j<number_of_columns;j++)
    Items_d[i][j]=Items[i][j];
    delete[] Items[i];
}
delete[] Items;
Items=new QTableWidgetItem**[number_of_rows+n_rows];

for (int i=0;i<number_of_rows+n_rows;i++)
{
    Items[i]=new QTableWidgetItem*[number_of_columns];
    if (i<number_of_rows)
    {
        for (int j=0;j<number_of_columns;j++)
        Items[i][j]=Items_d[i][j];
    }
    else
    {
        table->insertRow(i);
        for (int j=0;j<number_of_columns;j++)
        {
        Items[i][j]=new QTableWidgetItem(QString(""),QTableWidgetItem::Type);
        table->setItem(i, j, Items[i][j]);
        }
    }
}
}*///end: not enough space

        /*plotarr * p=g[gno].p+setno;
//get_graph_plotarr(gno, setno, &p);
for (int col=0;col<number_of_columns;col++)
{
sprintf(setPrec,"%%.%d",col_precsision[col]);
switch (col_format[col])
{
case 0://decimal
sprintf(out_format,"%sf",setPrec);
break;
case 1://general
sprintf(out_format,"%sg",setPrec);
break;
case 2://exponential
sprintf(out_format,"%se",setPrec);
break;
case 3://Date/time
sprintf(out_format,"%%t");///NOT CORRECT
break;
}
        for (int ro=number_of_rows;ro<r;ro++)
        {
        sprintf(dummy,out_format,p->data.ex[col][ro]);
        Items[ro][col]->setText(QString(dummy));
        }
}
    if (number_of_rows<filled_rows+5)
    {
    QStringList vertHeads;
    number_of_rows+=n_rows;
        for (int i=0;i<number_of_rows;i++)
        {
        sprintf(dummy,"%7d",i);
        vertHeads << QString(dummy);
        }
    table->setVerticalHeaderLabels(vertHeads);
    }*/
    }


    /*if (start_row<=(r-number_of_visible_entries+1))
{
    cout << "start_row=" << start_row;
    start_row-=(start_row-(r-number_of_visible_entries+1))-1;
    cout << " jetzt muesste ich eigentlich --> " << start_row << endl;

    working=false;
}
cout << "a) start_row=" << start_row << endl;*/
    update_entries();
    //cout << "b) start_row=" << start_row << endl;
    updateScrollBar();
    //cout << "c) start_row=" << start_row << endl;
    int start_sav=start_row;
    spreadSheetEntryChanged();
    start_row=start_sav;
    //cout << "len=" << getsetlength(gno,setno) << " start=" << start_row << " vis=" << number_of_visible_entries << " cur_r=" << r << endl;
    working=false;
}

void frmSpreadSheet3::CreateActions(void)
{
    actClose= new QAction(tr("&Close"), this);
    actClose->setShortcut(tr("Esc"));
    connect(actClose, SIGNAL(triggered()), this, SLOT(doClose()));
    actAddRow= new QAction(tr("&Add row"), this);
    connect(actAddRow, SIGNAL(triggered()), this, SLOT(doAddRow()));
    actDelSelRow= new QAction(tr("&Delete selected rows"), this);
    connect(actDelSelRow, SIGNAL(triggered()), this, SLOT(doDelSelRow()));
    actColumnFormat= new QAction(tr("&Column format..."), this);
    connect(actColumnFormat, SIGNAL(triggered()), this, SLOT(doColumnFormat()));
    actHelpOnContext= new QAction(tr("On conte&xt"), this);
    actHelpOnContext->setShortcut(tr("Shift+F1"));
    connect(actHelpOnContext, SIGNAL(triggered()), this, SLOT(doHelpOnContext()));
    actHelpOnDataSetEditor= new QAction(tr("On datas&et editor"), this);
    connect(actHelpOnDataSetEditor, SIGNAL(triggered()), this, SLOT(doHelpOnDataSetEditor()));
}

void frmSpreadSheet3::doApply(void)
{
    ApplyError=false;
    int r=table->currentRow();
    int c=table->currentColumn();
    itemChanged(r,c);
}

void frmSpreadSheet3::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmSpreadSheet3::doClose(void)
{
    hide();
    emit(spreadSheetClosed(gno,setno));
}

void frmSpreadSheet3::doAddRow(void)
{
    int * sels;
    int nsels;
    int * gnos=new int[3];
    int * snos=new int[3];
    getSelection(&nsels,&sels);
    gnos[0]=gno;
    snos[0]=setno;
    SaveSetStatesPrevious(1,gnos,snos,UNDO_DATA);
    for (int ii=0;ii<nsels;ii++)
    {
        int i=sels[ii]+start_row, k;
        int nrows=setLength, ncols=number_of_columns;// scols;
        char **s;
        char **orig_s;
        Datapoint dpoint;

        if (i > nrows || i < 0){
            errmsg(tr("Selected row out of range").toLocal8Bit().constData());
            return;
        }

        zero_datapoint(&dpoint);

        if (i < nrows) {
            for (k = 0; k < ncols; k++) {
                dpoint.ex[k] = *(getcol(gno, setno, k) + i);
            }
            if ((s = get_set_strings(gno, setno)) != NULL) {
                orig_s = get_set_original_strings(gno, setno);
                dpoint.s = s[i];
                dpoint.orig_s = orig_s[i];
            }
            add_point_at(gno, setno, i + 1, &dpoint);
        } else {
            add_point_at(gno, setno, i, &dpoint);
        }

        update_set_lists(gno);
        init(gno, setno);
        mainWin->mainArea->completeRedraw();
    }
    SetsModified(1,gnos,snos,UNDO_DATA);
    delete[] sels;
    delete[] gnos;
    delete[] snos;
}

void frmSpreadSheet3::doDelSelRow(void)
{
    int i;
    int * srows;
    int nsrows;
    int ndatapoints=getsetlength(gno,setno);
    int * gnos=new int[3];
    int * snos=new int[3];
    gnos[0]=gno;
    snos[0]=setno;
    SaveSetStatesPrevious(1,gnos,snos,UNDO_DATA);
    getSelection(&nsrows,&srows);
    char buf[64];
    if (srows[0] < 0 || srows[0] >= setLength) {
        errmsg(tr("Nothing to delete").toLocal8Bit().constData());
        return;
    }
    sprintf(buf, "Delete %d selected row(s)?", nsrows);
    if (yesno(buf, NULL, NULL, NULL)) {
        for (i = nsrows - 1; i >= 0; i--) {
            if (srows[i]+start_row>=0 && srows[i]+start_row<ndatapoints)
                del_point(gno,setno,srows[i]+start_row);
        }
        update_set_lists(gno);
        init(gno, setno);
        mainWin->mainArea->completeRedraw();
    }
    delete[] srows;
    SetsModified(1,gnos,snos,UNDO_DATA);
    delete[] gnos;
    delete[] snos;
}

void frmSpreadSheet3::doColumnFormat(void)
{
    EditColumn->initToColumn(0);
    EditColumn->show();
    EditColumn->raise();
}

void frmSpreadSheet3::doHelpOnContext(void)
{
    setCursor(QCursor(Qt::WhatsThisCursor));
}

void frmSpreadSheet3::doHelpOnDataSetEditor(void)
{
    HelpCB("doc/UsersGuide.html#SSEditor");
}

void frmSpreadSheet3::write_set(void)
{
    plotarr *p=g[gno].p+setno;
    QString dummy1;
    double dummy2;
    for (int col=0;col<number_of_columns;col++)
    {
        for (int ro=0;ro<number_of_visible_entries;ro++)
        {
            if (ro+start_row>=getsetlength(gno,setno)) break;
            dummy1=Items[ro][col]->text();
            dummy2=atof(dummy1.toLocal8Bit());
            p->data.ex[col][ro+start_row]=dummy2;
        }
    }
    spreadSheetEntryChanged();
}

void frmSpreadSheet3::spreadSheetEntryChanged(void)
{
    ledComment->SetMemoryToText(g[gno].p[setno].comments,g[gno].p[setno].orig_comments);
    //static string used
    //char * buf=new char[ledComment->text().length()+8];
    //strcpy(buf,ledComment->text().toLocal8Bit().constData());
    //setcomment(gno,setno,buf);
    set_dirtystate();
    mainWin->mainArea->completeRedraw();
    //delete[] buf;
}

void frmSpreadSheet3::getSelection(int * n_of_sel,int ** sel)
{
    int nsel=10;
    int * sels=new int[nsel];
    int * old_sel;
    bool row_active;
    *n_of_sel=0;
    for (int i=0;i<MAX_NUMBER_OF_LINES_IN_SPREADSHEET;i++)//look in every line that has been allocated
    {
        row_active=false;
        for (int j=0;j<number_of_columns;j++)
        {
            if (Items[i][j]->isSelected()==true)
            {
                row_active=true;
                break;
            }
        }
        if (row_active==true)
        {//new selected row found
            if (nsel==*n_of_sel)
            {//not enough data for selection-storage
                old_sel=sels;
                sels=new int[nsel+30];
                nsel+=30;
                for (int k=0;k<*n_of_sel;k++)
                    sels[k]=old_sel[k];
                delete[] old_sel;
            }
            sels[*n_of_sel]=i;
            (*n_of_sel)++;
        }
    }
    *sel=new int[*n_of_sel];
    for (int i=0;i<*n_of_sel;i++)
        (*sel)[i]=sels[i];
    delete[] sels;
}

void frmSpreadSheet3::updateScrollBar(void)
{
    disconnect(scroll,SIGNAL(valueChanged(int)),this,SLOT(position_changed(int)));
    //scroll->setRange(0,getsetlength(gno,setno)-number_of_visible_entries+1);
    scroll->setRange(0,getsetlength(gno,setno)-1);
    scroll->setValue(start_row);
    scroll->setPageStep(number_of_visible_entries);
    connect(scroll,SIGNAL(valueChanged(int)),SLOT(position_changed(int)));
}

void frmSpreadSheet3::changeDirection(int keynr)
{
    if (working==true) return;
    working=true;
    nextScroll=scroll->value();
    nextRow=table->currentRow();
    nextCol=table->currentColumn();
    //cout << "start_row=" << start_row << " current_row=" << table->currentRow() << " scroll=" << scroll->value() << endl;
    switch (keynr)
    {
    case Qt::Key_Tab:
        //cout << "Tab" << endl;
        StepRight(nextRow,nextCol);
        break;
    case Qt::Key_Backtab:
        //cout << "BackTab" << endl;
        StepLeft(nextRow,nextCol);
        break;
        /*case Qt::Key_Return:
break;
case Qt::Key_Enter:
break;*/
    case Qt::Key_PageUp:
        nextScroll-=number_of_visible_entries-1;
        break;
    case Qt::Key_PageDown:
        nextScroll+=number_of_visible_entries-1;
        break;
    case Qt::Key_Down:
        if (table->currentRow()<number_of_visible_entries)
        {
            nextRow++;
            //cout << "new row" << endl;
        }
        else
        {
            nextScroll++;
            //cout << "new scroll "<< nextScrollValue << endl;
        }
        break;
    case Qt::Key_Up:
        if (table->currentRow()>0)
            nextRow--;
        else
            nextScroll--;
        break;
    case Qt::Key_Home:
        nextRow=0;
        nextScroll=0;
        break;
    case Qt::Key_End:
        nextRow=number_of_visible_entries-2;
        nextScroll=scroll->maximum();
        break;
        //defaut:
        //cout << keynr << endl;
        break;
    }

    if (nextRow!=table->currentRow() || nextCol!=table->currentColumn())
        table->setCurrentCell(nextRow,nextCol);
    working=false;
    if (nextScroll<0) nextScroll=0;
    if (nextScroll!=scroll->value())
        scroll->setValue(nextScroll);
}

void frmSpreadSheet3::currentCellChangedWrapper(int currentRow, int currentColumn, int previousRow, int previousColumn)
{
    (void)previousColumn;
    bool setEdit;
    if (working==true) return;
    working=true;
    setEdit=false;
    nextRow=currentRow;
    nextCol=currentColumn;
    nextScroll=scroll->value();
    ///cout << "(" << previousRow << "|" << previousColumn << ") --> (" << currentRow << "|" << currentColumn << ") vis_entr.=" << number_of_visible_entries << endl;
    if (currentRow>previousRow && currentRow>=number_of_visible_entries)
    {
        nextRow=number_of_visible_entries-1;
        nextScroll+=currentRow-previousRow;
        //cout << "Row hat Bereich nach unten verlassen!" << endl;
        setEdit=true;
        if (nextRow!=table->currentRow() || nextCol!=table->currentColumn())
            table->setCurrentCell(nextRow,nextCol);
    }
    else if (currentRow<previousRow && currentRow==0 && scroll->value()>0)
    {
        nextRow=1;
        nextScroll+=currentRow-previousRow;
        //cout << "Gone up" << endl;
        setEdit=true;
        if (nextRow!=table->currentRow() || nextCol!=table->currentColumn())
            table->setCurrentCell(nextRow,nextCol);
    }
    working=false;
    if (nextScroll<0) nextScroll=0;
    if (nextScroll!=scroll->value())
        scroll->setValue(nextScroll);
    if (setEdit==true)
        table->editItem(Items[nextRow][nextCol]);
}

void frmSpreadSheet3::StepLeft(int curRow,int curCol)//rows are in visible coordinates!
{
    nextRow=curRow;
    nextCol=curCol-1;
    nextScroll=scroll->value();
    if (nextCol<0)
    {
        nextCol=number_of_columns-1;
        nextRow--;
    }
    //column-changes are always within visible range / row-changes only sometimes
    if (nextRow<0)//row would leave visible area now
    {
        nextRow=0;//set actual row to last visible one
        nextScroll--;//scroll contents down
    }
    /// actually do something here
}

void frmSpreadSheet3::StepRight(int curRow,int curCol)//rows are in visible coordinates!
{
    nextRow=curRow;
    nextCol=curCol+1;
    nextScroll=scroll->value();
    if (nextCol>=number_of_columns)
    {
        nextCol=0;
        nextRow++;
    }
    //column-changes are always within visible range / row-changes only sometimes
    if (nextRow>=number_of_visible_entries)//row would leave visible area now
    {
        nextRow=number_of_visible_entries-1;//set actual row to last visible one
        nextScroll++;//scroll contents down
    }
    /// actually do something here
}


frmSetOp::frmSetOp(QWidget * parent):QDialog(parent)
{
    int number;
    QString entr[16];

 //setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Data set operations"));
    setWindowIcon(QIcon(*GraceIcon));
    CreateActions();
    prev_operation=0;

    lblDataSet=new QLabel(tr("Data sets:"),this);
    listSets=new uniList(SETLIST,this);
    listSets->setBehavior(true,true,true);

    menuBar=new QMenuBar(this);
    mnuFile=new QMenu("&File",this);
    mnuFile->setTearOffEnabled(true);
    mnuFile->addAction(actClose);
    mnuHelp=new QMenu("&Help",this);
    mnuHelp->setTearOffEnabled(true);
    mnuHelp->addAction(actHelpOnContext);
    mnuHelp->addSeparator();
    mnuHelp->addAction(actHelpOnSetOp);

    menuBar->addMenu(mnuFile);
    menuBar->addSeparator();
    menuBar->addMenu( mnuHelp );

    number=8;
    entr[0]=tr("Sort");
    entr[1]=tr("Reverse");
    entr[2]=tr("Join");
    entr[3]=tr("Split");
    entr[4]=tr("Drop points");
    entr[5]=tr("Restrict");
    entr[6]=tr("Swap columns");
    entr[7]=tr("Average set");
    selOperation=new StdSelector(this,tr("Operation type:"),number,entr);
    selOperation->entryValues[0]=DATASETOP_SORT;
    selOperation->entryValues[1]=DATASETOP_REVERSE;
    selOperation->entryValues[2]=DATASETOP_JOIN;
    selOperation->entryValues[3]=DATASETOP_SPLIT;
    selOperation->entryValues[4]=DATASETOP_DROP;
    selOperation->entryValues[5]=DATASETOP_RESTRICT;
    selOperation->entryValues[6]=DATASETOP_SWAP_COLS;
    selOperation->entryValues[7]=DATASETOP_AVERAGE_SET;
    connect(selOperation->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(changeSelection(int)));
    number=6;
    entr[0]=QString("X");
    entr[1]=QString("Y");
    entr[2]=QString("Y1");
    entr[3]=QString("Y2");
    entr[4]=QString("Y3");
    entr[5]=QString("Y4");
    selSortOn=new StdSelector(this,tr("Sort on:"),number,entr);
    selSwap1=new StdSelector(this,tr("Swap column"),number,entr);
    selSwap2=new StdSelector(this,tr("with column"),number,entr);
    selSwap1->setCurrentIndex(0);
    selSwap2->setCurrentIndex(1);
    number=2;
    entr[0]=tr("Ascending");
    entr[1]=tr("Descending");
    selSortOrder=new StdSelector(this,tr("Order:"),number,entr);

    ledLength=new stdLineEdit(this,tr("Length:"));
    ledLength->setVisible(false);
    ledStart=new stdLineEdit(this,tr("Start at:"));
    ledStart->setVisible(false);
    ledStop=new stdLineEdit(this,tr("Stop at:"));
    ledStop->setVisible(false);
    selSwap1->setVisible(false);
    selSwap2->setVisible(false);

    number=7;
    entr[0]=tr("None");
    entr[1]=tr("Region 0");
    entr[2]=tr("Region 1");
    entr[3]=tr("Region 2");
    entr[4]=tr("Region 3");
    entr[5]=tr("Region 4");
    entr[6]=tr("Inside graph");
    selRegion=new StdSelector(this,tr("Restrictions:"),number,entr);
    selRegion->setVisible(false);
    chkInvert=new QCheckBox(tr("Negate region"),this);
    chkInvert->setVisible(false);
    chkCreateNew=new QCheckBox(tr("Create new set"),this);
    chkCreateNew->setToolTip(tr("If checked a new set is created,\nif not checked the old set will be clipped"));
    chkCreateNew->setVisible(false);
    chkAllowInterpolation=new QCheckBox(tr("Allow set interpoltion"),this);
    chkAllowInterpolation->setToolTip(tr("If checked the sets are interpolated before an average set is created,\nif not checked the y-values of the sets are taken as they are\nregardless whether x-values match or not (the set-lengths have to match)"));
    chkAllowInterpolation->setVisible(false);
    connect(chkAllowInterpolation,SIGNAL(toggled(bool)),SLOT(allow_interpol_toggled(bool)));

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    layout=new QGridLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar,0,0,1,2);
#endif
    layout->addWidget(lblDataSet,1,0,1,2);
    layout->addWidget(listSets,2,0,3,2);
    layout->addWidget(selOperation,5,0,1,2);
    layout->addWidget(chkAllowInterpolation,6,0,1,2);
    layout->addWidget(selSortOn,7,0,1,1);
    layout->addWidget(selSortOrder,7,1,1,1);
    layout->addWidget(ledLength,7,0,1,2);
    layout->addWidget(ledStart,8,0,1,1);
    layout->addWidget(ledStop,8,1,1,1);
    layout->addWidget(selRegion,9,0,1,2);
    layout->addWidget(chkInvert,10,0,1,1);
    layout->addWidget(chkCreateNew,10,1,1,1);
    layout->addWidget(selSwap1,11,0,1,1);
    layout->addWidget(selSwap2,11,1,1,1);
    layout->addWidget(buttonGroup,12,0,1,2);

    layout->setRowStretch(0,0);
    layout->setRowStretch(1,0);
    layout->setRowStretch(2,1);
    layout->setRowStretch(3,1);
    layout->setRowStretch(4,1);
    layout->setRowStretch(5,0);
    layout->setRowStretch(6,0);
    layout->setRowStretch(7,0);
    layout->setRowStretch(8,0);
    layout->setRowStretch(9,0);
    layout->setRowStretch(10,0);
    layout->setRowStretch(11,0);
    layout->setRowStretch(12,0);
    resize(LastSize_FormSetOPS);
    setLayout(layout);
}

frmSetOp::~frmSetOp()
{
    LastSize_FormSetOPS=this->size();
}

void frmSetOp::init(void)
{
    listSets->set_graph_number(get_cg(),false);
    listSets->update_number_of_entries();
}

void frmSetOp::changeSelection(int i)
{
if (i==prev_operation) return;

    switch (prev_operation)
    {
    case DATASETOP_SORT://Sort
        selSortOn->setVisible(false);
        selSortOrder->setVisible(false);
        break;
    case DATASETOP_REVERSE://Reverse
        break;
    case DATASETOP_JOIN://Join
        break;
    case DATASETOP_SPLIT://Split
        ledLength->setVisible(false);
        break;
    case DATASETOP_DROP://Drop points
        ledStart->setVisible(false);
        ledStop->setVisible(false);
        break;
    case DATASETOP_RESTRICT://Restrict sets
        selRegion->setVisible(false);
        chkInvert->setVisible(false);
        chkCreateNew->setVisible(false);
        break;
    case DATASETOP_SWAP_COLS://Swap columns
        selSwap1->setVisible(false);
        selSwap2->setVisible(false);
        break;
    case DATASETOP_AVERAGE_SET://build the average a several sets
        chkAllowInterpolation->setVisible(false);
        ledLength->setVisible(false);
        ledStart->setVisible(false);
        ledStop->setVisible(false);
        break;
    default:
        selSortOn->setVisible(false);
        selSortOrder->setVisible(false);
        selRegion->setVisible(false);
        chkInvert->setVisible(false);
        chkCreateNew->setVisible(false);
        chkAllowInterpolation->setVisible(false);
        selSwap1->setVisible(false);
        selSwap2->setVisible(false);
        ledLength->setVisible(false);
        ledStart->setVisible(false);
        ledStop->setVisible(false);
        break;
    }

    switch (i)
    {
    case DATASETOP_SORT://Sort
        selSortOn->setVisible(true);
        selSortOrder->setVisible(true);
        break;
    case DATASETOP_REVERSE://Reverse
        break;
    case DATASETOP_JOIN://Join
        break;
    case DATASETOP_SPLIT://Split
        ledLength->setVisible(true);
        break;
    case DATASETOP_DROP://Drop points
        ledStart->setVisible(true);
        ledStop->setVisible(true);
        break;
    case DATASETOP_RESTRICT://Restrict sets
        selRegion->setVisible(true);
        chkInvert->setVisible(true);
        chkCreateNew->setVisible(true);
        break;
    case DATASETOP_SWAP_COLS://Swap columns
        selSwap1->setVisible(true);
        selSwap2->setVisible(true);
        break;
    case DATASETOP_AVERAGE_SET://build an averae set of several sets
        chkAllowInterpolation->setVisible(true);
        allow_interpol_toggled(false);
        break;
    default:
        selSortOn->setVisible(false);
        selSortOrder->setVisible(false);
        selRegion->setVisible(false);
        chkInvert->setVisible(false);
        chkCreateNew->setVisible(false);
        chkAllowInterpolation->setVisible(false);
        selSwap1->setVisible(false);
        selSwap2->setVisible(false);
        ledLength->setVisible(false);
        ledStart->setVisible(false);
        ledStop->setVisible(false);
        break;
    }
    prev_operation=i;
}

void frmSetOp::allow_interpol_toggled(bool c)
{
    (void)c;
    if (chkAllowInterpolation->isChecked()==true)
    {
        ledLength->setVisible(true);
        ledStart->setVisible(true);
        ledStop->setVisible(true);
    }
    else
    {
        ledLength->setVisible(false);
        ledStart->setVisible(false);
        ledStop->setVisible(false);
    }
}

void frmSetOp::CreateActions(void)
{
    actClose=new QAction(tr("&Close"),this);
    connect(actClose,SIGNAL(triggered()), this, SLOT(doClose()));
    actHelpOnContext=new QAction(tr("On conte&xt"),this);
    actHelpOnContext->setShortcut(tr("Shift+F1"));
    connect(actHelpOnContext,SIGNAL(triggered()), this, SLOT(doHelpOnContext()));
    actHelpOnSetOp=new QAction(tr("On data&set operations"),this);
    connect(actHelpOnSetOp,SIGNAL(triggered()), this, SLOT(doHelpOnSetOp()));
}

void frmSetOp::doClose(void)
{
    hide();
}

void frmSetOp::doApply(void)
{
static int son[MAX_SET_COLS] = {DATA_X, DATA_Y, DATA_Y1, DATA_Y2, DATA_Y3, DATA_Y4};
    ApplyError=false;
    int i;
    int sorton=0, stype=0, lpart;
    int optype,ret=RETURN_SUCCESS;
    double d_vals[2];
    int nsets,*selset,*gnos=NULL;
    selset=new int[2];
    listSets->get_selection(&nsets,&selset);

    if (nsets < 1) {
        ApplyError=true;
        errmsg(tr("No set selected").toLocal8Bit().constData());
    } else {
        optype=selOperation->currentIndex();
            gnos=new int[nsets+1];
            for (i=0;i<nsets;i++) gnos[i]=cg;
        switch (optype) {
        case DATASETOP_SORT:
            sorton = son[selSortOn->currentIndex()];
            stype = selSortOrder->currentIndex();
            ret=SmallSetOperations(nsets,gnos,selset,optype,sorton,stype,1,NULL);
            break;
        case DATASETOP_REVERSE:
            ret=SmallSetOperations(nsets,gnos,selset,optype,1,1,1,NULL);
            break;
        case DATASETOP_JOIN:
            ret=SmallSetOperations(nsets,gnos,selset,optype,1,1,1,NULL);
            break;
        case DATASETOP_SPLIT:
            xv_evalexpri(ledLength, &lpart);
            ret=SmallSetOperations(nsets,gnos,selset,optype,lpart,1,1,NULL);
            break;
        case DATASETOP_DROP:
            xv_evalexpri(ledStart, &sorton);
            xv_evalexpri(ledStop, &stype);
            ret=SmallSetOperations(nsets,gnos,selset,optype,sorton,stype,1,NULL);
            break;
        case DATASETOP_RESTRICT:
            switch (selRegion->currentIndex())
            {
            case 0:
                sorton=RESTRICT_NONE;
                break;
            case 1:
                sorton=RESTRICT_REG0;
                break;
            case 2:
                sorton=RESTRICT_REG1;
                break;
            case 3:
                sorton=RESTRICT_REG2;
                break;
            case 4:
                sorton=RESTRICT_REG3;
                break;
            case 5:
                sorton=RESTRICT_REG4;
                break;
            case 6:
                sorton=RESTRICT_WORLD;
                break;
            }
            stype=(chkInvert->isChecked()==true)?1:0;
            lpart=(chkCreateNew->isChecked()==true)?1:0;
            ret=SmallSetOperations(nsets,gnos,selset,optype,sorton,stype,lpart,NULL);
            break;
        case DATASETOP_SWAP_COLS:
            stype=selSwap1->currentValue();
            lpart=selSwap2->currentValue();
            ret=SmallSetOperations(nsets,gnos,selset,optype,lpart,stype,1,NULL);
            break;
        case DATASETOP_AVERAGE_SET:
            xv_evalexpr(ledStart, d_vals);
            xv_evalexpr(ledStop, d_vals+1);
            xv_evalexpri(ledLength, &lpart);
            if (chkAllowInterpolation->isChecked()==false) lpart=-1;//length invalid --> do not interpolate
            ret=SmallSetOperations(nsets,gnos,selset,optype,sorton,stype,lpart,d_vals);
            break;
        default://just to make some compilers happy
            break;
        }
        listSets->update_number_of_entries();
            if (optype==DATASETOP_JOIN && nsets>0)
            {
            listSets->set_new_selection(1,selset);
            }
            else if (optype==DATASETOP_SPLIT && nsets>0)
            {
            listSets->set_new_selection(new_set_no,new_set_nos);
            }
            else
            {
            listSets->set_new_selection(nsets,selset);
            }
        update_set_lists(cg);
        mainWin->mainArea->completeRedraw();
    }
    delete[] selset;
    delete[] gnos;
if (ret>0) ApplyError=true;
}

void frmSetOp::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmSetOp::doHelpOnContext(void)
{
    setCursor(QCursor(Qt::WhatsThisCursor));
}

void frmSetOp::doHelpOnSetOp(void)
{
    HelpCB("doc/UsersGuide.html#data-set-operations");
}


frmDeviceOptions::frmDeviceOptions(int device,QWidget * parent):QDialog(parent)
{
    int number;
    QString entr[5];

    Device=device;
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));

    grpPSoptions=new QGroupBox(tr("PS options"),this);
    layout0=new QVBoxLayout;
    //layout0->setMargin(STD_MARGIN);
    layout0->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    ps_setup_grayscale_item=new QCheckBox(tr("Grayscale output"),grpPSoptions);
    layout0->addWidget(ps_setup_grayscale_item);
    ps_setup_level2_item=new QCheckBox(tr("PS Level 2"),grpPSoptions);
    ps_setup_level2_item->setChecked(TRUE);
    layout0->addWidget(ps_setup_level2_item);
    number=3;
    entr[0]=tr("7bit");
    entr[1]=tr("8bit");
    entr[2]=tr("Binary");
    ps_setup_docdata_item=new StdSelector(grpPSoptions,tr("Document data:"),number,entr);
    ps_setup_docdata_item->setCurrentIndex(1);
    layout0->addWidget(ps_setup_docdata_item);
    grpPSoptions->setLayout(layout0);
    grpPSoptions->setVisible(FALSE);
    grpPageOffset=new QGroupBox(tr("Page offset (pt)"),this);
    layout1=new QHBoxLayout;
    //layout1->setMargin(STD_MARGIN);
    layout1->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    ps_setup_offset_x_item=new stdIntSelector(grpPageOffset,tr("X:"),-999,999);
    ps_setup_offset_x_item->spnInt->setSingleStep(10);
    layout1->addWidget(ps_setup_offset_x_item);
    ps_setup_offset_y_item=new stdIntSelector(grpPageOffset,tr("Y:"),-999,999);
    ps_setup_offset_y_item->spnInt->setSingleStep(10);
    layout1->addWidget(ps_setup_offset_y_item);
    grpPageOffset->setLayout(layout1);
    grpPageOffset->setVisible(FALSE);
    grpHardware=new QGroupBox(tr("Hardware"),this);
    layout2=new QVBoxLayout;
    //layout2->setMargin(STD_MARGIN);
    layout2->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    number=3;
    entr[0]=tr("Automatic");
    entr[1]=tr("Match size");
    entr[2]=tr("Manual");
    ps_setup_feed_item=new StdSelector(grpHardware,tr("Media feed:"),number,entr);
    layout2->addWidget(ps_setup_feed_item);
    ps_setup_hwres_item=new QCheckBox(tr("Set hardware resolution"),grpHardware);
    layout2->addWidget(ps_setup_hwres_item);
    grpHardware->setLayout(layout2);
    grpHardware->setVisible(FALSE);

    grpPNMoptions=new QGroupBox(tr("PNM options"),this);
    layout3=new QVBoxLayout;
    //layout3->setMargin(STD_MARGIN);
    layout3->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    number=3;
    entr[0]=tr("1-bit mono (PBM)");
    entr[1]=tr("8-bit grayscale (PGM)");
    entr[2]=tr("8-bit color (PPM)");
    pnm_setup_format_item=new StdSelector(grpPNMoptions,tr("Format:"),number,entr);
    pnm_setup_format_item->setCurrentIndex(2);
    layout3->addWidget(pnm_setup_format_item);
    pnm_setup_rawbits_item=new QCheckBox(tr("\"Rawbits\""),grpPNMoptions);
    pnm_setup_rawbits_item->setChecked(TRUE);
    layout3->addWidget(pnm_setup_rawbits_item);
    grpPNMoptions->setLayout(layout3);
    grpPNMoptions->setVisible(FALSE);

    grpEPSoptions=new QGroupBox(tr("EPS options"),this);
    layout4=new QVBoxLayout;
    //layout4->setMargin(STD_MARGIN);
    layout4->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    eps_setup_grayscale_item=new QCheckBox(tr("Grayscale output"),grpEPSoptions);
    layout4->addWidget(eps_setup_grayscale_item);
    eps_setup_level2_item=new QCheckBox(tr("PS Level 2"),grpEPSoptions);
    eps_setup_level2_item->setChecked(TRUE);
    layout4->addWidget(eps_setup_level2_item);
    eps_setup_tight_bb_item=new QCheckBox(tr("Tight BBox"),grpEPSoptions);
    eps_setup_tight_bb_item->setChecked(TRUE);
    layout4->addWidget(eps_setup_tight_bb_item);
    number=3;
    entr[0]=tr("7bit");
    entr[1]=tr("8bit");
    entr[2]=tr("Binary");
    eps_setup_docdata_item=new StdSelector(grpPSoptions,tr("Document data:"),number,entr);
    eps_setup_docdata_item->setCurrentIndex(1);
    layout4->addWidget(eps_setup_docdata_item);
    grpEPSoptions->setLayout(layout4);
    grpEPSoptions->setVisible(FALSE);

    grpJPEGoptions=new QGroupBox(tr("JPEG options"),this);
    layout5=new QVBoxLayout;
    //layout5->setMargin(STD_MARGIN);
    layout5->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    selQuality=new stdIntSelector(grpJPEGoptions,tr("Quality:"),0,100);
    selQuality->setValue(75);
    selQuality->spnInt->setSingleStep(5);
    layout5->addWidget(selQuality);
    chkOptimize=new QCheckBox(tr("Optimize"),grpJPEGoptions);
    layout5->addWidget(chkOptimize);
    chkProgressive=new QCheckBox(tr("Progressive"),grpJPEGoptions);
    layout5->addWidget(chkProgressive);
    chkJPG_Grayscale=new QCheckBox(tr("Grayscale"),grpJPEGoptions);
    layout5->addWidget(chkJPG_Grayscale);
    grpJPEGoptions->setLayout(layout5);
    grpJPEGoptions->setVisible(FALSE);
    grpJPEGadvoptions=new QGroupBox(tr("JPEG advanced options"),this);
    layout6=new QVBoxLayout;
    //layout6->setMargin(STD_MARGIN);
    layout6->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    selSmoothing=new stdIntSelector(grpJPEGadvoptions,tr("Smoothing:"),0,100);
    selSmoothing->spnInt->setSingleStep(10);
    layout6->addWidget(selSmoothing);
    chkForceBaseline=new QCheckBox(tr("Force baseline"),grpJPEGadvoptions);
    layout6->addWidget(chkForceBaseline);
    number=3;
    entr[0]=tr("Fast integer");
    entr[1]=tr("Slow integer");
    entr[2]=tr("Float");
    selDCT=new StdSelector(grpJPEGadvoptions,tr("DCT:"),number,entr);
    selDCT->setCurrentIndex(1);
    layout6->addWidget(selDCT);
    grpJPEGadvoptions->setLayout(layout6);
    grpJPEGadvoptions->setVisible(FALSE);

    grpPNGoptions=new QGroupBox(tr("PNG options"),this);
    layout7=new QVBoxLayout;
    //layout7->setMargin(STD_MARGIN);
    layout7->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    chkInterlaced=new QCheckBox(tr("Interlaced"),grpPNGoptions);
    layout7->addWidget(chkInterlaced);
    chkTransparent=new QCheckBox(tr("Transparent"),grpPNGoptions);
    layout7->addWidget(chkTransparent);
    selCompression=new stdIntSelector(grpPNGoptions,tr("Compression:"),0,9);
    selCompression->setValue(4);
    layout7->addWidget(selCompression);
    grpPNGoptions->setLayout(layout7);
    grpPNGoptions->setVisible(FALSE);

    grpBMPoptions=new QGroupBox(tr("BMP options"),this);
    layout8=new QVBoxLayout;
    //layout8->setMargin(STD_MARGIN);
    layout8->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    sldQuality=new stdSlider(grpBMPoptions,tr("Quality"),0,100);
    layout8->addWidget(sldQuality);
    sldQuality->setValue(outputQuality);
    chkGrayscale=new QCheckBox(tr("Grayscale"),grpBMPoptions);
    layout8->addWidget(chkGrayscale);
    grpBMPoptions->setLayout(layout8);
    grpBMPoptions->setVisible(FALSE);

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    switch (device)
    {
    case DEVICE_PS:
        setWindowTitle(tr("QtGrace: PS options"));
        grpPSoptions->setVisible(TRUE);
        grpPageOffset->setVisible(TRUE);
        grpHardware->setVisible(TRUE);
        layout->addWidget(grpPSoptions);
        layout->addWidget(grpPageOffset);
        layout->addWidget(grpHardware);
        break;
    case DEVICE_EPS:
        setWindowTitle(tr("QtGrace: EPS options"));
        grpEPSoptions->setVisible(TRUE);
        layout->addWidget(grpEPSoptions);
        break;
    case DEVICE_PNM:
        setWindowTitle(tr("QtGrace: PNM options"));
        grpPNMoptions->setVisible(TRUE);
        layout->addWidget(grpPNMoptions);
        break;
    case DEVICE_JPEG:
        setWindowTitle(tr("QtGrace: JPEG options"));
        grpJPEGoptions->setVisible(TRUE);
        grpJPEGadvoptions->setVisible(TRUE);
        layout->addWidget(grpJPEGoptions);
        layout->addWidget(grpJPEGadvoptions);
        break;
    case DEVICE_PNG:
        setWindowTitle(tr("QtGrace: PNG options"));
        grpPNGoptions->setVisible(TRUE);
        layout->addWidget(grpPNGoptions);
        break;
    case DEVICE_BMP:
        setWindowTitle(tr("QtGrace: BMP options"));
        grpBMPoptions->setTitle(tr("BMP options"));
        grpBMPoptions->setVisible(TRUE);
        layout->addWidget(grpBMPoptions);
        break;
    case DEVICE_TIFF:
        setWindowTitle(tr("QtGrace: TIFF options"));
        grpBMPoptions->setTitle(tr("TIFF options"));
        grpBMPoptions->setVisible(TRUE);
        layout->addWidget(grpBMPoptions);
        break;
    }
    layout->addWidget(buttonGroup);
    setLayout(layout);
    resize(LastSize_FormDeviceOptions);
}

frmDeviceOptions::~frmDeviceOptions()
{
    LastSize_FormDeviceOptions=this->size();
}

void frmDeviceOptions::init(void)
{
    if (Device==DEVICE_BMP || Device==DEVICE_JPEG || Device==DEVICE_PNG || Device==DEVICE_TIFF)
    {
        sldQuality->setValue(outputQuality);
        chkGrayscale->setChecked(outputGrayscale);
    }
    else if (Device==DEVICE_PS)
    {
        SetToggleButtonState(ps_setup_grayscale_item, ps_setup_grayscale);
        SetToggleButtonState(ps_setup_level2_item, ps_setup_level2);
        SetSpinChoice(ps_setup_offset_x_item, (double) ps_setup_offset_x);
        SetSpinChoice(ps_setup_offset_y_item, (double) ps_setup_offset_y);
        SetOptionChoice(ps_setup_feed_item, ps_setup_feed);
        SetToggleButtonState(ps_setup_hwres_item, ps_setup_hwres);
        SetOptionChoice(ps_setup_docdata_item, ps_setup_docdata);
    }
    else if (Device==DEVICE_EPS)
    {
        SetToggleButtonState(eps_setup_grayscale_item, eps_setup_grayscale);
        SetToggleButtonState(eps_setup_level2_item, eps_setup_level2);
        SetToggleButtonState(eps_setup_tight_bb_item, eps_setup_tight_bb);
        SetOptionChoice(eps_setup_docdata_item, eps_setup_docdata);
    }
    else if (Device==DEVICE_PNM)
    {
        SetChoice(pnm_setup_format_item, pnm_setup_format);
        SetToggleButtonState(pnm_setup_rawbits_item, pnm_setup_rawbits);
    }
    else
    {

    }
}

void frmDeviceOptions::doApply(void)
{
    ApplyError=false;
    if (Device==DEVICE_BMP || Device==DEVICE_JPEG || Device==DEVICE_PNG || Device==DEVICE_TIFF)
    {
        outputQuality=sldQuality->value();
        outputGrayscale=chkGrayscale->isChecked();
    }
    else if (Device==DEVICE_PS)
    {
        ps_setup_grayscale = GetToggleButtonState(ps_setup_grayscale_item);
        ps_setup_level2    = GetToggleButtonState(ps_setup_level2_item);
        ps_setup_offset_x  = (int) GetSpinChoice(ps_setup_offset_x_item);
        ps_setup_offset_y  = (int) GetSpinChoice(ps_setup_offset_y_item);
        ps_setup_feed      = GetOptionChoice(ps_setup_feed_item);
        ps_setup_hwres     = GetToggleButtonState(ps_setup_hwres_item);
        ps_setup_docdata   = GetOptionChoice(ps_setup_docdata_item);
    }
    else if (Device==DEVICE_EPS)
    {
        eps_setup_grayscale = GetToggleButtonState(eps_setup_grayscale_item);
        eps_setup_level2 = GetToggleButtonState(eps_setup_level2_item);
        eps_setup_tight_bb = GetToggleButtonState(eps_setup_tight_bb_item);
        eps_setup_docdata = GetOptionChoice(eps_setup_docdata_item);
    }
    else if (Device==DEVICE_PNM)
    {
        pnm_setup_format = GetChoice(pnm_setup_format_item);
        pnm_setup_rawbits = GetToggleButtonState(pnm_setup_rawbits_item);
    }
    else
    {
    ;
    }
}

void frmDeviceOptions::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmDeviceOptions::doClose(void)
{
    hide();
}

frmDeviceActivator::frmDeviceActivator(QWidget * parent):QDialog(parent)
{
setWindowTitle(tr("QtGrace: Enable/Disable export formats"));
layout=new QGridLayout;
//layout->setMargin(STD_MARGIN);
layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
layout->setSpacing(STD_SPACING);
cmdAll=new QPushButton(tr("Activate all"),this);
cmdApply=new QPushButton(tr("Accept"),this);
cmdClose=new QPushButton(tr("Close"),this);
connect(cmdApply,SIGNAL(clicked()),SLOT(doApply()));
connect(cmdAll,SIGNAL(clicked()),SLOT(doAll()));
connect(cmdClose,SIGNAL(clicked()),SLOT(doClose()));
int index=0;
layout->addWidget(cmdAll,index++,0,1,2);
alloc_checks=3;
chkDeviceActive=new QCheckBox*[alloc_checks];
    for (int i=0;i<alloc_checks;i++)
    {
    chkDeviceActive[i]=new QCheckBox(QString("test"),this);
    layout->addWidget(chkDeviceActive[i],index++,0,1,2);
    }
layout->addWidget(cmdApply,index,0,1,1);
layout->addWidget(cmdClose,index++,1,1,1);
setLayout(layout);
resize(LastSize_DeviceActivator);
}

frmDeviceActivator::~frmDeviceActivator()
{
    LastSize_DeviceActivator=this->size();
}

void frmDeviceActivator::doAll(void)
{
    for (int i=0;i<alloc_checks;i++)
    {
    chkDeviceActive[i]->setChecked(true);
    }
}

void frmDeviceActivator::init(void)
{
//delete old checkBoxes
    for (int i=0;i<alloc_checks;i++)
    {
    delete chkDeviceActive[i];
    }
delete[] chkDeviceActive;
//create new checkBoxes
alloc_checks=number_of_devices();
chkDeviceActive=new QCheckBox*[alloc_checks];
int index=1;
    for (int i=0;i<alloc_checks;i++)
    {
    chkDeviceActive[i]=new QCheckBox(QString(get_device_name(i)),this);
    layout->addWidget(chkDeviceActive[i],index++,0,1,2);
    chkDeviceActive[i]->setChecked(isDeviceActive(i));
    }
    chkDeviceActive[DEVICE_TERM]->hide();
    chkDeviceActive[DEVICE_TERM]->setChecked(true);//Screen is always active
layout->addWidget(cmdApply,index,0,1,1);
layout->addWidget(cmdClose,index++,1,1,1);
}

void frmDeviceActivator::doApply(void)
{
    for (int i=0;i<alloc_checks;i++)
    {
    setDeviceActive(i,chkDeviceActive[i]->isChecked());
    }
        if (FormDeviceSetup!=NULL)
        {
        FormDeviceSetup->changeDeviceList(FormDeviceSetup->cur_version);
        }
    doClose();
}

void frmDeviceActivator::doClose(void)
{
hide();
}

frmUserDefaultGeometries::frmUserDefaultGeometries(QWidget * parent):QDialog(parent)
{
    int row=0,column=0;
    setWindowTitle(tr("QtGrace: Settings for User-Default-Geometries"));
    setWindowIcon(QIcon(*GraceIcon));
    layout=new QGridLayout();
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    lblDescription=new QLabel(tr("Settings for quick changes in page geometry. Negative values mean: no changes."),this);
    layout->addWidget(lblDescription,row,0,1,10);
    lblTitles[0]=new QLabel(tr("#"),this);
    lblTitles[1]=new QLabel(tr("Active"),this);
    lblTitles[2]=new QLabel(tr("Name"),this);
    lblTitles[3]=new QLabel(tr("Format"),this);
    lblTitles[4]=new QLabel(tr("Orientation"),this);
    lblTitles[5]=new QLabel(tr("Width"),this);
    lblTitles[6]=new QLabel(tr("Height"),this);
    lblTitles[7]=new QLabel(tr("Unit"),this);
    lblTitles[8]=new QLabel(tr("DPI"),this);
    lblTitles[9]=new QLabel(tr("Antialiasing"),this);
    lblTitles[10]=new QLabel(tr("Linescaling"),this);
    row=1;
    for (int i=0;i<11;i++)
    {
    layout->addWidget(lblTitles[i],row,i,1,1);
    }
    row++;
    for (int i=0;i<NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES;i++)
    {
    column=0;
    lblNr[i]=new QLabel(QString::number(i+1),this);
    layout->addWidget(lblNr[i],row,column++,1,1);
    chkActive1[i]=new QCheckBox(QString(""),this);
    layout->addWidget(chkActive1[i],row,column++,1,1);
    lenName[i]=new QLineEdit(this);
    layout->addWidget(lenName[i],row,column++,1,1);
    cmbDevice[i]=new QComboBox(this);
        cmbDevice[i]->addItem(tr("No change"));
        for (int j=0;j<number_of_devices();j++)
        {
        cmbDevice[i]->addItem(get_device_name(j));
        }
    layout->addWidget(cmbDevice[i],row,column++,1,1);
    cmbOrientation[i]=new QComboBox(this);
        cmbOrientation[i]->addItem(tr("No change"));
        cmbOrientation[i]->addItem(tr("Landscape"));
        cmbOrientation[i]->addItem(tr("Portrait"));
    layout->addWidget(cmbOrientation[i],row,column++,1,1);
    spnWidth[i]=new QDoubleSpinBox(this);
        spnWidth[i]->setRange(-1.0,100000.0);
        spnWidth[i]->setSingleStep(1.0);
        spnWidth[i]->setDecimals(2);
    layout->addWidget(spnWidth[i],row,column++,1,1);
    spnHeight[i]=new QDoubleSpinBox(this);
        spnHeight[i]->setRange(-1.0,100000.0);
        spnHeight[i]->setSingleStep(1.0);
        spnHeight[i]->setDecimals(2);
    layout->addWidget(spnHeight[i],row,column++,1,1);
    cmbUnit[i]=new QComboBox(this);
        cmbUnit[i]->addItem(tr("No change"));
        cmbUnit[i]->addItem(tr("pix"));
        cmbUnit[i]->addItem(tr("in"));
        cmbUnit[i]->addItem(tr("cm"));
    layout->addWidget(cmbUnit[i],row,column++,1,1);
    spnResolution[i]=new QDoubleSpinBox(this);
        spnResolution[i]->setRange(-1.0,6000.0);
        spnResolution[i]->setSingleStep(1.0);
        spnResolution[i]->setDecimals(2);
    layout->addWidget(spnResolution[i],row,column++,1,1);
    cmbAntialiasing[i]=new QComboBox(this);
        cmbAntialiasing[i]->addItem(tr("No change"));
        cmbAntialiasing[i]->addItem(tr("None"));
        cmbAntialiasing[i]->addItem(tr("Fonts only"));
        cmbAntialiasing[i]->addItem(tr("Plot only"));
        cmbAntialiasing[i]->addItem(tr("Fonts and plot"));
    layout->addWidget(cmbAntialiasing[i],row,column++,1,1);
    cmbLineScaling[i]=new QComboBox(this);
        cmbLineScaling[i]->addItem(tr("No change"));
        cmbLineScaling[i]->addItem(tr("No scaling"));
        cmbLineScaling[i]->addItem(tr("Line scaling"));
    layout->addWidget(cmbLineScaling[i],row++,column++,1,1);
    }

    empty=new QWidget(this);
    layout0=new QGridLayout(this);
    layout0->setSpacing(STD_SPACING);
    //layout0->setMargin(0);
    layout0->setContentsMargins(0,0,0,0);
    lblActive2=new QLabel(tr("Activate internal default quick-selection-geometries:"),this);
    layout->addWidget(lblActive2,row++,0,1,11);
    int max_in_row=4,row2=0,column2=0;
    for (int i=0;i<NR_OF_QUICKSELECTOPTIONS;i++)
    {
    chkActive2[i]=new QCheckBox(QString(DefaultSystemDeviceGeometry[i].name),this);
    layout0->addWidget(chkActive2[i],row2,column2++);
        if (column2>=max_in_row)
        {
        row2++;
        column2=0;
        }
    }
    empty->setLayout(layout0);
    layout->addWidget(empty,row++,0,1,11);
    buttons=new stdButtonGroup(this);
    connect(buttons->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttons->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttons->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    layout->addWidget(buttons,row,0,1,11);
    setLayout(layout);
    redisplaySeparators();
    resize(LastSize_FormUserDefaultDevice);
}

frmUserDefaultGeometries::~frmUserDefaultGeometries()
{
LastSize_FormUserDefaultDevice=this->size();
}

void frmUserDefaultGeometries::init(void)
{
    for (int i=0;i<NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES;i++)
    {
    lenName[i]->setText(QString::fromLocal8Bit(DefaultUserDeviceGeometry[i].name));
    chkActive1[i]->setChecked((bool)DefaultUserDeviceGeometry[i].active);
    cmbDevice[i]->setCurrentIndex(DefaultUserDeviceGeometry[i].dev_nr+1);
    cmbOrientation[i]->setCurrentIndex(DefaultUserDeviceGeometry[i].orientation+1);
    spnWidth[i]->setValue(DefaultUserDeviceGeometry[i].width);
    spnHeight[i]->setValue(DefaultUserDeviceGeometry[i].height);
    cmbUnit[i]->setCurrentIndex(DefaultUserDeviceGeometry[i].unit+1);
    spnResolution[i]->setValue(DefaultUserDeviceGeometry[i].dpi);
    cmbAntialiasing[i]->setCurrentIndex(DefaultUserDeviceGeometry[i].Antialiasing+1);
    cmbLineScaling[i]->setCurrentIndex(DefaultUserDeviceGeometry[i].ScaleLineWidth+1);
    }
    for (int i=0;i<NR_OF_QUICKSELECTOPTIONS;i++)
    {
    chkActive2[i]->setChecked((bool)DefaultSystemDeviceGeometry[i].active);
    }
}

void frmUserDefaultGeometries::doApply(void)
{
    for (int i=0;i<NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES;i++)
    {
    strcpy(DefaultUserDeviceGeometry[i].name,lenName[i]->text().toLocal8Bit().constData());
    DefaultUserDeviceGeometry[i].active=(chkActive1[i]->isChecked()==true?TRUE:FALSE);
    DefaultUserDeviceGeometry[i].dev_nr=cmbDevice[i]->currentIndex()-1;
    DefaultUserDeviceGeometry[i].orientation=cmbOrientation[i]->currentIndex()-1;
    DefaultUserDeviceGeometry[i].width=spnWidth[i]->value();
    DefaultUserDeviceGeometry[i].height=spnHeight[i]->value();
    DefaultUserDeviceGeometry[i].unit=cmbUnit[i]->currentIndex()-1;
    DefaultUserDeviceGeometry[i].dpi=spnResolution[i]->value();
    DefaultUserDeviceGeometry[i].Antialiasing=cmbAntialiasing[i]->currentIndex()-1;
    DefaultUserDeviceGeometry[i].ScaleLineWidth=cmbLineScaling[i]->currentIndex()-1;
    }
    for (int i=0;i<NR_OF_QUICKSELECTOPTIONS;i++)
    {
    DefaultSystemDeviceGeometry[i].active=(chkActive2[i]->isChecked()==true?TRUE:FALSE);
    }
    emit(newUserDefaults());
}

void frmUserDefaultGeometries::doAccept(void)
{
    ApplyError=false;
    doApply();
    if (ApplyError==false)
    doClose();
}

void frmUserDefaultGeometries::doClose(void)
{
    hide();
}

void frmUserDefaultGeometries::redisplaySeparators(void)
{
    QLocale newLocale=(DecimalPointToUse=='.')?(*dot_locale):(*comma_locale);
///qDebug() << "newLocale=" << DecimalPointToUse;
    for (int i=0;i<NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES;i++)
    {
    spnWidth[i]->setLocale(newLocale);
    spnHeight[i]->setLocale(newLocale);
    spnResolution[i]->setLocale(newLocale);
    spnWidth[i]->setValue(spnWidth[i]->value());
    spnHeight[i]->setValue(spnHeight[i]->value());
    spnResolution[i]->setValue(spnResolution[i]->value());
    }
}

frmDeviceSetup::frmDeviceSetup(QWidget * parent):QDialog(parent)
{
    cur_version=0;
    actNativePrinterDialog=NULL;
    printDialog=NULL;
    int number;
    QString entr[32];
    int i_entr[32];
    strcpy(out_format_int,"%.0f");
    strcpy(out_format_float,"%.2f");
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: File Export Setup"));
    setWindowIcon(QIcon(*GraceIcon));
    cur_dev=0;
    parent_of_print_dialog=0;

    CreateActions();
//cout << "DeviceSetup_Start: " << actNativePrinterDialog << endl;

    grpDevSetup=new QGroupBox(tr("Device setup"),this);
    grpOutput=new QGroupBox(tr("Output"),this);
    grpPage=new QGroupBox(tr("Page-Settings"),this);
    grpFonts=new QGroupBox(tr("Font-Settings"),this);

    grpPage->setCheckable(true);
    connect(grpPage,SIGNAL(toggled(bool)),this,SLOT(geometryGroupToggled(bool)));
    grpFonts->setCheckable(true);
    connect(grpFonts,SIGNAL(toggled(bool)),this,SLOT(fontGroupToggled(bool)));

    device_opts_item=new QPushButton(tr("Format options..."),grpDevSetup);
    connect(device_opts_item,SIGNAL(clicked()),this,SLOT(doDevOpt()));
    wbut=new QPushButton(tr("Browse..."),grpOutput);
    connect(wbut,SIGNAL(clicked()),this,SLOT(doBrowse()));

    menuBar=new QMenuBar(this);
    mnuFile=new QMenu("&File",this);
    mnuFile->setTearOffEnabled(TRUE);
    mnuFile->addAction(actNativePrinterDialog);
    mnuFile->addAction(actPrintToFile);
    mnuFile->addSeparator();
    mnuFile->addAction(actClose);
    mnuOptions=new QMenu("&Options",this);
    mnuOptions->setTearOffEnabled(TRUE);
    mnuOptions->addAction(dsync_item);
    mnuOptions->addAction(psync_item);
    mnuQuickSelect=new QMenu("&Quick Format Selection",this);
    mnuQuickSelect->setTearOffEnabled(TRUE);
    mnuHelp=new QMenu("&Help",this);
    mnuHelp->setTearOffEnabled(TRUE);
    mnuHelp->addAction(actHelpOnContext);
    mnuHelp->addSeparator();
    mnuHelp->addAction(actHelpOnDevSetup);

    menuBar->addMenu(mnuFile);
    menuBar->addMenu(mnuOptions);
    menuBar->addMenu(mnuQuickSelect);
    menuBar->addSeparator();
    menuBar->addMenu(mnuHelp);

    number=number_of_devices();
    for (int i=0;i<number;i++)
    {
    entr[i]=get_device_name(i);
    }
    devices_item=new StdSelector(grpDevSetup,tr("Output format:"),number,entr);
    connect(devices_item->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(DeviceChanged(int)));
    number=2;
    entr[0]=tr("Landscape");
    entr[1]=tr("Portrait");
    i_entr[0]=PAGE_ORIENT_LANDSCAPE;
    i_entr[1]=PAGE_ORIENT_PORTRAIT;
    page_orient_item=new StdSelector(grpPage,tr("Orientation:"),number,entr);
    page_orient_item->setValues(i_entr);
    connect(page_orient_item->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(OrientationChanged(int)));
#if QT_VERSION >= 0x050000

#else
    quickMapper=new QSignalMapper();
#endif
        for (int i=0;i<NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES;i++)
        {
        act_quickSel[i]=new QAction(tr("User Default ") + QString::number(i+1) + QString(": ") + QString::fromLocal8Bit(DefaultUserDeviceGeometry[i].name),this);
#if QT_VERSION >= 0x050000
        connect(act_quickSel[i],&QAction::triggered,this,[this,i](){this->QuickResolutionChange(i-NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES);});
#else
        connect(act_quickSel[i], SIGNAL(triggered()), quickMapper, SLOT(map()));
        quickMapper->setMapping(act_quickSel[i],-NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i);
#endif
        mnuQuickSelect->addAction(act_quickSel[i]);
        }
#if QT_VERSION >= 0x050000

#else
    connect(quickMapper, SIGNAL(mapped(int)),this, SLOT(QuickResolutionChange(int)));
#endif
    mnuQuickSelect->addSeparator();

    for (int i=0;i<NR_OF_QUICKSELECTOPTIONS;i++)
    {
    //entr[i]+=QString(" (")+QString::number(quick_pg[i].width)+QString("x")+QString::number(quick_pg[i].height)+QString(")");
    act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i]=new QAction(QString(DefaultSystemDeviceGeometry[i].name),this);
#if QT_VERSION >= 0x050000
    connect(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i], &QAction::triggered,this,[this,i](){this->QuickResolutionChange(i);});
#else
    connect(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i], SIGNAL(triggered()), quickMapper, SLOT(map()));
    quickMapper->setMapping(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i],i);
#endif
    mnuQuickSelect->addAction(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i]);
    }
    mnuQuickSelect->addSeparator();
    act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+NR_OF_QUICKSELECTOPTIONS]=new QAction(tr("Edit User Default Geometries"),this);
    mnuQuickSelect->addAction(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+NR_OF_QUICKSELECTOPTIONS]);
    connect(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+NR_OF_QUICKSELECTOPTIONS],SIGNAL(triggered()),this,SLOT(doDefaultPageGeometrySetup()));
    mnuQuickSelect->addSeparator();
    act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+NR_OF_QUICKSELECTOPTIONS+1]=new QAction(tr("Discard changes / Reset settings"),this);
    mnuQuickSelect->addAction(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+NR_OF_QUICKSELECTOPTIONS+1]);
    connect(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+NR_OF_QUICKSELECTOPTIONS+1],SIGNAL(triggered()),this,SLOT(doReset()));

    quick_resolution_selector=new StdSelector(grpPage,tr("Quick select:"),number,entr);
    connect(quick_resolution_selector->cmbSelect,SIGNAL(activated(int)),SLOT(QuickResolutionChange(int)));

    number=12;
    entr[0]=tr("Custom");
    entr[1]=tr("Letter");
    entr[2]=tr("A4");
    entr[3]=tr("A3");
    entr[4]=tr("A2");
    entr[5]=tr("A1");
    entr[6]=tr("A0");
    entr[7]=tr("B4");
    entr[8]=tr("B5");
    entr[9]=tr("B6");
    entr[10]=tr("Legal");
    entr[11]=tr("Tabloid");
    i_entr[0]=PAGE_FORMAT_CUSTOM;
    i_entr[1]=PAGE_FORMAT_USLETTER;
    i_entr[2]=PAGE_FORMAT_A4;
    i_entr[3]=PAGE_FORMAT_A3;
    i_entr[4]=PAGE_FORMAT_A2;
    i_entr[5]=PAGE_FORMAT_A1;
    i_entr[6]=PAGE_FORMAT_A0;
    i_entr[7]=PAGE_FORMAT_B4;
    i_entr[8]=PAGE_FORMAT_B5;
    i_entr[9]=PAGE_FORMAT_B6;
    i_entr[10]=PAGE_FORMAT_USLEGAL;
    i_entr[11]=PAGE_FORMAT_USTABLOID;
    page_format_item=new StdSelector(grpPage,tr("Size:"),number,entr);
    page_format_item->setValues(i_entr);
    connect(page_format_item->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(SizeChanged(int)));

    print_string_item=new stdLineEdit(grpOutput,tr("Print command:"));
    print_string_item->lenText->setText(QString(""));
    print_string_item->setVisible(false);
    printfile_item=new stdLineEdit(grpOutput,tr("File name:"));
    printfile_item->lenText->setText(QString(""));
    page_x_item=new stdLineEdit(grpPage,tr("Dimensions:"));
    page_y_item=new stdLineEdit(grpPage,tr("x"));
    dev_res_item=new stdLineEdit(grpPage,tr("Resolution (dpi):"));
    connect(dev_res_item->lenText,SIGNAL(textEdited(QString)),SLOT(dpiInputChanged(QString)));
    //connect(dev_res_item->lenText,SIGNAL(returnPressed()),SLOT(DpisChanged()));
    page_size_unit_item=new QComboBox(grpPage);
    page_size_unit_item->addItem(tr("pix"));
    page_size_unit_item->addItem(tr("in"));
    page_size_unit_item->addItem(tr("cm"));
    connect(page_size_unit_item,SIGNAL(currentIndexChanged(int)),this,SLOT(DimChanged(int)));
    chkDontChangeSize=new QCheckBox(tr("Don't reposition Graph(s) "),this);
    chkScaleLineWidthByResolution=new QCheckBox(tr("Scale line width by resolution "),this);
    chkUseAntialiasing=new QCheckBox(tr("Enable antialiasing (except for fonts) "),this);

    printto_item=new QCheckBox(tr("Print to file"),grpOutput);
    connect(printto_item,SIGNAL(stateChanged(int)),this,SLOT(PrintToFileClicked(int)));
    printto_item->setVisible(false);

    fontaa_item=new QCheckBox(tr("Enable font antialiasing"),grpFonts);
    devfont_item=new QCheckBox(tr("Use device fonts"),grpFonts);
    devfont_item->setChecked(TRUE);
/*
qDebug() << "DeviceSetup_Mitte: " << actNativePrinterDialog;

    actNativePrinterDialog=new QAction(this);
    connect(actNativePrinterDialog,SIGNAL(triggered()),this,SLOT(doNativePrinterDialog()));

qDebug() << "DeviceSetup_Ende: " << actNativePrinterDialog;
*/
    cmdNativePrinterDialog=new QPushButton(tr("Open native printer dialog"),this);
    connect(cmdNativePrinterDialog,SIGNAL(clicked()),this,SLOT(doNativePrinterDialog()));
    cmdNativePrinterDialog->setVisible(false);

    chkClipOutput=new QCheckBox(tr("Clip empty border areas"),this);
    chkClipOutput->setToolTip(tr("Removes the empty areas around the borders from the output\n(i.e. output starts at the first pixel that is not the background)\ncurrenty only implemented for pixel-graphics (bmp,png,jpg,tiff)"));

    cmdDoPrint=new QPushButton(tr("Export to File"),this);
    connect(cmdDoPrint,SIGNAL(clicked()),SLOT(doPrintToFile()));
    QFont ExportCmdFont=cmdDoPrint->font();
    ExportCmdFont.setBold(true);
    cmdDoPrint->setFont(ExportCmdFont);

    cmdUseScreenResolution=new QPushButton(tr("Use screen resolution"),this);
    connect(cmdUseScreenResolution,SIGNAL(clicked()),SLOT(doUseScreenResolution()));

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

        for (int i=0;i<7;i++)
        DevOptions[i]=NULL;

    layout0=new QHBoxLayout();
    //layout0->setMargin(STD_MARGIN);
    layout0->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout0->setSpacing(STD_SPACING);
    layout0->addWidget(devices_item);
    layout0->addWidget(device_opts_item);
    grpDevSetup->setLayout(layout0);
    layout1=new QGridLayout();
    //layout1->setMargin(STD_MARGIN);
    layout1->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
        /*layout1->addWidget(printto_item,0,0,1,1);
        layout1->addWidget(cmdDoPrint,0,1,1,1);
        layout1->addWidget(cmdNativePrinterDialog,0,2,1,1);*/
    layout1->addWidget(cmdDoPrint,2,0,1,3);
        //layout1->addWidget(cmdDoPrint,1,0,1,1);
        //layout1->addWidget(cmdNativePrinterDialog,1,1,1,1);
        //layout1->addWidget(print_string_item,1,0,1,3);
    layout1->addWidget(printfile_item,0,0,1,2);
    layout1->addWidget(chkClipOutput,1,0,1,3);
    layout1->addWidget(wbut,0,2);
    grpOutput->setLayout(layout1);
    layout2=new QGridLayout();
    //layout2->setMargin(STD_MARGIN);
    layout2->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout2->setSpacing(STD_SPACING);
    layout2->addWidget(page_orient_item,0,0,1,2);
    layout2->addWidget(page_format_item,0,2,1,2);
    layout2->addWidget(page_x_item,1,0,1,2);
    layout2->addWidget(page_y_item,1,2);
    layout2->addWidget(page_size_unit_item,1,3);
    layout2->addWidget(dev_res_item,2,0);//,1,2
    layout2->addWidget(cmdUseScreenResolution,2,1);
    layout2->addWidget(chkDontChangeSize,3,1);//,2,1,1,2);
    layout2->addWidget(chkScaleLineWidthByResolution,3,2);
    layout2->setRowStretch(0,1);
    layout2->setRowStretch(1,1);
    layout2->setRowStretch(2,1);
    layout2->setRowStretch(3,1);
    //layout2->setRowStretch(4,10);
    layout2->setColumnStretch(0,2);
    layout2->setColumnStretch(1,2);
    layout2->setColumnStretch(2,2);
    //layout2->addWidget(quick_resolution_selector,3,0);
    quick_resolution_selector->hide();
    layout2->addWidget(chkUseAntialiasing,3,0);
    grpPage->setLayout(layout2);
    layout3=new QGridLayout();
    //layout3->setMargin(STD_MARGIN);
    layout3->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout3->setSpacing(STD_SPACING);
    layout3->addWidget(fontaa_item,0,0);
    layout3->addWidget(devfont_item,0,1);
    layout3->setRowStretch(0,1);
    //layout3->setRowStretch(1,10);
    grpFonts->setLayout(layout3);

    layout=new QVBoxLayout();
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar);
#endif
    layout->addWidget(grpDevSetup);
    layout->addWidget(grpOutput);
    layout->addWidget(grpPage);
    layout->addWidget(grpFonts);
    layout->addWidget(buttonGroup);
    //layout->addStretch(10);

    /*layout->setStretch(0,0);
    layout->setStretch(1,1);
    layout->setStretch(2,1);
    layout->setStretch(3,1);
    layout->setStretch(4,1);
    layout->setStretch(5,0);
    layout->setStretch(6,10);*/
    setLayout(layout);

    printto_item->setChecked(TRUE);
    PrintToFileClicked(Qt::Checked);
    page_format_item->setCurrentIndex(1);
    DeviceChanged(0);
    resize(LastSize_FormDeviceSetup);
}

frmDeviceSetup::~frmDeviceSetup()
{
    showPageSettings=grpPage->isChecked();
    showFontSettings=grpFonts->isChecked();
    LastSize_FormDeviceSetup=this->size();
}

void frmDeviceSetup::init(int dev)
{
//SetOptionChoice(devices_item, dev);
//qDebug() << "ClipEdges=" << clip_borders_for_output << endl;
    devices_item->setCurrentValue(dev);
    DeviceChanged(dev);
    dsync_item->setChecked(sync_device_dims);
    psync_item->setChecked(rescale_plot_on_size_change);
//qDebug() << "ShowPage=" << showPageSettings;
//qDebug() << "ShowFont=" << showFontSettings;
    grpPage->setChecked((bool)showPageSettings);
    grpFonts->setChecked((bool)showFontSettings);
    recreateQuickMenu();
grpPage->adjustSize();
grpFonts->adjustSize();
this->adjustSize();
}

void frmDeviceSetup::CreateActions(void)
{
    actNativePrinterDialog=new QAction(tr("&Print"),this);
    actNativePrinterDialog->setShortcut(tr("Ctrl+P"));
    actNativePrinterDialog->setStatusTip(tr("Print on physical printer, using the settings in this dialog."));
    connect(actNativePrinterDialog,SIGNAL(triggered()), this, SLOT(doPrintToPrinter()));
    actPrintToFile=new QAction(tr("&Export to file"),this);
    actPrintToFile->setShortcut(tr("Ctrl+F"));
    connect(actPrintToFile,SIGNAL(triggered()), this, SLOT(doPrintToFile()));
    dsync_item=new QAction(tr("&Sync page size of screen and all output formats"),this);
    dsync_item->setCheckable(TRUE);
    dsync_item->setChecked(TRUE);
    connect(dsync_item,SIGNAL(triggered()), this, SLOT(doSyncPage()));
    psync_item=new QAction(tr("&Rescale plot on page size change"),this);
    psync_item->setCheckable(TRUE);
    psync_item->setChecked(FALSE);
    connect(psync_item,SIGNAL(triggered()), this, SLOT(doRescalePlot()));
    actClose=new QAction(tr("&Close"),this);
    actClose->setShortcut(tr("Esc"));
    connect(actClose,SIGNAL(triggered()), this, SLOT(doClose()));
    actHelpOnContext=new QAction(tr("On conte&xt"),this);
    actHelpOnContext->setShortcut(tr("Shift+F1"));
    connect(actHelpOnContext,SIGNAL(triggered()), this, SLOT(doHelpOnContext()));
    actHelpOnDevSetup=new QAction(tr("On &device setup"),this);
    connect(actHelpOnDevSetup,SIGNAL(triggered()), this, SLOT(doHelpOnDevSetup()));
}

void frmDeviceSetup::PrintToFileClicked(int i)
{
    if (i==Qt::Checked)
    {
        print_string_item->setEnabled(FALSE);
        printfile_item->setEnabled(TRUE);
        wbut->setEnabled(TRUE);
    }
    else if (i==Qt::Unchecked)
    {
        print_string_item->setEnabled(TRUE);
        printfile_item->setEnabled(FALSE);
        wbut->setEnabled(FALSE);
    }
}

void frmDeviceSetup::DeviceChanged(int device_id)//output-device changed (screen, pdf, png, ...)
{
    char buf[GR_MAXPATHLEN];//, *bufptr;
    int page_units;
    double page_x, page_y;
    (void)device_id;
    PageFormat pf;

    Page_geometry pg;
    Device_entry dev;

    //cur_dev=device_id;
    //dev = get_device_props(device_id);

    cur_dev=devices_item->currentValue();
    dev = get_device_props(cur_dev);

    pg = dev.pg;

    if (dev.setup == NULL) {
        SetSensitive(device_opts_item, false);
    } else {
        SetSensitive(device_opts_item, true);
    }

    if (dev.type==DEVICE_TERM)
    {
        device_opts_item->setText(tr("Copy page to clipboard."));
        SetSensitive(device_opts_item, true);
    }
    else
    {
        device_opts_item->setText(tr("Format options..."));
    }

    //if (print_file == NULL || print_file[0] == '\0') {
    if (print_file[0] == '\0') {
        strcpy(print_file, mybasename(get_docname()));
    }

    /// * Replace existing filename extension */
    /*bufptr = strrchr(print_file, '.');
            if (bufptr) {
                *(bufptr + 1) = '\0';
            } else {
                strcat(print_file, ".");
            }
            strcat(print_file, dev.fext);*/
    /// sprintf(print_file,"%s.%s",get_docbname(),dev.fext);

    QString pf1=printfile_item->lenText->text();
    if (!pf1.isEmpty())
    {
//qDebug() << "replace suffix of existing filename";
    replaceSuffix(pf1,QString(dev.fext));
    }
    else
    {
//qDebug() << "generate filename with suffix";
    pf1=get_filename_with_extension(cur_dev);
    //pf1=get_filename_with_extension(device_id);
    }

/*
    QString print_file_with_extension=get_filename_with_extension(device_id);
    strcpy(print_file,print_file_with_extension.toLocal8Bit().constData());
*/
    strcpy(print_file,pf1.toLocal8Bit().constData());

//qDebug() << "pf1=" << pf1;

    printfile_item->lenText->setText(pf1);
    //xv_setstr(printfile_item, print_file);
    xv_setstr(print_string_item, get_print_cmd());

    switch (dev.type) {
    case DEVICE_TERM://for the screen
        grpOutput->setVisible(false);
        break;
    case DEVICE_FILE://output to a file
        grpOutput->setVisible(true);
        SetToggleButtonState(printto_item, true);
        SetSensitive(printto_item, true);
        //SetSensitive(printto_item, false);
        SetSensitive(print_string_item, false);
        //SetSensitive(rc_filesel, true);
        SetSensitive(printfile_item, true);
        SetSensitive(wbut, true);
        break;
    case DEVICE_PRINT://output to a printer
        grpOutput->setVisible(true);
        SetToggleButtonState(printto_item, get_ptofile());
        SetSensitive(printto_item, true);
        if (get_ptofile() == true) {
            //SetSensitive(rc_filesel, true);
            SetSensitive(printfile_item, true);
            SetSensitive(wbut, true);
            SetSensitive(printto_item, true);
            //SetSensitive(printto_item, false);
            SetSensitive(print_string_item, false);
        } else {
            //SetSensitive(rc_filesel, false);
            /// SetSensitive(printfile_item, false);
            SetSensitive(printfile_item, true);
            /// SetSensitive(wbut, false);
            SetSensitive(wbut, true);
            SetSensitive(printto_item, true);
            SetSensitive(print_string_item, true);
        }
        break;
    }

    SetOptionChoice(page_orient_item, pg.width < pg.height ? PAGE_ORIENT_PORTRAIT : PAGE_ORIENT_LANDSCAPE);
    pf = get_page_format(cur_dev);
    //pf = get_page_format(device_id);
    SetOptionChoice(page_format_item, pf);
    if (pf == PAGE_FORMAT_CUSTOM) {
        SetSensitive(page_x_item, true);
        SetSensitive(page_y_item, true);
        SetSensitive(page_orient_item, false);
    } else {
        SetSensitive(page_x_item, false);
        SetSensitive(page_y_item, false);
        SetSensitive(page_orient_item, true);
    }

    sprintf (buf, out_format_int, pg.dpi);
    xv_setstr(dev_res_item, buf);

    page_units = GetOptionChoice(page_size_unit_item);

    switch (page_units) {
    case 0:     /* pixels */
        out_format=out_format_int;
        page_x = (double) pg.width;
        page_y = (double) pg.height;
        break;
    case 1:      /* inches */
        out_format=out_format_float;
        page_x = ((double) pg.width / pg.dpi);
        page_y = ((double) pg.height / pg.dpi);
        break;
    case 2:      /* cm */
        out_format=out_format_float;
        page_x = (CM_PER_INCH * (double)pg.width / pg.dpi);
        page_y = (CM_PER_INCH * (double)pg.height / pg.dpi);
        break;
    default:
        errmsg(tr("Internal error").toLocal8Bit().constData());
        return;
    }

    if (clip_borders_for_output==TRUE)
    chkClipOutput->setChecked(true);
    else
    chkClipOutput->setChecked(false);
    switch (cur_dev)
    {
    case DEVICE_BMP:
    case DEVICE_PNG:
    case DEVICE_JPEG:
    case DEVICE_TIFF:
    chkClipOutput->setVisible(true);
    break;
    default:
    chkClipOutput->setVisible(false);
    break;
    }

    sprintf (buf, out_format, page_x);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(page_x_item, buf);

    sprintf (buf, out_format, page_y);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(page_y_item, buf);

    SetToggleButtonState(fontaa_item, dev.fontaa);
    SetToggleButtonState(devfont_item, dev.devfonts);
    SetToggleButtonState(chkScaleLineWidthByResolution,ScaleLineWidthByResolution);
    SetToggleButtonState(chkUseAntialiasing,general_antialiasing);
//replaceFileNameOnly(QString("nname"));
}

void frmDeviceSetup::OrientationChanged(int value)//change the page orientation
{
    int orientation = value;
    double px, py;
    //float px1,py1;
    int px2,py2;
    char buf[256];
    int page_units = GetOptionChoice(page_size_unit_item);
    int format = page_format_item->currentValue();
    double dpis;
    if (xv_evalexpr(dev_res_item, &dpis) != RETURN_SUCCESS) {
        errmsg(tr("Invalid dpi").toLocal8Bit().constData());
        return;
    }
    if (dpis <= 0.0 && startupphase==0) {
        errmsg(tr("Device resolution(s) <= 0").toLocal8Bit().constData());
        return;
    }
if (format!=PAGE_FORMAT_CUSTOM)
{
    switch (page_units)
    {
    case 0:     /* pixels */
        out_format=out_format_int;
        return_Page_Dimensions_pix(format,orientation,dpis,&px2,&py2);
        px=px2;
        py=py2;
        break;
    case 1:      /* inches */
        out_format=out_format_float;
        return_Page_Dimensions_in(format,orientation,&px,&py);
        /*px=px1;
        py=py1;*/
        break;
    case 2:      /* cm */
        out_format=out_format_float;
        return_Page_Dimensions_cm(format,orientation,&px,&py);
        /*px=px1;
        py=py1;*/
        break;
    default:
        errmsg(tr("Internal error").toLocal8Bit().constData());
        return;
    }
}
else//custom format
{
    if (xv_evalexpr(page_x_item, &px) != RETURN_SUCCESS ||
            xv_evalexpr(page_y_item, &py) != RETURN_SUCCESS ) {
        errmsg(tr("Invalid page dimension(s)").toLocal8Bit().constData());
        return;
    }
}

    if ((orientation == PAGE_ORIENT_LANDSCAPE && px > py) ||
        (orientation == PAGE_ORIENT_PORTRAIT  && px < py) ) {
        sprintf (buf, out_format, px);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_x_item, buf);
        sprintf (buf, out_format, py);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_y_item, buf);
    } else {
        sprintf (buf, out_format, py);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_x_item, buf);
        sprintf (buf, out_format, px);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_y_item, buf);
    }
/*
}
else//not a custom value-->one of the preset-values
{
    sprintf (buf, out_format, py);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(page_x_item, buf);
    sprintf (buf, out_format, px);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(page_y_item, buf);
}
cout << "finished orentation changed" << endl;*/
}

void frmDeviceSetup::SizeChanged(int i_value)//change between Custom,Letter,A4 and so on
{
    int orientation;
    int value=page_format_item->currentValue();
    int x, y;
    double px, py;
    int page_units;
    double dpi;
    char buf[256];
    (void)i_value;
    if (value == PAGE_FORMAT_CUSTOM) {
        SetSensitive(page_x_item, true);
        SetSensitive(page_y_item, true);
        SetSensitive(page_orient_item, false);
        return;
    } else {
        SetSensitive(page_x_item, false);
        SetSensitive(page_y_item, false);
        SetSensitive(page_orient_item, true);
    }
    orientation = GetOptionChoice(page_orient_item);
    return_Page_Dimensions_pix(value,orientation,72.0,&x,&y);
    /*switch (value) {
    case PAGE_FORMAT_USLETTER:
        x = 612;
        y = 792;
        break;
    case PAGE_FORMAT_A4:
        x = 595;
        y = 842;
        break;
    case PAGE_FORMAT_CUSTOM:
    default:
        return;
    }*/
    //x and y are now the sizes in pixels at 72dpi
    page_units = GetOptionChoice(page_size_unit_item);
    switch (page_units) {
    case 0:      /* pixels */
        if (xv_evalexpr(dev_res_item, &dpi) != RETURN_SUCCESS) {
            errmsg(tr("Invalid dpi").toLocal8Bit().constData());
            return;
        }
        if (dpi <= 0.0 && startupphase==0) {
            errmsg(tr("Device resolution(s) <= 0").toLocal8Bit().constData());
            return;
        }
        out_format=out_format_int;
        return_Page_Dimensions_pix(value,orientation,dpi,&x,&y);
        px = x;
        py = y;
        break;
    case 1:      /* inches */
        out_format=out_format_float;
        px = x/72.0;
        py = y/72.0;
        break;
    case 2:      /* cm */
        out_format=out_format_float;
        px = x/72.0*CM_PER_INCH;
        py = y/72.0*CM_PER_INCH;
        break;
    default:
        errmsg(tr("Internal error").toLocal8Bit().constData());
        return;
    }

    /*if ((orientation == PAGE_ORIENT_LANDSCAPE && px > py) ||
            (orientation == PAGE_ORIENT_PORTRAIT  && px < py) ) {*/
        sprintf (buf, out_format, px);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_x_item, buf);
        sprintf (buf, out_format, py);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_y_item, buf);
    /*} else {
        sprintf (buf, "%.2f", py);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_x_item, buf);
        sprintf (buf, "%.2f", px);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_y_item, buf);
    }*/

/*if (i==0)
{
page_orient_item->setEnabled(FALSE);
page_size_unit_item->setEnabled(TRUE);
page_x_item->setEnabled(TRUE);
page_y_item->setEnabled(TRUE);
}
else
{
page_orient_item->setEnabled(TRUE);
page_size_unit_item->setEnabled(FALSE);
page_x_item->setEnabled(FALSE);
page_y_item->setEnabled(FALSE);
}*/
}

void frmDeviceSetup::setLikeDefaultGeometry(UserDeviceGeometry * dg)
{
this->blockSignals(true);
    if (dg->dev_nr>=0)
    {
        int index=-1;
        for (int i=0;i<devices_item->number_of_entries;i++)
        {
            if (!strcmp(devices_item->entries[i].toLocal8Bit().constData(),get_device_name(dg->dev_nr)))
            {
            index=i;
            break;
            }
        }
        if (index>=0)
        devices_item->setCurrentIndex(index);
    }
    if (dg->orientation>=0)
    page_orient_item->setCurrentIndex(dg->orientation);
    if (dg->width>=0)
    page_x_item->setText(QString::number(dg->width,'f',2));
    if (dg->height>=0)
    page_y_item->setText(QString::number(dg->height,'f',2));
    if (dg->unit>=0)
    page_size_unit_item->setCurrentIndex(dg->unit);
    if (dg->dpi>=0)
    dev_res_item->setText(QString::number(dg->dpi,'f',2));
if (dg->Antialiasing>=0)
{
    //0=No Antialiasing
    //1=Font Antialiasing Only
    //2=Graph Antialiaing Only
    //3=Graph and Font Antialiasing
    //-1=no change
        if (dg->Antialiasing==1 || dg->Antialiasing==3)
        fontaa_item->setChecked(true);
        else
        fontaa_item->setChecked(false);
    if (dg->Antialiasing==2 || dg->Antialiasing==3)
    chkUseAntialiasing->setChecked(true);
    else
    chkUseAntialiasing->setChecked(false);
}
    if (dg->ScaleLineWidth>=0)
    {
        if (dg->ScaleLineWidth==0)
        chkScaleLineWidthByResolution->setChecked(false);
        else
        chkScaleLineWidthByResolution->setChecked(true);
    }
    page_format_item->setCurrentIndex(0);
    //qDebug() << "User Default " << curval;
this->blockSignals(false);
}

void frmDeviceSetup::QuickResolutionChange(int val)
{
int curval=NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+val;
//qDebug() << "QuickResolutionChanged=" << curval;
if (val<0)
{
setLikeDefaultGeometry(DefaultUserDeviceGeometry+curval);
}
else
{
setLikeDefaultGeometry(DefaultSystemDeviceGeometry+val);
    if (val==0 || val==1)//Letter
    {
    page_format_item->setCurrentIndex(1);
    }
    else if (val==2 || val==3)//A4
    {
    page_format_item->setCurrentIndex(2);
    }
}
}

void frmDeviceSetup::DimChanged(int i)//change between units for device-dimensions (pixel/inch or cm)
{
char buf[256];
double page_x, page_y;
//float px1,py1;
int px2,py2;
double dev_res;
int page_units = i;//pix,in,cm
int format=page_format_item->currentValue();//Custom / DIN A4 / Letter / and so on...
int orientation = GetOptionChoice(page_orient_item);
    if (xv_evalexpr(dev_res_item, &dev_res) != RETURN_SUCCESS) {
        errmsg(tr("Invalid device resolution").toLocal8Bit().constData());
        return;
    }
    if (dev_res <= 0.0 && startupphase==0) {
        errmsg(tr("Device resolution(s) <= 0").toLocal8Bit().constData());
        return;
    }
    switch (page_units)
    {
    case 0:     /* pixels */
        out_format=out_format_int;
        return_Page_Dimensions_pix(format,orientation,dev_res,&px2,&py2);
        page_x=px2;
        page_y=py2;
        break;
    case 1:      /* inches */
        out_format=out_format_float;
        return_Page_Dimensions_in(format,orientation,&page_x,&page_y);
        /*page_x=px1;
        page_y=py1;*/
        break;
    case 2:      /* cm */
        out_format=out_format_float;
        return_Page_Dimensions_cm(format,orientation,&page_x,&page_y);
        /*page_x=px1;
        page_y=py1;*/
        break;
    default:
        errmsg(tr("Internal error").toLocal8Bit().constData());
        return;
    }
if (format==PAGE_FORMAT_CUSTOM)
{
    if (xv_evalexpr(page_x_item, &page_x) != RETURN_SUCCESS ||
        xv_evalexpr(page_y_item, &page_y) != RETURN_SUCCESS ) {
        errmsg(tr("Invalid page dimension(s)").toLocal8Bit().constData());
        return;
    }
//0=pixel
//1=inch
//2=cm
    if (current_page_units == page_units) {
        ;
    } else if (current_page_units == 0 && page_units == 1) {
        //pixel-->inch
        page_x /= dev_res;
        page_y /= dev_res;
    } else if (current_page_units == 0 && page_units == 2) {
        //pixel-->cm
        page_x /= (dev_res/CM_PER_INCH);
        page_y /= (dev_res/CM_PER_INCH);
    } else if (current_page_units == 1 && page_units == 0) {
        //inch-->pixel
        page_x *= dev_res;
        page_y *= dev_res;
    } else if (current_page_units == 1 && page_units == 2) {
        //inch-->cm
        page_x *= CM_PER_INCH;
        page_y *= CM_PER_INCH;
    } else if (current_page_units == 2 && page_units == 0) {
        //cm-->pixel
        page_x *= (dev_res/CM_PER_INCH);
        page_y *= (dev_res/CM_PER_INCH);
    } else if (current_page_units == 2 && page_units == 1) {
        //cm-->inch
        page_x /= CM_PER_INCH;
        page_y /= CM_PER_INCH;
    } else {
        errmsg(tr("Internal error").toLocal8Bit().constData());
        return;
    }
}
    switch (page_units)
    {
    case 0:     /* pixels */
        out_format=out_format_int;
        break;
    case 1:      /* inches */
    case 2:      /* cm */
        out_format=out_format_float;
        break;
    default:
        errmsg(tr("Internal error").toLocal8Bit().constData());
        return;
    }
    current_page_units = page_units;

    sprintf (buf, out_format, page_x);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(page_x_item, buf);
    sprintf (buf, out_format, page_y);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(page_y_item, buf);
}

void frmDeviceSetup::DpisChanged(void)
{
OrientationChanged(page_orient_item->currentValue());
}

void frmDeviceSetup::changeDeviceList(int version)//this is useful for a change in the usage of libHaru (activate/deactivate it) and other output formats
{
//version=0 --> all
//version=1 --> just screen
//version=2 --> everything except Screen
int old_selection=devices_item->currentValue();
int number=number_of_devices();
QString * entr=new QString[number];
int * i_entr=new int[number];
int index=0;
    for (int i=0;i<number;i++)
    {
        if (((version==0 && isDeviceActive(i)) || (version==1 && i==DEVICE_SCREEN) || (version==2 && i!=DEVICE_SCREEN && isDeviceActive(i))) && (i!=DEVICE_PDF_HARU || (i==DEVICE_PDF_HARU && use_libHaru==TRUE)) )
        {
        entr[index]=get_device_name(i);
        i_entr[index++]=i;
        }
    }
cur_version=version;
disconnect(devices_item->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(DeviceChanged(int)));
devices_item->setNewEntries(index,entr,i_entr);
devices_item->setCurrentValue(old_selection);
connect(devices_item->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(DeviceChanged(int)));
    if (version==1)//just screen
    {
    setWindowTitle(tr("QtGrace: Page setup"));
    devices_item->setVisible(false);
    devices_item->setEnabled(false);
    grpDevSetup->setTitle(tr("Screenshot"));
    actHelpOnDevSetup->setText(tr("On &page setup"));
    }
    else//everything else --> the usual device-setup
    {
    setWindowTitle(tr("QtGrace: File Export Setup"));
    devices_item->setVisible(true);
    devices_item->setEnabled(true);
    grpDevSetup->setTitle(tr("Select output format"));
    actHelpOnDevSetup->setText(tr("On &output formats"));
    }
}

void frmDeviceSetup::doApply(void)
{
    ApplyError=false;
    int seldevice;
    double page_x, page_y;
    double dpi;
    int page_units;
    Device_entry dev;
    Page_geometry pg;
    int do_redraw = FALSE;

    int nr_of_gr=number_of_graphs();
    double old_small,new_small;
    Page_geometry cur_pg=get_page_geometry();
    Page_geometry old_pg=cur_pg;
    old_small=cur_pg.width<cur_pg.height?cur_pg.width:cur_pg.height;

    stdOutputFormat = seldevice = GetOptionChoice(devices_item);
    ScaleLineWidthByResolution=chkScaleLineWidthByResolution->isChecked()?TRUE:FALSE;
    general_antialiasing=chkUseAntialiasing->isChecked()?TRUE:FALSE;

    SaveDeviceState(seldevice,GetToggleButtonState(dsync_item));
    ListOfChanges.clear();
    ListOfOldStates.clear();

    dev = get_device_props(seldevice);

    clip_borders_for_output=(chkClipOutput->isChecked()==true?TRUE:FALSE);

    sprintf(dummy,"@page size %ld, %ld",dev.pg.width,dev.pg.height);
    ListOfOldStates << QString(dummy);

    if (dev.type != DEVICE_TERM)
    {
        hdevice = seldevice;
        set_ptofile(GetToggleButtonState(printto_item));
        //strcpy(print_file, xv_getstr(printfile_item));
        strcpy(print_file,printfile_item->lenText->text().toLocal8Bit().constData());
//qDebug() << "print_file=" << print_file;
//qDebug() << "LineEdit=" << printfile_item->lenText->text();
        if (get_ptofile())
        {
            //strcpy(print_file, xv_getstr(printfile_item));
            set_exportname(print_file);
        }
        else
        {
            set_print_cmd(xv_getstr(print_string_item));
        }

    }

    dev.devfonts = GetToggleButtonState(devfont_item);
    dev.fontaa = GetToggleButtonState(fontaa_item);

    if (xv_evalexpr(page_x_item, &page_x) != RETURN_SUCCESS ||
        xv_evalexpr(page_y_item, &page_y) != RETURN_SUCCESS  )
    {
        errmsg(tr("Invalid page dimension(s)").toLocal8Bit().constData());
        ApplyError=true;
        goto end_dev_setup_apply;
    }

    if (xv_evalexpr(dev_res_item, &dpi) != RETURN_SUCCESS || dpi <= 0.0)
    {
        errmsg(tr("Invalid dpi").toLocal8Bit().constData());
        ApplyError=true;
        goto end_dev_setup_apply;
    }

    page_units = GetOptionChoice(page_size_unit_item);

    switch (page_units) {
    case 0:
        pg.width =  (long) page_x;
        pg.height = (long) page_y;
        break;
    case 1:
        pg.width =  (long) (page_x * dpi);
        pg.height = (long) (page_y * dpi);
        break;
    case 2:
        pg.width =  (long) (page_x * dpi / CM_PER_INCH);
        pg.height = (long) (page_y * dpi / CM_PER_INCH);
        break;
    default:
        errmsg(tr("Internal error").toLocal8Bit().constData());
        ApplyError=true;
        goto end_dev_setup_apply;
    }

    pg.dpi = dpi;

    if (GetToggleButtonState(dsync_item) == TRUE)
    {
    //cout << "doApply" << endl;
    //cout << pg.width << " x " << pg.height << " dpi=" << pg.dpi << endl;
        set_page_dimensions((int) rint(72.0*pg.width/pg.dpi),
                            (int) rint(72.0*pg.height/pg.dpi),
                            GetToggleButtonState(psync_item) == TRUE);
        do_redraw = TRUE;
    }

    dev.pg = pg;
    if (set_device_props(seldevice, dev) != RETURN_SUCCESS)
    {
        errmsg(tr("Invalid page dimensions or DPI").toLocal8Bit().constData());
        ApplyError=true;
        goto end_dev_setup_apply;
    }

    if (seldevice == tdevice)
    {
        do_redraw = TRUE;
    }

    setExportTypeDescription(dev.fext);

    sprintf(dummy,"@page size %ld, %ld",dev.pg.width,dev.pg.height);
    ListOfChanges << QString(dummy);

    //undo-stuff
    DeviceModified(seldevice,GetToggleButtonState(dsync_item));

    cur_pg=get_page_geometry();
    new_small=cur_pg.width<cur_pg.height?cur_pg.width:cur_pg.height;

    if (new_small!=old_small && chkDontChangeSize->isChecked()==true && nr_of_gr>0)//relation between viewport and pixels is changed and the users wants the graphs not to be changed
    {
        int * gnos=new int[nr_of_gr+1];
            for (int i=0;i<nr_of_gr;i++)
            gnos[i]=i;
        SaveGraphStatesPrevious(nr_of_gr,gnos,UNDO_APPEARANCE);//call this before the modification
        for (int i=0;i<nr_of_gr;i++)
        {
            g[i].v.xv1/=new_small/old_small;
            g[i].v.xv2/=new_small/old_small;
            g[i].v.yv1/=new_small/old_small;
            g[i].v.yv2/=new_small/old_small;
            g[i].v.yv1-=((double)old_pg.height-(double)cur_pg.height)/new_small;
            g[i].v.yv2-=((double)old_pg.height-(double)cur_pg.height)/new_small;
        }
        GraphsModified(nr_of_gr,gnos,UNDO_APPEARANCE);//call this after the modification
        addAditionalDescriptionToLastNode(-1,tr("Graph(s) repositioned"),QString());
        delete[] gnos;
    }
/*
    orig_page_w=device_table[0].pg.width;//save original size
    orig_page_h=device_table[0].pg.height;
    device_table[0].pg.width=orig_page_w*GeneralPageZoomFactor;//use Page Zoom
    device_table[0].pg.height=orig_page_h*GeneralPageZoomFactor;
*/
    if (do_redraw)
    {
        set_dirtystate();
        mainWin->mainArea->completeRedraw();
    }
end_dev_setup_apply:
    set_left_footer(NULL);
    ;//end
}

void frmDeviceSetup::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmDeviceSetup::fontGroupToggled(bool t)
{
    if (t==true)//show
    {
        //deltaFonts=this->height()-buttonGroup->y()-buttonGroup->height();
        fontaa_item->setVisible(t);
        devfont_item->setVisible(t);
        //deltaFonts-=this->height()-buttonGroup->y()-buttonGroup->height();
        //qApp->processEvents();
    }
    else//hide
    {
        //deltaFonts=this->height()-buttonGroup->y()-buttonGroup->height();
        fontaa_item->setVisible(t);
        devfont_item->setVisible(t);
        //deltaFonts-=this->height()-buttonGroup->y()-buttonGroup->height();
        //qApp->processEvents();
        //this->update();
        //this->repaint();
        //qApp->processEvents();
        //this->resize(this->width(),this->height()+deltaFonts);
    grpFonts->adjustSize();
    }
this->adjustSize();
}

void frmDeviceSetup::geometryGroupToggled(bool t)
{
    if (t==true)//show
    {
        //deltaGeometry=this->height()-buttonGroup->y()-buttonGroup->height();
        cmdUseScreenResolution->setVisible(true);
        page_orient_item->setVisible(true);
        page_format_item->setVisible(true);
        page_x_item->setVisible(true);
        page_y_item->setVisible(true);
        dev_res_item->setVisible(true);
        page_size_unit_item->setVisible(true);
        chkDontChangeSize->setVisible(true);
        chkScaleLineWidthByResolution->setVisible(true);
        chkUseAntialiasing->setVisible(true);
        //qApp->processEvents();
        //deltaGeometry-=this->height()-buttonGroup->y()-buttonGroup->height();
    }
    else//hide
    {
        //deltaGeometry=this->height()-buttonGroup->y()-buttonGroup->height();
    //qDebug() << "Ausgangspos=" << deltaGeometry;
        cmdUseScreenResolution->setVisible(false);
        page_orient_item->setVisible(false);
        page_format_item->setVisible(false);
        page_x_item->setVisible(false);
        page_y_item->setVisible(false);
        dev_res_item->setVisible(false);
        page_size_unit_item->setVisible(false);
        chkDontChangeSize->setVisible(false);
        chkScaleLineWidthByResolution->setVisible(false);
        chkUseAntialiasing->setVisible(false);
        //qApp->processEvents();
        //this->update();
        //this->repaint();
        //qApp->processEvents();
    //qDebug() << "Nachher=" << this->height()-buttonGroup->y()-buttonGroup->height();
        //deltaGeometry-=this->height()-buttonGroup->y()-buttonGroup->height();
    //qDebug() << "deltaGeomtry=" << deltaGeometry;
    //this->resize(this->width(),this->height()+deltaGeometry);
    }
grpPage->adjustSize();
this->adjustSize();
}

void frmDeviceSetup::doDefaultPageGeometrySetup(void)
{
    if (FormUserDefaultGeometries==NULL)
    {
    FormUserDefaultGeometries=new frmUserDefaultGeometries(this);
    connect(FormUserDefaultGeometries,SIGNAL(newUserDefaults()),this,SLOT(recreateQuickMenu()));
    }
    FormUserDefaultGeometries->init();
    FormUserDefaultGeometries->show();
    FormUserDefaultGeometries->raise();
    FormUserDefaultGeometries->activateWindow();
}

void frmDeviceSetup::doReset(void)
{
    init(devices_item->currentValue());
}

void frmDeviceSetup::recreateQuickMenu(void)
{
    for (int i=0;i<NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES;i++)
    {
    act_quickSel[i]->setText(tr("User Default ") + QString::number(i+1) + QString(": ") + QString::fromLocal8Bit(DefaultUserDeviceGeometry[i].name));
        if (DefaultUserDeviceGeometry[i].active==TRUE)
        act_quickSel[i]->setVisible(true);
        else
        act_quickSel[i]->setVisible(false);
    }
    for (int i=0;i<NR_OF_QUICKSELECTOPTIONS;i++)
    {
        if (DefaultSystemDeviceGeometry[i].active==TRUE)
        act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i]->setVisible(true);
        else
        act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i]->setVisible(false);
    }
    mnuQuickSelect->update();
}

void frmDeviceSetup::closeEvent(QCloseEvent * e)
{
e->accept();
doClose();
}

void frmDeviceSetup::doClose(void)
{
    if (devices_item->number_of_entries>1)
    //{
    lastPrintDevice=devices_item->currentValue();
    /*cout << "closing PageSetup" << endl;
    }
    else
    cout << "closing ScreenSetup" << endl;*/
    showPageSettings=grpPage->isChecked();
    showFontSettings=grpFonts->isChecked();
    hide();
}

void frmDeviceSetup::doPrintToFile(void)
{
static int save_dirty_state=dirtystate;
    doApply();
    if (ApplyError==true) return;
    mainWin->PrintToFile();
dirtystate=save_dirty_state;
update_app_title();
    /*bool old_state=printto_item->isChecked();
    doPrint();
    printto_item->setChecked(old_state);
    printto_item->setEnabled(true);*/
}

void frmDeviceSetup::doPrintToPrinter(void)
{
static int save_dirty_state=dirtystate;
//cout << "doPrintToPrinter" << endl;
    doApply();
if (ApplyError==true) return;
    whoCalledThePrinter=1;
    mainWin->Print();
dirtystate=save_dirty_state;
update_app_title();
    whoCalledThePrinter=0;//reset to default
}

void frmDeviceSetup::doSyncPage(void)
{}

void frmDeviceSetup::doRescalePlot(void)
{}

void frmDeviceSetup::doHelpOnContext(void)
{
    setCursor(QCursor(Qt::WhatsThisCursor));
}

void frmDeviceSetup::doHelpOnDevSetup(void)
{
    HelpCB("doc/UsersGuide.html#print-setup");
}

void frmDeviceSetup::doBrowse(void)
{
QFileInfo qf(printfile_item->lenText->text());
    int seldevice = GetOptionChoice(devices_item);
    Device_entry dev = get_device_props(seldevice);
    QString FileExtension(dev.fext);
    QString absPath=qf.absoluteDir().absolutePath();
    cur_FileName=qf.completeBaseName()+QString(".")+FileExtension;

if (should_open_grace_file_dialog())
{
    if (FormSelectOutputFile==NULL)
    {
        FormSelectOutputFile=new frmIOForm(SELECT_PRINT_FILE,this);
        connect(FormSelectOutputFile,SIGNAL(newFileSelectedForIO(int,QString,bool,bool,bool)),SLOT(IOrequested(int,QString,bool,bool,bool)));
    }
    FileExtension=QString("*.")+FileExtension;
    FormSelectOutputFile->selector->setFilterFromExtern(absPath,FileExtension);

    FormSelectOutputFile->init();
    FormSelectOutputFile->ledSelection->setText(QDir::toNativeSeparators(qf.absoluteFilePath()));

    FormSelectOutputFile->show();
    FormSelectOutputFile->raise();
    FormSelectOutputFile->activateWindow();
}
else
{
    FileExtension=QString(dev.name)+QString(" (")+QString("*.")+FileExtension;
    FileExtension+=QString(");;All files (*)");
mainWin->UseOperatingSystemFileDialog(SELECT_PRINT_FILE,tr("QtGrace: Select print file"),absPath,FileExtension);
}
}

void frmDeviceSetup::IOrequested(int type,QString file,bool exists,bool writeable,bool readable)
{
    (void)type;
    (void)exists;
    (void)writeable;
    (void)readable;
    QString nfile=file;
    nfile.replace(QString("/\\"),QDir::separator());
    QFileInfo qf(nfile);
    if (qf.completeBaseName().isEmpty())
    {
    nfile+=cur_FileName;
    }
    printfile_item->setText(nfile);
    if (FormSelectOutputFile)
    FormSelectOutputFile->hide();
}

void frmDeviceSetup::doDevOpt(void)
{
    int device_id;
    int dev_nr=-1;
    Device_entry dev;
    device_id = GetOptionChoice(devices_item);

    if (device_id==DEVICE_TERM)//special case! Copy to Clipboard!
    {
    /// No reaints needed any more because the MainPixmap never contains focus indicators
        /*
        int save_focus_flag=draw_focus_flag;
        printing_in_file=true;
        if (save_focus_flag==TRUE || getbgfill()==FALSE)
        {
            draw_focus_flag = FALSE;
            mainWin->mainArea->completeRedraw();
        }
        */
        QImage * pixm=new QImage();
        *pixm=MainPixmap->copy();
        qApp->clipboard()->setImage(*pixm);
        delete pixm;
        /*
        printing_in_file=false;
        draw_focus_flag = save_focus_flag;
        if (save_focus_flag==TRUE || getbgfill()==FALSE)
        {
            mainWin->mainArea->completeRedraw();
        }
        */
        QMessageBox::information(this,tr("Information"),tr("Page copied to clipboard."));
        return;
    }

    dev = get_device_props(device_id);
    if (dev.setup == NULL) {
        /* Should never come to here */
        errmsg(tr("No options can be set for this device").toLocal8Bit().constData());
    } else {
        dev_nr=find_dev_nr(dev.name);
        //(dev.setup)();
    }

/*qDebug() << "device_id =" << device_id;
qDebug() << "dev_nr    =" << dev_nr;*/

    switch (dev_nr)
    {
    case DEVICE_PS:
        if (DevOptions[0]==NULL)
        {
            DevOptions[0]=new frmDeviceOptions(DEVICE_PS,this);
        }
        DevOptions[0]->init();
        DevOptions[0]->show();
        DevOptions[0]->raise();
        break;
    case DEVICE_EPS:
        if (DevOptions[1]==NULL)
        {
            DevOptions[1]=new frmDeviceOptions(DEVICE_EPS,this);
        }
        DevOptions[1]->init();
        DevOptions[1]->show();
        DevOptions[1]->raise();
        break;
    case DEVICE_PNM:
        if (DevOptions[2]==NULL)
        {
            DevOptions[2]=new frmDeviceOptions(DEVICE_PNM,this);
        }
        DevOptions[2]->init();
        DevOptions[2]->show();
        DevOptions[2]->raise();
        break;
    case DEVICE_JPEG:
        if (DevOptions[3]==NULL)
        {
            //DevOptions[3]=new frmDeviceOptions(DEVICE_JPEG,this);
            DevOptions[3]=new frmDeviceOptions(DEVICE_BMP,this);
            DevOptions[3]->setWindowTitle(tr("QtGrace: JPEG options"));
            DevOptions[3]->grpBMPoptions->setTitle(tr("JPEG options"));
        }
        DevOptions[3]->init();
        DevOptions[3]->show();
        DevOptions[3]->raise();
        break;
    case DEVICE_PNG:
        if (DevOptions[4]==NULL)
        {
            //DevOptions[4]=new frmDeviceOptions(DEVICE_PNG,this);
            DevOptions[4]=new frmDeviceOptions(DEVICE_BMP,this);
            DevOptions[4]->setWindowTitle(tr("QtGrace: PNG options"));
            DevOptions[4]->grpBMPoptions->setTitle(tr("PNG options"));
        }
        DevOptions[4]->init();
        DevOptions[4]->show();
        DevOptions[4]->raise();
        break;
    case DEVICE_BMP:
        if (DevOptions[5]==NULL)
        {
            DevOptions[5]=new frmDeviceOptions(DEVICE_BMP,this);
        }
        DevOptions[5]->init();
        DevOptions[5]->show();
        DevOptions[5]->raise();
        break;
    case DEVICE_TIFF:
        if (DevOptions[6]==NULL)
        {
            DevOptions[6]=new frmDeviceOptions(DEVICE_TIFF,this);
        }
        DevOptions[6]->init();
        DevOptions[6]->show();
        DevOptions[6]->raise();
        break;
    default:
        ;//Do nothing
        break;
    }
}

void frmDeviceSetup::doUseScreenResolution(void)
{
    #if QT_VERSION >= 0x060000

    #else
dev_res_item->setText(QString::number(QApplication::desktop()->physicalDpiX()));
    #endif
DpisChanged();
}

bool frmDeviceSetup::openNativePrinter(int dev)//returns true, if everything is ok, and returns false, if the user selected cancel
{
/*static char dummy[1024];
bool ret=true;
int ret_val1;*/

curdev = get_device_props(dev);
tmp_dev = get_device_props(DEVICE_SCREEN);

//ofi.open(QString(QString(user_home_dir)+QDir::separator()+QString("Printer_Debug.txt")).toLocal8Bit().constData());

FormProgress->init(QObject::tr("Printing..."),5);
FormProgress->show();
FormProgress->raise();
FormProgress->activateWindow();

int orientation=curdev.pg.height<curdev.pg.width?0:1;
if (stdPrinter!=NULL)//delete stdPrinter
{
delete stdPrinter;
stdPrinter=NULL;
}
if (stdPrinter==NULL)
{
    if (useHDPrinterOutput==TRUE)
    stdPrinter=new QPrinter(QPrinter::HighResolution);//with this setting the Printer returns the maximum (interpolated) resolution possible (just used to limit the resolution if it does not fit the printer)
    else
    stdPrinter=new QPrinter(QPrinter::ScreenResolution);
stdPrinter->setFromTo(1,1);
}
stdPrinter->setColorMode(QPrinter::Color);
if (orientation==0)//landscape
{
    stdPrinter->setPageOrientation(QPageLayout::Landscape);
}
else//Portrait
{
    stdPrinter->setPageOrientation(QPageLayout::Portrait);
}

//ofi << "Vor Print Dialog " << endl;

/*
#ifdef WINDOWS_SYSTEM
//stdPrinter->setOutputFileName(QString());//on Windows it is often counterproductive to preset the filename - sometimes the printer-dialog is bloked because Windows thinks output to a file is wanted
//stdPrinter->setOutputToFile(false);
#else
stdPrinter->setOutputFileName(FormDeviceSetup->printfile_item->text());
#endif
*/
stdPrinter->setOutputFormat(QPrinter::NativeFormat);
//stdPrinter->setResolution(curdev.pg.dpi);
stdPrinter->setResolution(typicalPrinterResolution);
//QPrintDialog * printDialog=new QPrintDialog(mainWin);

if (printDialog!=NULL)
{
delete printDialog;
printDialog=NULL;
}

printDialog=new QPrintDialog(stdPrinter,mainWin);

if (printDialog==NULL)
{
errmsg(tr("Unable to open native printer dialog.").toLocal8Bit().constData());
return false;
}

/*
//printDialog->open(,SLOT(tryPrintingOnPrinter));
QTime st1;
st1.start();
ret_val1=printDialog->exec();
int millisec=st1.restart();
if (millisec<500) ret_val1=printDialog->exec();
*/

printDialog->setModal(true);

/*connect(printDialog,SIGNAL(accepted(QPrinter *)),SLOT(printerAccepted(QPrinter *)));
connect(printDialog,SIGNAL(rejected()),SLOT(printerRejected()));*/
qApp->processEvents();

/*ofi << "nach new PrintDialog" << endl;
cout << "nach new PrintDialog" << endl;*/

if (printDialog->exec() == QDialog::Accepted)
printerAccepted(stdPrinter);
else
printerRejected();

/*
if (printDialog!=NULL)
{
    cout << "vor show" << endl;
printDialog->show();
cout << "nach show" << endl;
printDialog->raise();
printDialog->activateWindow();
}*/

qApp->processEvents();
//printDialog->open(this,SLOT(printerAccepted(QPrinter*)));

return true;
}

void frmDeviceSetup::printerAccepted(QPrinter * pri)
{
    (void)pri;
    if (printDialog==NULL) return;
/*ofi << "in PrintDialog - accepted" << endl;
cout << "in PrintDialog - accepted" << endl;*/
/*
delete stdPrinter;
stdPrinter=printDialog->printer();
QPrinterInfo pinf(*stdPrinter);
cout << "Printer selected:" << pinf.printerName().constData() << endl;
*/
FormProgress->show();
FormProgress->raise();
FormProgress->activateWindow();
    if (printDialog->printer()->isValid())
    {
/*ofi << "Paper=" << printDialog->printer()->paperRect().width() << "x" << printDialog->printer()->paperRect().height() << endl;
ofi << "Page =" << printDialog->printer()->pageRect().width() << "x" << printDialog->printer()->pageRect().height() << endl;
ofi << "printing on selected Printer: Name=\"" << printDialog->printer()->printerName().toLatin1().constData() << "\"" << endl;*/

/*         QList<int> resols=stdPrinter->supportedResolutions();
cout << "Supported resolutions:" << endl;
        for (int k=0;k<resols.length();k++)
        {
            cout << resols.at(k) << " dpi" << endl;
        }
        cout << "---" << endl;*/
int savScaleLineWidthByResolution=ScaleLineWidthByResolution;
    curdev = get_device_props(DEVICE_SCREEN);
    /*curdev.pg.width=stdPrinter->pageRect().width();
    curdev.pg.height=stdPrinter->pageRect().height();
    curdev.pg.dpi=stdPrinter->resolution();
    set_device_props(DEVICE_SCREEN,curdev);*/
/// cout << "dpi=" << cur_dev.pg.dpi << endl;
/// cout << "Page=" << cur_dev.pg.width << " x " << cur_dev.pg.height << endl;
/// QSizeF ps123=stdPrinter->paperSize(QPrinter::Millimeter);
/// qDebug() << "PaperSize(mm)         = " << ps123.width() << " x " << ps123.height();
/// ps123=stdPrinter->paperSize(QPrinter::Point);
/// qDebug() << "PaperSize(points)     = " << ps123.width() << " x " << ps123.height();
/// ps123=stdPrinter->paperSize(QPrinter::DevicePixel);
/// qDebug() << "PaperSize(dev_pixels) = " << ps123.width() << " x " << ps123.height();
QRectF ps321=stdPrinter->pageRect(QPrinter::Inch);
//qDebug() << "PaperSize(inch)       = " << ps321.width() << " x " << ps321.height();
/// qDebug() << "Resolution = " << stdPrinter->resolution() << " dpi";
//qDebug() << "curdev = " << curdev.pg.width << " x " << curdev.pg.height;
        //delete stdPrinter;
        //stdPrinter=printDialog->printer();
        //GeneralPainter->begin(printDialog->printer());
        //stdPrinter->setResolution(cur_dev.pg.dpi);
        //printDialog->printer()->setResolution(cur_dev.pg.dpi);
        /*if (orientation==0)//landscape
        {
            stdPrinter->setOrientation(QPrinter::Landscape);
        }
        else//Portrait
        {
            stdPrinter->setOrientation(QPrinter::Portrait);
        }*/
curdev.pg.dpi=typicalPrinterResolution;
stdPrinter->setResolution(curdev.pg.dpi);
//we know the size on screen, but we need to know the size that fits on the page (keeping the aspect ratio)
double width_to_height=(curdev.pg.width*1.0)/(curdev.pg.height*1.0);
double page_width_to_height=ps321.width()/ps321.height();

if (whoCalledThePrinter==0)
{
/// who called the printer:
/// 0=from Main Menu
ScaleLineWidthByResolution=TRUE;
if ((width_to_height<=1.0 && page_width_to_height>1.0) || (width_to_height>=1.0 && page_width_to_height<1.0))
{
//qDebug() << "Printer orientation does not match the Page orientation";
    if (stdPrinter->pageLayout().orientation()==QPageLayout::Portrait)
    {
    stdPrinter->setPageOrientation(QPageLayout::Landscape);
    }
    else
    {
    stdPrinter->setPageOrientation(QPageLayout::Portrait);
    }
ps321=stdPrinter->pageRect(QPrinter::Inch);
page_width_to_height=ps321.width()/ps321.height();
//qDebug() << "Orientation Changed";
//qDebug() << "PaperSize(inch)       = " << ps321.width() << " x " << ps321.height();
}
    if (page_width_to_height<=width_to_height)
    {
    curdev.pg.width=ps321.width()*curdev.pg.dpi;
    curdev.pg.height=curdev.pg.width/width_to_height;
    }
    else
    {
    curdev.pg.height=ps321.height()*curdev.pg.dpi;
    curdev.pg.width=curdev.pg.height*width_to_height;
    }
}
else
{
/// who called the printer:
/// 1=FileExortSetup-Dialog
curdev.pg.dpi=dev_res_item->getIntValue();
curdev.pg.height=page_y_item->getIntValue();
curdev.pg.width=page_x_item->getIntValue();
}

set_device_props(DEVICE_SCREEN,curdev);

/*ofi << "valid PrintDialog - start printing" << endl;
cout << "valid PrintDialog - start printing" << endl;*/

    FormProgress->increase();
        print_target=PRINT_TARGET_PRINTER;
        useQPrinter=true;
        int sav_stop_setting=stop_repaint;
        stop_repaint=FALSE;
        xdrawgraph();/// for debugging: deactivate this to inhibit the actual printing
    FormProgress->increase();
        GeneralPainter->end();/// and this

    ScaleLineWidthByResolution=savScaleLineWidthByResolution;
set_device_props(DEVICE_SCREEN,tmp_dev);

/*ofi << "valid PrintDialog - stop printing" << endl;
cout << "valid PrintDialog - stop printing" << endl;*/

        print_target=PRINT_TARGET_SCREEN;
        useQPrinter=false;
        xdrawgraph();
    FormProgress->increase();
        GeneralPainter->end();
        stdPrinter=NULL;
        stop_repaint=sav_stop_setting;

/*ofi << "valid PrintDialog - repaint screen" << endl;
cout << "valid PrintDialog - repaint screen" << endl;*/

    }
    else//Invalid Printer!?
    {
//ofi << "Invalid PrintDialog" << endl;
        if (stdPrinter->outputFileName().isEmpty() || stdPrinter->outputFileName().isNull())
            strcpy(dummy,QString(QString(qt_grace_share_dir) +QDir::separator()+ QString("QtGracePdfOutput.pdf")).toLocal8Bit());
        else
            strcpy(dummy,stdPrinter->outputFileName().toLocal8Bit());

        QSizeF size(MainPixmap->width()*1.0,MainPixmap->height()*1.0);
#if QT_VERSION >= 0x060000
        size=QSizeF(MainPixmap->width()*72.0,MainPixmap->height()*72.0);
        stdPrinter->setPageSize(QPageSize(size,QPageSize::Point));
        stdPrinter->setPageMargins(QMarginsF(0.0,0.0,0.0,0.0),QPageLayout::Point);
#else
        stdPrinter->setPaperSize(size,QPrinter::DevicePixel);
        stdPrinter->setPageMargins(0.0,0.0,0.0,0.0,QPrinter::DevicePixel);
#endif

        stdPrinter->setResolution(72);

        if (stdPrinter->outputFormat()!=QPrinter::PdfFormat)
        {
            stdPrinter->setOutputFormat(QPrinter::PdfFormat);
        }
        if (stdPrinter->outputFileName().isEmpty() || stdPrinter->outputFileName().isNull())
        {
            stdPrinter->setOutputFileName(dummy);
        }
        errwin(QObject::tr("Invalid Printer selected. Output redirected to:").toLocal8Bit());
        errwin(dummy);
/// print_target=PRINT_TARGET_FILE;
        /*useQPrinter=true;
        xdrawgraph();
    print_target=PRINT_TARGET_SCREEN;
        useQPrinter=false;
        xdrawgraph();*/
    FormProgress->progress->setMaximum(FormProgress->progress->maximum()+3);
    FormProgress->increase();
        int save_hdevice=hdevice;
        char * sav_print_file=new char[2+strlen(print_file)];
        strcpy(sav_print_file,print_file);
        strcpy(print_file,dummy);

        hdevice=DEVICE_PDF_HARU;
        int save_dirty_state=dirtystate;
            set_ptofile(true);
            printing_in_file=true;
        do_hardcopy();
    FormProgress->increase();
            printing_in_file=false;
            print_target=PRINT_TARGET_SCREEN;
            mainWin->mainArea->completeRedraw();
        dirtystate=save_dirty_state;
            update_app_title();
        hdevice=save_hdevice;

        strcpy(print_file,sav_print_file);
        delete[] sav_print_file;
    FormProgress->increase();
    }
    this->disconnect(printDialog,SIGNAL(accepted(QPrinter*)));//SLOT(printerAccepted()));
    this->disconnect(printDialog,SIGNAL(rejected()));// SLOT(printerRejected()));
//cout << "ende Accepted A" << endl;
//ofi.close();
    FormProgress->hide();
//cout << "ende Accepted B" << endl;
    printDialog->hide();
//cout << "ende Accepted C" << endl;
    delete printDialog;
    printDialog=NULL;
//cout << "ende Accepted D" << endl;
    useQPrinter=false;
}

void frmDeviceSetup::printerRejected(void)
{
//ret=false;
    if (printDialog==NULL) return;
//cout << "ende Rejected A" << endl;
    this->disconnect(printDialog,SIGNAL(accepted(QPrinter*)));//SLOT(printerAccepted()));
    this->disconnect(printDialog,SIGNAL(rejected()));// SLOT(printerRejected()));
//ofi.close();
    FormProgress->hide();
    printDialog->hide();
    delete printDialog;
    printDialog=NULL;
    useQPrinter=false;
//cout << "ende Rejected B" << endl;
}

void frmDeviceSetup::dpiInputChanged(QString text)
{
if (text.isEmpty()) return;
int ok;
double dpi_number;//=text.toInt(&ok);
ok=xv_evalexpr(dev_res_item, &dpi_number);
if (ok==RETURN_FAILURE || page_format_item->currentValue()==PAGE_FORMAT_CUSTOM) return;
OrientationChanged(page_orient_item->currentValue());
//cout << "DPI: Text=\"" << text.toLocal8Bit().constData() << "\" umgewandelt=" << dpi_number <<  endl;
}

void frmDeviceSetup::tryPrintingOnPrinter(QPrinter * printer)
{
(void)printer;
}

void frmDeviceSetup::doNativePrinterDialog(void)
{
    //cout << "doNativePrinterDialog" << endl;
this->hide();
    if (openNativePrinter(devices_item->currentValue())==false)//only show the setup-dialog again, if the user selected cancel
    this->show();
}

void frmDeviceSetup::replaceFileNameOnly(QString nname)
{
QString oldName;
QString newName;
oldName=printfile_item->lenText->text();
//cout << "oldName=#" << oldName.toLocal8Bit().constData() << "#" << endl;
QFileInfo fi2(oldName);
newName=fi2.absolutePath();
//cout << "absPath=#" << newName.toLocal8Bit().constData() << "#" << endl;
newName+=QDir::separator()+nname;
    if (!fi2.completeSuffix().isEmpty())
    newName+=QString(".")+fi2.completeSuffix();
//cout << "newName=#" << newName.toLocal8Bit().constData() << "#" << endl;
printfile_item->lenText->setText(newName);
}

tabLinestyles::tabLinestyles(QWidget * parent):QWidget(parent)
{
int nr=4;
QString * entries=new QString[nr];
entries[0]=tr("Current");
entries[1]=tr("from project file");
entries[2]=tr("from ini file");
entries[3]=tr("Grace default");
selShowLinestyles=new StdSelector(this,tr("Show linestyles:"),nr,entries);
connect(selShowLinestyles->cmbSelect,SIGNAL(activated(int)),SLOT(show_style_changed(int)));
delete[] entries;

cur_line_len=0;
cur_line_pattern=NULL;
cur_line_pm=NULL;
cur_line_ic=NULL;
cur_line_pendash=NULL;

cur_list_len=nr_of_current_linestyles;
cur_list_entries_length=new int[cur_list_len];
cur_list_patterns=new char*[cur_list_len];
cur_list_LineIcons=new QIcon*[cur_list_len];
cur_list_LinePixmaps=new QPixmap*[cur_list_len];
cur_list_PenDashPattern=new QVector<qreal>*[cur_list_len];

for (int i=0;i<cur_list_len;i++)
{
cur_list_entries_length[i]=lenghts_of_linestyle_patterns[i];
cur_list_patterns[i]=new char[cur_list_entries_length[i]];
memcpy(cur_list_patterns[i],current_linestyle_patterns[i],sizeof(char)*cur_list_entries_length[i]);
cur_list_LineIcons[i]=NULL;
cur_list_LinePixmaps[i]=NULL;
cur_list_PenDashPattern[i]=NULL;
create_one_line_pattern(cur_list_entries_length[i],cur_list_patterns[i],cur_list_LinePixmaps+i,cur_list_LineIcons+i,cur_list_PenDashPattern+i);
}

selStyles=new LineStyleSelector(this);//at this stage the LineStyleSelector has the same entries as is currently set as standard for QtGrace
empty=new QWidget(this);
hbox=new QHBoxLayout();
//hbox->setMargin(0);
hbox->setContentsMargins(0,0,0,0);
hbox->setSpacing(0);
nr_of_panels=20;
panels=new Panel*[nr_of_panels];

pmExample=new QPixmap(320,100);
pmExample->fill();
whitepanel=new QPixmap(35,35);
whitepanel->fill(Qt::white);
blackpanel=new QPixmap(35,35);
blackpanel->fill(Qt::black);
#if QT_VERSION >= 0x050000

#else
mapper=new QSignalMapper(this);
#endif
    for (int i=0;i<nr_of_panels;i+=2)
    {
    panels[i]=new Panel(blackpanel,this,true);
    panels[i+1]=new Panel(whitepanel,this,true);
    hbox->addWidget(panels[i]);
    hbox->addWidget(panels[i+1]);
#if QT_VERSION >= 0x050000
    connect(panels[i],&Panel::mouseClicked,this,[this,i](){this->panel_clicked(i);});
    connect(panels[i+1],&Panel::mouseClicked,this,[this,i](){this->panel_clicked(i+1);});
#else
    connect(panels[i], SIGNAL(mouseClicked()), mapper, SLOT(map()));
    mapper->setMapping(panels[i],i);
    connect(panels[i+1], SIGNAL(mouseClicked()), mapper, SLOT(map()));
    mapper->setMapping(panels[i+1],i+1);
#endif
    }
#if QT_VERSION < 0x050000
connect(mapper,SIGNAL(mapped(int)),this,SLOT(panel_clicked(int)));
#endif
lblExample=new QLabel(QString(""),this);
lblExample->setPixmap(*pmExample);

selLen=new stdIntSelector(this,tr("Length:"),1,100);
selPos=new stdIntSelector(this,tr("Position:"),0,nr_of_current_linestyles-1);
layout=new QGridLayout();
//layout->setMargin(STD_MARGIN);
layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
layout->setSpacing(STD_SPACING);
buttons=new stdButtonGroup(this,true,true,false);

cmdEdit=new QPushButton(tr("Edit"),this);
cmdAppend=new QPushButton(tr("Append"),this);
cmdInsert=new QPushButton(tr("Insert"),this);
cmdDelete=new QPushButton(tr("Delete"),this);
cmdUp=new QPushButton(tr("Up"),this);
cmdDown=new QPushButton(tr("Down"),this);

cmdUseAsCurrent=new QPushButton(tr("Use these linestyles as current"),this);
cmdUseForIni=new QPushButton(tr("Use these linestyles as current and general defaults"),this);

connect(cmdEdit,SIGNAL(clicked()),SLOT(doEdit()));
connect(cmdAppend,SIGNAL(clicked()),SLOT(doAppend()));
connect(cmdInsert,SIGNAL(clicked()),SLOT(doInsert()));
connect(cmdDelete,SIGNAL(clicked()),SLOT(doDelete()));

connect(cmdUp,SIGNAL(clicked()),SLOT(doUp()));
connect(cmdDown,SIGNAL(clicked()),SLOT(doDown()));
connect(cmdUseAsCurrent,SIGNAL(clicked()),SLOT(doUseAsCurrent()));
connect(cmdUseForIni,SIGNAL(clicked()),SLOT(doUseForIni()));

connect(buttons->cmdApply,SIGNAL(clicked()),SLOT(doApply()));
connect(buttons->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
connect(buttons->cmdClose,SIGNAL(clicked()),SLOT(doClose()));

connect(selLen,SIGNAL(currentValueChanged(int)),SLOT(currentLengthChanged(int)));

empty->setLayout(hbox);

selShowLinestyles->setToolTip(tr("Select which set of linestyles is to be displayed here"));
selStyles->setToolTip(tr("Select the linestyle to be edited"));
lblExample->setToolTip(tr("Examples of how the currently selected linestyle looks like"));
selLen->setToolTip(tr("Edit the number of black/white tiles that define the linestyle"));
selPos->setToolTip(tr("Edit the linestyle at this position in the list\nWarning: Pressing Edit will overwrite the linestyle in this position!"));
cmdEdit->setToolTip(tr("Take the black and white patterns and generate a linestyle at the currently selected position (overwriting the existing one)"));
cmdAppend->setToolTip(tr("Append a new linestyle at the end of the list"));
cmdInsert->setToolTip(tr("Insert a new linestyle at the currently selected position in the list (move the other ones down)"));
cmdDelete->setToolTip(tr("Delete the linestyle at the current position from the list"));
cmdUp->setToolTip(tr("Swap the position of the currently selected linestyle with the one above it"));
cmdDown->setToolTip(tr("Swap the position of the currently selected linestyle with the one below it"));
cmdUseAsCurrent->setToolTip(tr("Use the set of linestyles that is currently displayed as the standard for the current project."));
cmdUseForIni->setToolTip(tr("Use the set of linestyles that is currently displayed as the default set of linestyles for the current project and store it in the ini-file"));

int line=0;
int col=0;

layout->addWidget(selShowLinestyles,line++,0,1,4);

layout->addWidget(selStyles,line++,col,1,4);
connect(selStyles,SIGNAL(currentIndexChanged(int)),SLOT(currentStyleChanged(int)));
layout->addWidget(selPos,line++,col,1,4);
layout->addWidget(selLen,line++,col,1,4);
layout->addWidget(empty,line++,col,1,4);

layout->addWidget(cmdEdit,line,0,1,1);
layout->addWidget(cmdInsert,line,1,1,1);
layout->addWidget(cmdAppend,line,2,1,1);
layout->addWidget(cmdDelete,line++,3,1,1);

layout->addWidget(cmdUp,line,0,1,2);
layout->addWidget(cmdDown,line++,2,1,2);

layout->addWidget(lblExample,line++,col,1,4);

layout->addWidget(cmdUseAsCurrent,line,0,1,2);
layout->addWidget(cmdUseForIni,line++,2,1,2);

layout->addWidget(new QWidget(this),line++,col,1,4);
layout->setRowStretch(line-1,3);

layout->addWidget(buttons,line++,col,1,4);
setLayout(layout);

generate_Pattern();
currentStyleChanged(1);
}

void tabLinestyles::init(void)
{
selStyles->setCurrentIndex(1);
}

void tabLinestyles::doApply(void)
{
//cout << "Apply" << endl;
setCurrentListForAll();
}

void tabLinestyles::doAccept(void)
{
ApplyError=false;
doApply();
    if (ApplyError==false)
    doClose();
}

void tabLinestyles::doClose(void)
{
    emit(close_wish());
    //hide();
}

void tabLinestyles::doAppend(void)
{
doSingularAppend();
refillLineStyleSelector();
//reinit
}

void tabLinestyles::doSingularAppend(void)
{
//cout << "doAppend" << endl;
int * dummy=new int[cur_list_len+1];
memcpy(dummy,cur_list_entries_length,sizeof(int)*cur_list_len);
dummy[cur_list_len]=cur_line_len;
delete[] cur_list_entries_length;
cur_list_entries_length=dummy;
char ** dummy2=new char*[cur_list_len+1];
memcpy(dummy2,cur_list_patterns,sizeof(char*)*cur_list_len);
dummy2[cur_list_len]=new char[cur_line_len];
memcpy(dummy2[cur_list_len],cur_line_pattern,sizeof(char)*cur_line_len);
delete[] cur_list_patterns;
cur_list_patterns=dummy2;
QIcon ** dummy3=new QIcon*[cur_list_len+1];
memcpy(dummy3,cur_list_LineIcons,sizeof(QIcon*)*cur_list_len);
dummy3[cur_list_len]=NULL;
delete[] cur_list_LineIcons;
cur_list_LineIcons=dummy3;
QPixmap ** dummy4=new QPixmap*[cur_list_len+1];
memcpy(dummy4,cur_list_LinePixmaps,sizeof(QPixmap*)*cur_list_len);
dummy4[cur_list_len]=NULL;
delete[] cur_list_LinePixmaps;
cur_list_LinePixmaps=dummy4;
QVector<qreal> ** dummy5=new QVector<qreal>*[cur_list_len+1];
memcpy(dummy5,cur_list_PenDashPattern,sizeof(QVector<qreal>*)*cur_list_len);
dummy5[cur_list_len]=NULL;
delete[] cur_list_PenDashPattern;
cur_list_PenDashPattern=dummy5;

create_one_line_pattern(cur_list_entries_length[cur_list_len],cur_list_patterns[cur_list_len],cur_list_LinePixmaps+cur_list_len,cur_list_LineIcons+cur_list_len,cur_list_PenDashPattern+cur_list_len);

cur_list_len++;
}

void tabLinestyles::doInsert(void)
{
int nr_to_edit=selPos->value();
//cout << "doInsert " << nr_to_edit << endl;
doSingularAppend();//first we append --> then we move the last entry upwards
for (int i=cur_list_len-1;i>nr_to_edit;i--)
{
doSwap(i,i-1);
}
for (int i=0;i<cur_list_len;i++)
{
delete cur_list_LinePixmaps[i];
cur_list_LinePixmaps[i]=NULL;
delete cur_list_LineIcons[i];
cur_list_LineIcons[i]=NULL;
delete cur_list_PenDashPattern[i];
cur_list_PenDashPattern[i]=NULL;
create_one_line_pattern(cur_list_entries_length[i],cur_list_patterns[i],cur_list_LinePixmaps+i,cur_list_LineIcons+i,cur_list_PenDashPattern+i);
}
refillLineStyleSelector();
//reinit
}

void tabLinestyles::doEdit(void)
{
int nr_to_edit=selPos->value();
//cout << "doEdit " << nr_to_edit << endl;
if (nr_to_edit>=cur_list_len)
{
doAppend();
return;
}
else if (nr_to_edit<=1)
{
errmsg(QObject::tr("Linestyles 0 and 1 are not editable!").toLocal8Bit().constData());
return;
}
//just replace one line-style
delete[] cur_list_patterns[nr_to_edit];
cur_list_entries_length[nr_to_edit]=cur_line_len;
cur_list_patterns[nr_to_edit]=new char[cur_line_len];
memcpy(cur_list_patterns[nr_to_edit],cur_line_pattern,sizeof(char)*cur_line_len);
create_one_line_pattern(cur_list_entries_length[nr_to_edit],cur_list_patterns[nr_to_edit],cur_list_LinePixmaps+nr_to_edit,cur_list_LineIcons+nr_to_edit,cur_list_PenDashPattern+nr_to_edit);
refillLineStyleSelector();
//reinit
}

void tabLinestyles::doDelete(void)
{
int nr_to_edit=selPos->value();
char dummy[48];
sprintf(dummy,"%d",nr_to_edit);
if (nr_to_edit<2 || nr_to_edit>=cur_list_len)
{
QMessageBox::information(this,tr("Warning"),tr("Unable to delete LineStyle ")+QString(dummy));
return;
}
int ret=QMessageBox::question(this,tr("Delete linestyle"),tr("Really delete linestyle nr ")+QString(dummy),QMessageBox::Yes | QMessageBox::Abort,QMessageBox::Abort);
if (ret==QMessageBox::Yes)
{
//cout << "deleting " << nr_to_edit << endl;
    delete[] cur_list_patterns[nr_to_edit];
    delete cur_list_LineIcons[nr_to_edit];
    delete cur_list_LinePixmaps[nr_to_edit];
    delete cur_list_PenDashPattern[nr_to_edit];
    for (int i=nr_to_edit;i<cur_list_len-1;i++)
    {
    cur_list_patterns[i]=cur_list_patterns[i+1];
    cur_list_entries_length[i]=cur_list_entries_length[i+1];
    cur_list_LineIcons[i]=cur_list_LineIcons[i+1];
    cur_list_LinePixmaps[i]=cur_list_LinePixmaps[i+1];
    cur_list_PenDashPattern[i]=cur_list_PenDashPattern[i+1];
    }
cur_list_len--;
refillLineStyleSelector();
//reinit
}
}

void tabLinestyles::doUseAsCurrent(void)
{//Use the settings currently shown as the Current LineStyles
int ret=QMessageBox::question(this,tr("Change current Linestyles"),tr("Use the currently shown linestyle(s) as current linestyles?"),QMessageBox::Yes | QMessageBox::No);
    if (ret==QMessageBox::No) return;
copy_line_style_patterns_to_current(cur_list_len,cur_list_entries_length,cur_list_patterns);
selShowLinestyles->setCurrentIndex(0);
selStyles->setCurrentIndex(1);
}

void tabLinestyles::doUseForIni(void)
{//Use the settings currently shown for the Ini-File
int ret=QMessageBox::question(this,tr("Change current Linestyles"),tr("Use the currently shown linestyle(s) as default linestyles?"),QMessageBox::Yes | QMessageBox::No);
    if (ret==QMessageBox::No) return;
copy_line_style_patterns_to_target(cur_list_len,cur_list_entries_length,cur_list_patterns,3);
selShowLinestyles->setCurrentIndex(2);
selStyles->setCurrentIndex(1);
}

void tabLinestyles::doSwap(int a,int b)
{
static int i_tmp;
static char * c_tmp;
static QIcon * ic_tmp;
static QPixmap * pm_tmp;
static QVector<qreal> * ve_tmp;
i_tmp=cur_list_entries_length[a];
cur_list_entries_length[a]=cur_list_entries_length[b];
cur_list_entries_length[b]=i_tmp;
c_tmp=cur_list_patterns[a];
cur_list_patterns[a]=cur_list_patterns[b];
cur_list_patterns[b]=c_tmp;
ic_tmp=cur_list_LineIcons[a];
cur_list_LineIcons[a]=cur_list_LineIcons[b];
cur_list_LineIcons[b]=ic_tmp;
pm_tmp=cur_list_LinePixmaps[a];
cur_list_LinePixmaps[a]=cur_list_LinePixmaps[b];
cur_list_LinePixmaps[b]=pm_tmp;
ve_tmp=cur_list_PenDashPattern[a];
cur_list_PenDashPattern[a]=cur_list_PenDashPattern[b];
cur_list_PenDashPattern[b]=ve_tmp;
}

void tabLinestyles::doUp(void)
{
//cout << "doUp" << endl;
int nr_to_edit=selPos->value();
char dummy[48];
sprintf(dummy,"%d",nr_to_edit);
if (nr_to_edit<3)
{
QMessageBox::warning(this,tr("Error"),tr("Unable to move LineStyle ") + QString(dummy)+tr(" up."));
return;
}
doSwap(nr_to_edit,nr_to_edit-1);
refillLineStyleSelector();
//reinit
}

void tabLinestyles::doDown(void)
{
//cout << "doDown" << endl;
int nr_to_edit=selPos->value();
char dummy[48];
sprintf(dummy,"%d",nr_to_edit);
if (nr_to_edit<2 || nr_to_edit>=cur_list_len-1)
{
QMessageBox::warning(this,tr("Error"),tr("Unable to move LineStyle ") + QString(dummy)+tr(" down."));
return;
}
doSwap(nr_to_edit,nr_to_edit+1);
refillLineStyleSelector();
//reinit
}

void tabLinestyles::setCurrentListForAll(void)
{
QString ques;
ApplyError=false;
switch (selShowLinestyles->currentIndex())
{
case 0://current
ques=tr("Do you really want to set the currently set linestyle(s) as standard for QtGrace?\nThis setting will only effect the current project.") ;
break;
case 1://file
ques=tr("Do you really want to change the saved linestyle settings read from the project file?\nAltering these linestyles has no real effect. When a project file is saved, the current linestyles are stored in the file.");
break;
case 2://ini
ques=tr("Do you really want to change the default linestyles store in the ini-file?\nThese linestyles will be used if the linestyle(s) are not stored in the project file.");
break;
case 3://Grace-Std.
ques=tr("The default Grace linestyles can not be changed!\nThese linestyles are listed here in order to be able to reset other linestyle settings.");
QMessageBox::information(this,tr("Unable to change defaults"),ques);
ApplyError=true;
break;
}
int ret;
if (selShowLinestyles->currentIndex()!=3)
{
ret=QMessageBox::question(this,tr("Set linestyle for QtGrace"),ques,QMessageBox::Yes | QMessageBox::Abort,QMessageBox::Abort);
    if (ret==QMessageBox::Yes)
    {
        if (selShowLinestyles->currentIndex()==0)//current
        {
        copy_line_style_patterns_to_current(cur_list_len,cur_list_entries_length,cur_list_patterns);
        mainWin->mainArea->completeRedraw();
        }
        else if (selShowLinestyles->currentIndex()==1)//file
        {
        copy_line_style_patterns_to_target(cur_list_len,cur_list_entries_length,cur_list_patterns,2);
        }
        else if (selShowLinestyles->currentIndex()==2)//ini
        {
        copy_line_style_patterns_to_target(cur_list_len,cur_list_entries_length,cur_list_patterns,3);
        }
    }
    else
    {
    ApplyError=true;
    }
}
}

void tabLinestyles::setPanelsToOnePattern(int len,char * pat,int pan_count)
{
    for (int i=0;i<nr_of_panels;i++)
    {
    delete panels[i];
    }
    delete[] panels;
panels=new Panel*[pan_count];
int index=0;

    for (int i=0;i<len;i++)
    {
        for (int j=0;j<((int)pat[i]);j++)
        {
            if (i%2==0)
            panels[index]=new Panel(blackpanel,this,true);
            else
            panels[index]=new Panel(whitepanel,this,true);
        panels[index]->setFrameShape(QFrame::Panel);
        panels[index]->setFrameStyle(QFrame::Raised | QFrame::WinPanel);
        panels[index]->setToolTip(tr("Press here to toggle between a black or white segment"));
        if (selShowLinestyles->currentIndex()==3) panels[index]->setEnabled(false);
        hbox->addWidget(panels[index]);
#if QT_VERSION >= 0x050000
        connect(panels[index],&Panel::mouseClicked,this,[this,index](){this->panel_clicked(index);});
#else
        connect(panels[index], SIGNAL(mouseClicked()), mapper, SLOT(map()));
        mapper->setMapping(panels[index],index);
#endif
        index++;
        }
    }
nr_of_panels=index;
}

int pattern_length(int len,char * pat)
{
int leng=0;
    for (int i=0;i<len;i++)
    {
    leng+=pat[i];
    }
return leng;
}

void tabLinestyles::show_style_changed(int nr)
{
int * source_list_len=NULL;
int ** source_list_entry_lengths=NULL;
char *** source_list_patterns=NULL;
switch (nr)
{
case 0://current
source_list_len=&nr_of_current_linestyles;
source_list_entry_lengths=&lenghts_of_linestyle_patterns;
source_list_patterns=&current_linestyle_patterns;
break;
case 1://file
source_list_len=&n_linestyles_file;
source_list_entry_lengths=&l_linestyle_pat_file;
source_list_patterns=&linestyle_pat_file;
break;
case 2://ini
source_list_len=&n_linestyles_ini;
source_list_entry_lengths=&l_linestyle_pat_ini;
source_list_patterns=&linestyle_pat_ini;
break;
case 3://grace-std
default:
copy_std_line_style_patterns(&cur_list_len,&cur_list_entries_length,&cur_list_patterns);
break;
}
if (nr>=0 && nr<=2)
{
    for (int i=0;i<cur_list_len;i++)
    {
    if (cur_list_patterns[i]!=NULL) delete[] cur_list_patterns[i];
    }
    delete[] cur_list_patterns;
    if (cur_list_entries_length!=NULL) delete[] cur_list_entries_length;

    cur_list_len=*source_list_len;
    cur_list_entries_length=new int[cur_list_len];
    memcpy(cur_list_entries_length,(*source_list_entry_lengths),sizeof(int)*cur_list_len);
    cur_list_patterns=new char*[cur_list_len];
    for (int i=0;i<cur_list_len;i++)
    {
    cur_list_patterns[i]=new char[cur_list_entries_length[i]];
    memcpy(cur_list_patterns[i],(*source_list_patterns)[i],sizeof(char)*cur_list_entries_length[i]);
    }
    for (int i=0;i<nr_of_panels;i++)
    {
    panels[i]->setEnabled(true);
    }
    selLen->setEnabled(true);
    selPos->setEnabled(true);
    cmdEdit->setEnabled(true);
    cmdAppend->setEnabled(true);
    cmdInsert->setEnabled(true);
    cmdDelete->setEnabled(true);
    cmdUp->setEnabled(true);
    cmdDown->setEnabled(true);
}
else//Grace-std. -- not editable
{
    for (int i=0;i<nr_of_panels;i++)
    {
    panels[i]->setEnabled(false);
    }
    selLen->setEnabled(false);
    selPos->setEnabled(false);
    selLen->setEnabled(false);
    selPos->setEnabled(false);
    cmdEdit->setEnabled(false);
    cmdAppend->setEnabled(false);
    cmdInsert->setEnabled(false);
    cmdDelete->setEnabled(false);
    cmdUp->setEnabled(false);
    cmdDown->setEnabled(false);
}

for (int i=0;i<cur_list_len;i++)
{
delete cur_list_LineIcons[i];
delete cur_list_LinePixmaps[i];
delete cur_list_PenDashPattern[i];
}
delete[] cur_list_LineIcons;
delete[] cur_list_LinePixmaps;
delete[] cur_list_PenDashPattern;

cur_list_LineIcons=new QIcon*[cur_list_len];
cur_list_LinePixmaps=new QPixmap*[cur_list_len];
cur_list_PenDashPattern=new QVector<qreal>*[cur_list_len];
for (int i=0;i<cur_list_len;i++)
{
cur_list_LineIcons[i]=NULL;
cur_list_LinePixmaps[i]=NULL;
cur_list_PenDashPattern[i]=NULL;
create_one_line_pattern(cur_list_entries_length[i],cur_list_patterns[i],cur_list_LinePixmaps+i,cur_list_LineIcons+i,cur_list_PenDashPattern+i);
}

refillLineStyleSelector();

//cout << "Show nr=" << nr << endl;
}

void tabLinestyles::currentStyleChanged(int nr)
{
//qDebug() << "Style Changed";
disconnect(selLen,SIGNAL(currentValueChanged(int)),0,0);
int len=pattern_length(cur_list_entries_length[nr],cur_list_patterns[nr]);
selLen->setValue(len);
selPos->setValue(nr);

setPanelsToOnePattern(cur_list_entries_length[nr],cur_list_patterns[nr],len);

generate_Pattern();
plotExamples();
connect(selLen,SIGNAL(currentValueChanged(int)),SLOT(currentLengthChanged(int)));
}

void tabLinestyles::currentLengthChanged(int nr)
{
//cout << "Length changed=" << nr << endl;
int len=pattern_length(cur_line_len,cur_line_pattern);
int diff=nr-len;
//cout << "Alt: Segmente=" << cur_line_len << " aktuelle_laenge=" << len << " Neu=" << nr << " Diff=" << diff << endl;
int index;
    if (diff<0)
    {
    len=0;
    index=0;
        for (int i=0;i<cur_line_len;i++)
        {
            len+=cur_line_pattern[i];
            index=i+1;
            if (len>=nr) break;
        }
        if (index%2==0)//even
        cur_line_len=index;
        else
        {
        cur_line_len=index+1;
        cur_line_pattern[index]=0;
        }
            if (len>nr)
            {
            cur_line_pattern[index-1]-=(len-nr);
            }
    }
    else if (diff>0)
    {
    cur_line_pattern[cur_line_len-1]+=diff;
    }
    else
    {
    return;
    }
len=pattern_length(cur_line_len,cur_line_pattern);
setPanelsToOnePattern(cur_line_len,cur_line_pattern,len);
generate_Pattern();
plotExamples();
}

void tabLinestyles::panel_clicked(int nr)
{
if (selShowLinestyles->currentIndex()==3) return;
    if (panels[nr]->p==blackpanel)
    panels[nr]->p=whitepanel;
    else
    panels[nr]->p=blackpanel;
panels[nr]->repaint();
generate_Pattern();
plotExamples();
}

void tabLinestyles::refillLineStyleSelector(void)
{
int current_nr=selStyles->currentIndex();
disconnect(selStyles,SIGNAL(currentIndexChanged(int)),0,0);
update_one_line_style_selector(selStyles,cur_list_len,cur_list_LinePixmaps);
selStyles->setCurrentIndex(current_nr);
connect(selStyles,SIGNAL(currentIndexChanged(int)),SLOT(currentStyleChanged(int)));
}

void tabLinestyles::generate_Pattern(void)
{
    //cout << "Generating Pattern" << endl;
char * simple=new char[nr_of_panels+8];
int nr_of_sub_patterns=0;
bool current_black=false;
bool last_black;
    if (panels[0]->p==blackpanel)
    current_black=true;
    else
    current_black=false;
//cout << 0 << " Current_Black=" << current_black << endl;
    simple[0]=1;
last_black=current_black;
for (int i=1;i<nr_of_panels;i++)
{
    if (panels[i]->p==blackpanel)
    current_black=true;
    else
    current_black=false;
//cout << i << " Current_Black=" << current_black << endl;
        if (last_black!=current_black)
        {
        last_black=current_black;
        nr_of_sub_patterns++;
        simple[nr_of_sub_patterns]=1;
        }
        else
        {
        simple[nr_of_sub_patterns]++;
        }
}
nr_of_sub_patterns++;

if (nr_of_sub_patterns<2)
{
simple[1]=0;
nr_of_sub_patterns++;
    if (panels[0]->p!=blackpanel)
    {
    simple[0]=0;
    simple[1]=1;
    }
}
else if (panels[0]->p!=blackpanel)
{
    for (int i=1;i<nr_of_sub_patterns;i++)
    {
    simple[i-1]=simple[i];
    }
    nr_of_sub_patterns--;
    if (nr_of_sub_patterns<2)
    {
    simple[1]=0;
    nr_of_sub_patterns++;
        if (panels[0]->p!=blackpanel)
        {
        simple[0]=0;
        simple[1]=1;
        }
    }
}
if (nr_of_sub_patterns%2==1)
{
simple[nr_of_sub_patterns++]=0;
}
if (cur_line_pattern!=NULL) delete[] cur_line_pattern;

cur_line_len=nr_of_sub_patterns;
cur_line_pattern=new char[cur_line_len];
memcpy(cur_line_pattern,simple,sizeof(char)*cur_line_len);

/*qDebug() << "New Pattern; lenght=" << cur_line_len;
for (int i=0;i<cur_line_len;i++)
qDebug() << (int)(cur_line_pattern[i]);*/

create_one_line_pattern(cur_line_len,cur_line_pattern,&cur_line_pm,&cur_line_ic,&cur_line_pendash);

delete[] simple;
//cout << "End Generating Pattern" << endl;
}

void tabLinestyles::plotExamples(void)
{
    //cout << "Plot Examples" << endl;
QPainter paint1;
QPen pen;
pen.setColor(Qt::black);
if (cur_line_len==2 && (cur_line_pattern[0]==0 || cur_line_pattern[1]==0))//only one black or white pattern
{
    if (cur_line_pattern[0]==0)
    pen.setColor(Qt::white);
pen.setStyle(Qt::SolidLine);
}
else
{
pen.setStyle(Qt::CustomDashLine);
pen.setDashPattern(*cur_line_pendash);
pen.setCapStyle(Qt::FlatCap);
}
delete pmExample;
int wid=lblExample->width()-20;
int siz=wid*0.3-50;
pmExample=new QPixmap(wid,wid*0.3);
pmExample->fill();

paint1.begin(pmExample);
pen.setWidth(1);
paint1.setPen(pen);
paint1.drawLine(10,10,wid-10,10);
pen.setWidth(3);
paint1.setPen(pen);
paint1.drawLine(10,20,wid-10,20);
pen.setWidth(5);
paint1.setPen(pen);
paint1.drawLine(10,30,wid-10,30);
pen.setWidth(2);
paint1.setPen(pen);
paint1.drawRect(10,40,siz,siz);
paint1.drawArc(20+siz,40,siz,siz,0,16*360);

double x,y;
x=0.0;
y=0.0;
QPointF points[70];
for (int i=0;i<70;i++)
{
x=2.0*3.1415927*4.0*i/70.0;
y=sin(x);
points[i].setX(2*siz+30+x*11);
points[i].setY(40+siz*0.5-y*siz*0.5);
}
paint1.drawPolyline(points,70);
paint1.end();

lblExample->setPixmap(*pmExample);
    //cout << "End Plot Examples" << endl;
}

void tabLinestyles::resizeEvent( QResizeEvent * event )
{
(void)event;
    //cout << "ResizeEvent" << endl;
plotExamples();
    //cout << "End Reize Event" << endl;
}


int yesnowin(const char * msg,const char * s1,const char * s2,const char * help_anchor)
{
    (void)help_anchor;
    if (s1==NULL)
        return QMessageBox::question(0,QString("Error"),QString::fromLocal8Bit(msg),QMessageBox::Yes | QMessageBox::No)==QMessageBox::Yes?1:0;
    else
        return QMessageBox::question(0,QString(s1),QString::fromLocal8Bit(msg) + QString(s2),QMessageBox::Yes | QMessageBox::No)==QMessageBox::Yes?1:0;
}

frmSpreadSheet * findOpenSpreadSheet(int gno,int setno)
{
int found=-1;
    for (int i=0;i<number_of_opened_spreadsheets;i++)
    {
        if (FormSpreadSheets[i]!=NULL)
            if (FormSpreadSheets[i]->gno==gno && FormSpreadSheets[i]->sno==setno)
            {
                found=i;
                break;
            }
    }
if (found<0)
{
return NULL;
}
else
{
return FormSpreadSheets[found];
}
}

void showSetInSpreadSheet(int gno,int setno)
{
    int found=-1;
    for (int i=0;i<number_of_opened_spreadsheets;i++)
    {
        if (FormSpreadSheets[i]!=NULL)
            if (FormSpreadSheets[i]->gno==gno && FormSpreadSheets[i]->sno==setno)
            {
                found=i;
                break;
            }
    }
    if (found>=0)
    {
        FormSpreadSheets[found]->show();
        qApp->processEvents();
        FormSpreadSheets[found]->init(FormSpreadSheets[found]->gno,FormSpreadSheets[found]->sno);
        FormSpreadSheets[found]->raise();
    }
    else//new one needed
    {
        frmSpreadSheet ** sheets=new frmSpreadSheet *[number_of_opened_spreadsheets+1];
        for (int i=0;i<number_of_opened_spreadsheets;i++)
            sheets[i]=FormSpreadSheets[i];
        delete[] FormSpreadSheets;
        FormSpreadSheets=new frmSpreadSheet *[number_of_opened_spreadsheets+1];
        for (int i=0;i<number_of_opened_spreadsheets;i++)
            FormSpreadSheets[i]=sheets[i];
        delete[] sheets;
        FormSpreadSheets[number_of_opened_spreadsheets]=new frmSpreadSheet(0);
        FormSpreadSheets[number_of_opened_spreadsheets]->init(gno,setno);
        FormSpreadSheets[number_of_opened_spreadsheets]->show();
        FormSpreadSheets[number_of_opened_spreadsheets]->raise();
        FormSpreadSheets[number_of_opened_spreadsheets]->activateWindow();
        number_of_opened_spreadsheets++;
    }
}

/*void deleteSpreadSheet(int gno,int setno)
{
    int found=-1;
    for (int i=0;i<number_of_opened_spreadsheets;i++)
    {
        if (FormSpreadSheets[i]->gno==gno && FormSpreadSheets[i]->sno==setno)
        {
            found=i;
            break;
        }
    }
}*/

frmFeatureExtract::frmFeatureExtract(QWidget * parent):QDialog(parent)
{
    int number;
    QString entr[32];
    int vals[32];
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Feature extraction"));
    setWindowIcon(QIcon(*GraceIcon));

    lblSourceGraph=new QLabel(tr("Features from graph:"),this);
    listSourceGraph=new uniList(GRAPHLIST,this);
    lblResultGraph=new QLabel(tr("Results to graph:"),this);
    listResultGraph=new uniList(GRAPHLIST,this);
    lblAbscissaGraph=new QLabel(tr("Abscissa from graph:"),this);
    listAbscissaGraph=new uniList(GRAPHLIST,this);
    lblSet=new QLabel(tr("Set:"),this);
    listSet=new uniList(SETLIST,this);

    number=7;
    entr[0]=tr("None");
    entr[1]=tr("Region 0");
    entr[2]=tr("Region 1");
    entr[3]=tr("Region 2");
    entr[4]=tr("Region 3");
    entr[5]=tr("Region 4");
    entr[6]=tr("Inside graph");
    selRestriction=new StdSelector(this,tr("Restriction:"),number,entr);
    chkNeg=new QCheckBox(tr("Negated"),this);
    chkNeg->setChecked(FALSE);

    buttonGroup=new stdButtonGroup(this,false,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    number=28;
    entr[0]=tr("Y minimum");
    entr[1]=tr("Y maximum");
    entr[2]=tr("Y average");
    entr[3]=tr("Y std. dev.");
    entr[4]=tr("Y median");
    entr[5]=tr("X minimum");
    entr[6]=tr("X maximum");
    entr[7]=tr("X average");
    entr[8]=tr("X std. dev.");
    entr[9]=tr("X median");
    entr[10]=tr("Frequency");
    entr[11]=tr("Period");
    entr[12]=tr("Zero crossing");
    entr[13]=tr("Rise time");
    entr[14]=tr("Fall time");
    entr[15]=tr("Slope");
    entr[16]=tr("Y intercept");
    entr[17]=tr("Set length");
    entr[18]=tr("Half maximal width");
    entr[19]=tr("Barycenter X");
    entr[20]=tr("Barycenter Y");
    entr[21]=tr("X(Y max)");
    entr[22]=tr("Y(X max)");
    entr[23]=tr("Integral");
    entr[24]=tr("Y-Value crossing");
    entr[25]=tr("X-Value crossing");
    entr[26]=tr("X(Y min)");
    entr[27]=tr("Y(X min)");

    vals[0]=FEATURE_Y_MIN;
    vals[1]=FEATURE_Y_MAX;
    vals[2]=FEATURE_Y_AVG;
    vals[3]=FEATURE_Y_STD_DEV;
    vals[4]=FEATURE_Y_MEDIAN;
    vals[5]=FEATURE_X_MIN;
    vals[6]=FEATURE_X_MAX;
    vals[7]=FEATURE_X_AVG;
    vals[8]=FEATURE_X_STD_DEV;
    vals[9]=FEATURE_X_MEDIAN;
    vals[10]=FEATURE_FREQUENCY;
    vals[11]=FEATURE_PERIOD;
    vals[12]=FEATURE_ZERO_CROSSING;
    vals[13]=FEATURE_RISE_TIME;
    vals[14]=FEATURE_FALL_TIME;
    vals[15]=FEATURE_SLOPE;
    vals[16]=FEATURE_Y_INTERCEPT;
    vals[17]=FEATURE_SET_LENGTH;
    vals[18]=FEATURE_HALF_MAX_WIDTH;
    vals[19]=FEATURE_BARYCENTER_X;
    vals[20]=FEATURE_BARYCENTER_Y;
    vals[21]=FEATURE_X_OF_YMAX;
    vals[22]=FEATURE_Y_OF_XMAX;
    vals[23]=FEATURE_INTEGRAL;
    vals[24]=FEATURE_VALUE_CROSSING;
    vals[25]=FEATURE_VALUE_CROSSING2;
    vals[26]=FEATURE_X_OF_YMIN;
    vals[27]=FEATURE_Y_OF_XMIN;

    selFeature=new StdSelector(this,tr("Feature:"),number,entr);
    selFeature->setValues(vals);
    connect(selFeature->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(FeatureChanged(int)));
    ledValue=new stdLineEdit(this,tr("Value:"),false);
    //ledValue->setText(QString("0.0"));
    ledValue->setDoubleValue("%.1f",0.0);
    ledValue->setVisible(false);
    number=4;
    entr[0]=tr("Index");
    entr[1]=tr("Legends");
    entr[2]=tr("X from Set");
    entr[3]=tr("Y from Set");
    selXValue=new StdSelector(this,tr("X values from:"),number,entr);
    connect(selXValue->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(XValueChanged(int)));

    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->addWidget(lblSourceGraph);
    layout->addWidget(listSourceGraph);
    layout->addWidget(lblResultGraph);
    layout->addWidget(listResultGraph);
    layout->addWidget(selFeature);
    layout->addWidget(ledValue);
    layout->addWidget(selRestriction);
    layout->addWidget(chkNeg);
    layout->addWidget(selXValue);
    layout->addWidget(lblAbscissaGraph);
    layout->addWidget(listAbscissaGraph);
    layout->addWidget(lblSet);
    layout->addWidget(listSet);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    lblAbscissaGraph->setEnabled(FALSE);
    listAbscissaGraph->setEnabled(FALSE);
    lblSet->setEnabled(FALSE);
    listSet->setEnabled(FALSE);
    resize(LastSize_FormFeatureExtraction);
}

frmFeatureExtract::~frmFeatureExtract()
{
    LastSize_FormFeatureExtraction=this->size();
}

void frmFeatureExtract::init(void)
{
    listSourceGraph->update_number_of_entries();
    listResultGraph->update_number_of_entries();
    listAbscissaGraph->update_number_of_entries();

    int nr_sel=1;
    int sel=get_cg();
    listSourceGraph->set_new_selection(nr_sel,&sel);
    listResultGraph->set_new_selection(nr_sel,&sel);
    listAbscissaGraph->set_new_selection(nr_sel,&sel);
    listSet->set_graph_number(sel,true);
    //listSet->update_number_of_entries();
    ledValue->ReplaceNumberContents();
}

void frmFeatureExtract::FeatureChanged(int i)
{
    (void)i;
    if (selFeature->currentValue()==FEATURE_VALUE_CROSSING)
    {
        ledValue->setVisible(true);
        ledValue->lblText->setText(tr("Y-Value:"));
    }
    else if (selFeature->currentValue()==FEATURE_VALUE_CROSSING2)
    {
        ledValue->setVisible(true);
        ledValue->lblText->setText(tr("X-Value:"));
    }
    else
    {
        ledValue->setVisible(false);
    }
}

void frmFeatureExtract::XValueChanged(int i)
{
    if (i == 2 || i == 3)
    {
        lblAbscissaGraph->setVisible(TRUE);
        listAbscissaGraph->setVisible(TRUE);
        lblSet->setVisible(TRUE);
        listSet->setVisible(TRUE);
    }
    else
    {
        lblAbscissaGraph->setVisible(FALSE);
        listAbscissaGraph->setVisible(FALSE);
        lblSet->setVisible(FALSE);
        listSet->setVisible(FALSE);
    }
}

void frmFeatureExtract::doClose(void)
{
    hide();
}

void frmFeatureExtract::doAccept(void)
{
    int gfrom, gto, feature, abs_graph = -1, abs_set = -1, abs_src, negate, restrict;
    int n_sel,*sel=new int[2];

    feature = selFeature->currentValue();//GetOptionChoice(ui->feature_item);
    //GetSingleListChoice(ui->tograph, &gto);
    listSourceGraph->get_selection(&n_sel,&sel);
    if (n_sel<=0)
    {gfrom=get_cg();}
    else
    {gfrom=sel[0];}
    listResultGraph->get_selection(&n_sel,&sel);
    if (n_sel<=0)
    {gto=-1;}
    else
    {gto=sel[0];}
        if( !is_valid_gno(gto) )
        gto = get_cg();
    abs_src =selXValue->currentIndex();// (int) GetChoice(ui->xval_item);
    if( abs_src ==2 || abs_src==3 )
    {
        listSet->get_selection(&n_sel,&sel);
        if (n_sel<=0)
        {abs_set=-1;}
        else
        {abs_set=sel[0];}
        //abs_set = GetSelectedSet(ui->absic_set);
        listAbscissaGraph->get_selection(&n_sel,&sel);
        if (n_sel<=0)
        {abs_graph=get_cg();}
        else
        {abs_graph=sel[0];}
        //GetSingleListChoice(ui->absic_graph, &abs_graph);
    }

    negate=(chkNeg->isChecked()==true?1:0);
    switch (selRestriction->currentIndex())
    {
    case 0:
    default:
        restrict=RESTRICT_NONE;
        break;
    case 1:
        restrict=RESTRICT_REG0;
        break;
    case 2:
        restrict=RESTRICT_REG1;
        break;
    case 3:
        restrict=RESTRICT_REG2;
        break;
    case 4:
        restrict=RESTRICT_REG3;
        break;
    case 5:
        restrict=RESTRICT_REG4;
        break;
    case 6:
        restrict=RESTRICT_WORLD;
        break;
    }

    new_set_no=-1;
    fext_routine(gfrom, gto, feature, abs_src, abs_set, abs_graph, restrict, negate);

    ///Undo-Stuff
    int gnos[2]={gto,gto};
    int snos[2]={new_set_no,new_set_no};
    SetsCreated(1,gnos,snos,UNDO_COMPLETE);
    addAditionalDescriptionToLastNode(-1,QObject::tr("Feature extraction (")+QString(tbuf)+QString(")"),QString());

    update_set_lists(gto);
    mainWin->mainArea->completeRedraw();
    listResultGraph->update_number_of_entries();
    listAbscissaGraph->update_number_of_entries();
    listSet->update_number_of_entries();
    delete[] sel;
}

void frmFeatureExtract::fext_routine(int gfrom, int gto, int feature, int abs_src, int abs_set, int abs_graph, int restr, int neg)
{
    int i, cs, ns, ncurves, extract_err, answer,first_set;
    double datum, dummy, extract_val, *absy;
    double * abscissa;
    QString formula,tmp_str;
    char dummy_formula[1024];

    ListOfChanges.clear();
    ListOfOldStates.clear();

    if( !is_graph_active( gto )	){
        FormConsole->errwin(tr("Graph for results must be active").toLocal8Bit().constData());
        return;
    }
    if( (new_set_no=ns=nextset( gto ) )== -1 ) {
        FormConsole->errwin(tr("Choose a new graph or kill sets!").toLocal8Bit().constData());
        return;
    }
    abscissa = (double*)xmalloc(number_of_sets(gfrom)*sizeof(double));
    ncurves = nactive(gfrom);
    first_set=-1;
        for (i=0;i<ncurves;i++)
        {
            if (is_set_active( gfrom, i ) && first_set==-1)
            {
            first_set=i;
            break;
            }
        }
    //cout << "gto=" << gto << " feature=" << feature << " abs_src=" << abs_src << " abs_set=" << abs_set << " abs_graph=" << abs_graph << " ncurves=" << ncurves << endl;
    switch( abs_src ) {
    case 0:		/* use index */
        for( i=0; i<ncurves; i++ )
            abscissa[i] = (double)i;
        break;
    case 1:		/* use legend label */
        cs = 0;
        for( i=0; i<ncurves; i++ ){
            while( !is_set_active( gfrom, cs ) )
                cs++;
            if(!sscanf( get_legend_string(gfrom, cs), "%lf", &abscissa[i]))
                break;
            cs++;
        }
        if( i != ncurves ) {
            FormConsole->errwin(tr("Bad legend label").toLocal8Bit().constData());
            xfree( abscissa );
            return;
        }
        break;
    case 2:     /* use X from set */
        if( !is_set_active( abs_graph, abs_set ) ){
            FormConsole->errwin(tr("Abscissa set not active").toLocal8Bit().constData());
            xfree( abscissa );
            return;
        }
        if( getsetlength( abs_graph, abs_set ) < ncurves ) {
            FormConsole->errwin(tr("Not enough points in set").toLocal8Bit().constData());
            xfree( abscissa );
            return;
        }
        absy = getx( abs_graph, abs_set );
        for( i=0; i<ncurves; i++ )
            abscissa[i] = absy[i];
        break;
    case 3:     /* use Y from set */
        if( !is_set_active( abs_graph, abs_set ) ){
            FormConsole->errwin(tr("Abscissa set not active").toLocal8Bit().constData());
            xfree( abscissa );
            return;
        }
        if( getsetlength( abs_graph, abs_set ) < ncurves ) {
            FormConsole->errwin(tr("Not enough points in set").toLocal8Bit().constData());
            xfree( abscissa );
            return;
        }
        absy = gety( abs_graph, abs_set );
        for( i=0; i<ncurves; i++ )
            abscissa[i] = absy[i];
        break;
    }

    cs = 0;
    tbuf[0] = '\0';

    for( i=0; i<ncurves; i++ ) {
        while( !is_set_active( gfrom, cs ) )
            cs++;
        extract_err = 0;

            if (feature==FEATURE_VALUE_CROSSING || feature==FEATURE_VALUE_CROSSING2)//a value is asked
            {
            set_parser_setno(gfrom, cs);
            formula=ledValue->text();
            formula.replace(QString("G#"),QString::number(gfrom),Qt::CaseInsensitive);
            formula.replace(QString("S#"),QString::number(cs),Qt::CaseInsensitive);
            //qDebug() << "resulting formula=" << formula;
            strcpy(dummy_formula,formula.toLatin1().constData());
            answer=std_evalexpr(dummy_formula,&dummy);
            //int answer=xv_evalexpr(ledValue,&dummy);
                if (answer==RETURN_FAILURE)
                {
                strcpy(tbuf,tr("Unable to evaluate expression ").toLocal8Bit().constData());
                strcat(tbuf,ledValue->text().toLocal8Bit().constData());
                FormConsole->errwin(tbuf);
                xfree( abscissa );
                return;
                }
            extract_val=datum=dummy;
            }

        extract_err=extract_single_feature(feature,gfrom,cs,restr,neg,&datum);

        if( !extract_err )
            add_point(gto, ns, abscissa[i], datum);
        cs++;
    }

    if (first_set>=0)//if first_set<0 then there is no active set
    {
    ListOfChanges << specialExtractCommand(feature,gfrom,first_set,extract_val);//this generates the Y-values in a19
        switch( abs_src )//generate X-values
        {
        case 0:		/* use index */
        ListOfChanges << QString("#if[S#=")+QString::number(first_set)+QString("] a18=0 #Please adjust ID to first ID in selection: #if[S#=<first set-id>]...");
        ListOfChanges << QString("#if[S#!=")+QString::number(first_set)+QString("] a18=a18+1 #Please adjust ID to first ID in selection");
        break;
        case 1:		/* use legend label */
        ListOfChanges << QString("a18=S#");//this is wrong, but there is no formula to convert a string to an integer
        break;
        case 2:     /* use X from set */
        ListOfChanges << QString("a18=G")+QString::number(abs_graph)+QString("$.S")+QString::number(abs_set)+QString("$.X[S#]");
        break;
        case 3:     /* use Y from set */
        ListOfChanges << QString("a18=G")+QString::number(abs_graph)+QString("$.S")+QString::number(abs_set)+QString("$.Y[S#]");
        break;
        }
    ListOfChanges << QString("#QTGRACE_SPECIAL APPEND G")+QString::number(gto)+QString(".S0N{a18;a19}");//this will copy the new values in a new set
    }
    /* set comment */
    switch( feature ) {
    case 0:			/* Y minimum */
        //sprintf(tbuf,"Y minima of graph %d",gfrom);
        tmp_str=tr("Y minima of graph ")+QString::number(gfrom);
        break;
    case 1: 		/* Y maximum */
        //sprintf(tbuf,"Y maxima of graph %d",gfrom);
        tmp_str=tr("Y maxima of graph ")+QString::number(gfrom);
        break;
    case 2: 		/* Y mean    */
        //sprintf(tbuf,"Y means of graph %d",gfrom);
        tmp_str=tr("Y means of graph ")+QString::number(gfrom);
        break;
    case 3:			/* Y std dev */
        //sprintf(tbuf,"Y std. dev.'s of graph %d",gfrom);
        tmp_str=tr("Y std. dev.'s of graph ")+QString::number(gfrom);
        break;
    case 4:			/* Y median  */
        //sprintf(tbuf,"Y medians of graph %d",gfrom);
        tmp_str=tr("Y medians of graph ")+QString::number(gfrom);
        break;
    case 5:			/* X minimum */
        //sprintf(tbuf,"X minima of graph %d",gfrom);
        tmp_str=tr("X minima of graph ")+QString::number(gfrom);
        break;
    case 6: 		/* X maximum */
        //sprintf(tbuf,"X maxima of graph %d",gfrom);
        tmp_str=tr("X maxima of graph ")+QString::number(gfrom);
        break;
    case 7: 		/* X mean    */
        //sprintf(tbuf,"X means of graph %d",gfrom);
        tmp_str=tr("X means of graph ")+QString::number(gfrom);
        break;
    case 8:			/* X std dev */
        //sprintf(tbuf,"X std. dev.'s of graph %d",gfrom);
        tmp_str=tr("X std. dev.'s of graph ")+QString::number(gfrom);
        break;
    case 9:			/* X median  */
        //sprintf(tbuf,"X medians of graph %d",gfrom);
        tmp_str=tr("X medians of graph ")+QString::number(gfrom);
        break;
    case 10: 		/* frequency and period */
        //sprintf(tbuf,"frequencies of graph %d",gfrom);
        tmp_str=tr("frequencies of graph ")+QString::number(gfrom);
        break;
    case 11:
        //sprintf(tbuf,"periods of graph %d",gfrom);
        tmp_str=tr("periods of graph ")+QString::number(gfrom);
        break;
    case 12:		/* first zero crossing */
        //sprintf(tbuf,"zero crossings of graph %d",gfrom);
        tmp_str=tr("zero crossings of graph ")+QString::number(gfrom);
        break;
    case 13:		/* rise time */
        //sprintf(tbuf,"rise times of graph %d",gfrom);
        tmp_str=tr("rise times of graph ")+QString::number(gfrom);
        break;
    case 14: 		/* fall time */
        //sprintf(tbuf,"fall times of graph %d",gfrom);
        tmp_str=tr("fall times of graph ")+QString::number(gfrom);
        break;
    case 15: 		/* slopes     */
        //sprintf(tbuf,"slopes of graph %d",gfrom);
        tmp_str=tr("slopes of graph ")+QString::number(gfrom);
        break;
    case 16: 		/* Y intercepts */
        //sprintf(tbuf,"Y intercepts of graph %d",gfrom);
        tmp_str=tr("Y intercepts of graph ")+QString::number(gfrom);
        break;
    case 17: 		/* set lengths */
        //sprintf(tbuf,"set lengths of graph %d",gfrom);
        tmp_str=tr("set lengths of graph ")+QString::number(gfrom);
        break;
    case 18: 		/* 1/2 maximal widths */
        //sprintf(tbuf,"half maximal widths of graph %d",gfrom);
        tmp_str=tr("half maximal widths of graph ")+QString::number(gfrom);
        break;
    case 19: 		/* barycenter X */
        //sprintf(tbuf,"X barycenters of graph %d",gfrom);
        tmp_str=tr("X barycenters of graph ")+QString::number(gfrom);
        break;
    case 20: 		/* barycenter Y */
        //sprintf(tbuf,"Y barycenters of graph %d",gfrom);
        tmp_str=tr("Y barycenters of graph ")+QString::number(gfrom);
        break;
    case 21:		/* X of maximum Y */
        //sprintf(tbuf,"X positions of maximum Y's of graph %d",gfrom);
        tmp_str=tr("X positions of maximum Y's of graph ")+QString::number(gfrom);
        break;
    case 22:		/* Y of maximum X */
        //sprintf(tbuf,"Y positions of maximum X's of graph %d",gfrom);
        tmp_str=tr("Y positions of maximum X's of graph ")+QString::number(gfrom);
        break;
    case 23:		/* integral */
        //sprintf(tbuf,"integrals of sets of graph %d",gfrom);
        tmp_str=tr("integrals of sets of graph ")+QString::number(gfrom);
        break;
    case 24:		/* first crossing of specified y-value */
        sprintf(tbuf,"first y-crossing of %g of graph %d",dummy,gfrom);
        tmp_str=tr("first y-crossing of ")+QString::number(dummy)+(" of graph ")+QString::number(gfrom);
        break;
    case 25:		/* first crossing of specified x-value */
        //sprintf(tbuf,"first x-crossing of %g of graph %d",dummy,gfrom);
        tmp_str=tr("first x-crossing of ")+QString::number(dummy)+(" of graph ")+QString::number(gfrom);
        break;
    case 26:		/* X of minimum Y */
        //sprintf(tbuf,"X positions of minimum Y's of graph %d",gfrom);
        tmp_str=tr("X positions of minimum Y's of graph ")+QString::number(gfrom);
        break;
    case 27:		/* X of minimum Y */
        //sprintf(tbuf,"Y positions of minimum X's of graph %d",gfrom);
        tmp_str=tr("Y positions of minimum X's of graph ")+QString::number(gfrom);
        break;
    }
    set_set_hidden(gto, ns, FALSE);
    //setcomment( gto, ns, tbuf );
    setcomment( gto, ns, tmp_str.toLocal8Bit().constData() );
    xfree( abscissa );
}


frmAgrInfos::frmAgrInfos(QWidget * parent):QDialog(parent)
{
setWindowTitle(QString("QtGrace: ")+QObject::tr("Import set(s) from agr-file"));
lblFilename=new QLabel(tr("Filename="),this);
lblFilenText=new QLabel(QString(""),this);
lblDescription=new QLabel(tr("Project description:"),this);
lblDescrText=new QLabel(QString(""),this);
lblDescrText->setWordWrap(true);

lblFilenText->setFrameStyle(QFrame::Panel | QFrame::Sunken);
lblDescrText->setFrameStyle(QFrame::Panel | QFrame::Sunken);
QPalette pal=lblFilenText->palette();
    #if QT_VERSION >= 0x060000
    pal.setColor(QPalette::Base,Qt::white);
    #else
    pal.setColor(QPalette::Background,Qt::white);
    #endif
lblFilenText->setPalette(pal);
lblFilenText->setAutoFillBackground(true);
lblDescrText->setPalette(pal);
lblDescrText->setAutoFillBackground(true);

int nr=2;
QString * entries=new QString[8];
entries[0]=QString("G0");
entries[1]=QString("G1");
selTargetGno=new StdSelector(this,tr("Target graph:"),nr,entries);
selTargetGno->simple_graph_selector=true;
nr=4;
entries[0]=tr("manual");
entries[1]=tr("none");
entries[2]=tr("all");
entries[3]=tr("invert");
selSelection=new StdSelector(this,tr("Selection:"),nr,entries);
connect(selSelection,SIGNAL(currentIndexChanged(int)),SLOT(changeSelection(int)));
delete[] entries;
chkAutoscale=new QCheckBox(tr("Autoscale"),this);

scroll=new QScrollArea;
empty=new QWidget();
layout0=new QGridLayout;
//layout0->setMargin(0);
layout0->setContentsMargins(0,0,0,0);
layout0->setSpacing(0);

lblTitle=new QLabel*[5];
lblTitle[0]=new QLabel(tr("Import"));
lblTitle[1]=new QLabel(tr("Set-ID"));
lblTitle[2]=new QLabel(tr("Type"));
lblTitle[3]=new QLabel(tr("Legend"));
lblTitle[4]=new QLabel(tr("Comment"));
for (int i=0;i<5;i++)
{
layout0->addWidget(lblTitle[i],0,i,1,1);
/// lblTitle[i]->setMaximumHeight(20);
lblTitle[i]->setFrameStyle(QFrame::Box | QFrame::Raised);
}
/// lblTitle[0]->setMaximumWidth(50);
//empty->setGeometry(0,0,600,35);
empty->setLayout(layout0);
empty->adjustSize();
scroll->setWidget(empty);

allocated_controls=0;
chkImport=NULL;
lblID=NULL;
lblLegend=NULL;
lblComment=NULL;

//cmdImport=new QPushButton(tr("Import set(s)"),this);
//connect(cmdImport,SIGNAL(clicked()),SLOT(doImport()));
//cmdImport->hide();
buttons=new stdButtonGroup(this);
buttons->cmdApply->setText(tr("Open agr-file"));
buttons->cmdApply->setToolTip(tr("Open the project file normally (closing current project)"));
buttons->cmdAccept->setText(tr("Import set(s)"));
buttons->cmdAccept->setToolTip(tr("Import selected set(s) in current project\n(only sets are imported including their appearance and description\nbut no text, objects or labels)"));
buttons->cmdClose->setText(tr("Cancel"));
connect(buttons->cmdApply,SIGNAL(clicked()),SLOT(doOpenAgr()));
connect(buttons->cmdAccept,SIGNAL(clicked()),SLOT(doImportAgr()));
connect(buttons->cmdClose,SIGNAL(clicked()),SLOT(doCancel()));

cmdShowAgrInfo=new QPushButton(tr("Show set import options >>>"),this);
cmdShowAgrInfo->hide();
//connect(cmdShowAgrInfo,SIGNAL(clicked()),SLOT(toggleShowAgrInfo()));

shButtons=shFilename=true;

layout1=new QGridLayout;
//layout1->setMargin(STD_MARGIN);
layout1->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
layout1->setSpacing(STD_SPACING);

layout1->addWidget(lblFilename,0,0,1,1);
layout1->addWidget(lblFilenText,0,1,1,2);
layout1->addWidget(lblDescription,1,0,1,3);
layout1->addWidget(lblDescrText,2,0,1,3);
layout1->addWidget(cmdShowAgrInfo,3,0,1,3);
layout1->addWidget(scroll,4,0,3,3);
layout1->addWidget(selSelection,7,0,1,1);
layout1->addWidget(selTargetGno,7,1,1,1);
layout1->addWidget(chkAutoscale,7,2,1,1);
//layout1->addWidget(cmdImport,7,2,1,1);

layout1->addWidget(buttons,8,0,1,3);
for (int i=0;i<9;i++)
{
layout1->setRowStretch(i,0);
}
//layout1->setRowStretch(3,2);
layout1->setRowStretch(5,2);

setLayout(layout1);
init_agr_file_info(info);
setMinimumHeight(200);
resize(LastSize_Form_AgrInfo);
}

frmAgrInfos::~frmAgrInfos()
{
    LastSize_Form_AgrInfo=this->size();
}

void frmAgrInfos::setVisibleItems(bool showButtons,bool showFilename)
{
shButtons=showButtons;
shFilename=showFilename;
    lblFilename->setVisible(shFilename);
    lblFilenText->setVisible(shFilename);
    buttons->setVisible(shFilename);
/*
layout1->setRowMinimumHeight(0,0);
layout1->setRowMinimumHeight(8,0);
layout1->setRowStretch(0,0);
layout1->setRowStretch(8,0);
*/
if (showButtons==false) layout1->removeWidget(buttons);
if (showFilename==false)
{
layout1->removeWidget(lblFilename);
layout1->removeWidget(lblFilenText);
}

}

void frmAgrInfos::setInfoVisible(bool v)
{
    if (v==false)
    {
    cmdShowAgrInfo->setText(tr("Show set import options >>>"));
    //cmdImport->setVisible(false);
    selSelection->setVisible(false);
    selTargetGno->setVisible(false);
    scroll->setVisible(false);

    layout1->removeWidget(scroll);
    layout1->removeWidget(selSelection);
    layout1->removeWidget(selTargetGno);
    //layout1->removeWidget(cmdImport);
    for (int i=4;i<9;i++) layout1->setRowStretch(i,0);
    }
    else
    {
    cmdShowAgrInfo->setText(tr("Hide set import options <<<"));
    //cmdImport->setVisible(true);
    selSelection->setVisible(true);
    selTargetGno->setVisible(true);
    scroll->setVisible(true);

    layout1->addWidget(scroll,4,0,3,3);
    layout1->addWidget(selSelection,7,0,1,1);
    layout1->addWidget(selTargetGno,7,1,1,1);
    //layout1->addWidget(cmdImport,7,2,1,1);
    }

    layout1->update();
}
void frmAgrInfos::toggleShowAgrInfo(void)
{
    //setInfoVisible(!cmdImport->isVisible());
}

void frmAgrInfos::init(char * filen)//initialize the display (not the target graph)
{
int nr=number_of_graphs();
QString * entr=new QString[nr+2];
int * vals=new int[nr+2];
char dummy[32];
sets_imported=agrs_opened=0;
for (int i=0;i<nr;i++)
{
sprintf(dummy,"G%d",i);
entr[i]=QString(dummy);
vals[i]=i;
}
selTargetGno->setNewEntries(nr,entr,vals);
delete[] entr;
delete[] vals;
read_header_from_agr(filen,info);//read all header informations from the agr-file
lblFilenText->setText(QString::fromLocal8Bit(filen));
lblDescrText->setText(info.project_description);
if (allocated_controls>0)
{
    for (int i=0;i<allocated_controls;i++)
    {
    layout0->removeWidget(chkImport[i]);
    delete chkImport[i];
    layout0->removeWidget(lblID[i]);
    delete lblID[i];
    layout0->removeWidget(lblLegend[i]);
    delete lblLegend[i];
    layout0->removeWidget(lblComment[i]);
    delete lblComment[i];
    layout0->removeWidget(lblType[i]);
    delete lblType[i];
    }
delete[] chkImport;
delete[] lblID;
delete[] lblLegend;
delete[] lblComment;
delete[] lblType;
chkImport=NULL;
lblID=NULL;
lblLegend=NULL;
lblComment=NULL;
lblType=NULL;
}
allocated_controls=info.nr_of_sets;
    if (info.nr_of_sets>0)
    {
    chkImport=new QCheckBox*[allocated_controls];
    lblID=new QLabel*[allocated_controls];
    lblLegend=new QLabel*[allocated_controls];
    lblComment=new QLabel*[allocated_controls];
    lblType=new QLabel*[allocated_controls];
        for (int i=0;i<allocated_controls;i++)
        {
        chkImport[i]=new QCheckBox();
        chkImport[i]->setMaximumWidth(25);
        chkImport[i]->setChecked(info.import.at(i));
        sprintf(dummy,"G%d.S%d",info.g_ids.at(i),info.s_ids.at(i));
        lblID[i]=new QLabel(QString(dummy));
        /// lblID[i]->setMaximumWidth(60);
        lblLegend[i]=new QLabel(info.set_legends.at(i));
        lblComment[i]=new QLabel(info.set_comments.at(i));
        lblType[i]=new QLabel(info.set_types.at(i));
        /// lblType[i]->setMaximumWidth(45);
        lblType[i]->setFrameStyle(QFrame::Box | QFrame::Raised);
        lblID[i]->setFrameStyle(QFrame::Box | QFrame::Raised);
        lblComment[i]->setFrameStyle(QFrame::Box | QFrame::Raised);
        lblLegend[i]->setFrameStyle(QFrame::Box | QFrame::Raised);
        layout0->addWidget(chkImport[i],i+1,0);
        layout0->setAlignment(chkImport[i],Qt::AlignHCenter);
        layout0->addWidget(lblID[i],i+1,1);
        layout0->addWidget(lblType[i],i+1,2);
        layout0->addWidget(lblLegend[i],i+1,3);
        layout0->addWidget(lblComment[i],i+1,4);
        }
    /// int he=lblTitle[0]->height();
    /// if (he>30 || he<15) he=20;
    empty->adjustSize();
    //empty->setGeometry(0,0,(scroll->width()>600?scroll->width():600),he*(allocated_controls+1));
    }
if (info.nr_of_sets<=0)
{
selSelection->setEnabled(false);
selTargetGno->setEnabled(false);
//cmdImport->setEnabled(false);
}
else
{
selSelection->setEnabled(true);
selTargetGno->setEnabled(true);
//cmdImport->setEnabled(true);
}
}

void frmAgrInfos::readSettings(void)
{
    for (int i=0;i<allocated_controls;i++)
    {
    info.import.replace(i,chkImport[i]->isChecked()==true?TRUE:FALSE);
    }
    info.target_gno=selTargetGno->currentValue();
}

void frmAgrInfos::changeSelection(int index)
{
switch(index)
{
case 0://manual
break;
case 1://none
    for (int i=0;i<allocated_controls;i++) chkImport[i]->setChecked(false);
break;
case 2://all
    for (int i=0;i<allocated_controls;i++) chkImport[i]->setChecked(true);
break;
case 3://invert
    for (int i=0;i<allocated_controls;i++) chkImport[i]->setChecked(!chkImport[i]->isChecked());
break;
}
}

void frmAgrInfos::doImport(void)
{
set_wait_cursor();
readSettings();
read_datasets_from_agr(info);
int autosc=AUTOSCALE_XY;
if (chkAutoscale->isChecked()==false) autosc=AUTOSCALE_NONE;
SetsImportedFromAgr(new_set_no,new_set_nos,info,autosc);
    if (autosc!=AUTOSCALE_NONE)
    autoscale_graph(info.target_gno,autosc);
mainWin->mainArea->completeRedraw();
sets_imported+=new_set_no;
unset_wait_cursor();
}

void frmAgrInfos::doCancel(void)
{
hide();
done(-1);
}

void frmAgrInfos::doOpenAgr(void)
{
set_wait_cursor();
load_project_file(info.filename,FALSE);
agrs_opened++;
hide();
done(0);
unset_wait_cursor();
}

void frmAgrInfos::doImportAgr(void)
{
doImport();
hide();
done(1);
}

void frmAgrInfos::reset_import_counters(void)
{
sets_imported=agrs_opened=0;
}

void frmAgrInfos::get_import_counts(int * n_o_sets,int * n_o_agrs)
{
*n_o_sets=sets_imported;
*n_o_agrs=agrs_opened;
}

frmIOForm::frmIOForm(int type,QWidget * parent):QDialog(parent)
{
    formType=type;
    frmEdBlock=NULL;
    int number;
    QString entr[32];
    int values[32];
    int number2,offset=0,offset2=0;
    QString entr2[32];
    char dummy[32];
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));

    grpRead=new QGroupBox(QString(""),this);
    grpWrite=new QGroupBox(QString(""),this);
    grpDescription=new QGroupBox(QString(""),this);
    grpTitle=new QGroupBox(QString(""),this);
    grpParamGraph=new QGroupBox(QString(""),this);

    lblReadGraph=new QLabel(tr("Read to graph:"),grpRead);
    lblWriteSet=new QLabel(tr("Write set(s):"),grpWrite);
    lblSelection=new QLabel(tr("Selection:"),this);
    lblDataSource=new QLabel(tr("Data source:"),grpRead);
    lblDescription=new QLabel(tr("Project description:"),grpDescription);

    ledFormat=new stdLineEdit(grpWrite,tr("Format:"));
    //ledFormat->lenText->setText(QString("\%.8g"));
    ledFormat->lenText->setText(QString(sformat));
    ledFormat2=new stdLineEdit(grpWrite,tr("Data format:"));
    //ledFormat2->lenText->setText(QString("\%.8g"));
    ledFormat2->lenText->setText(QString(sformat));
    ledTitle=new stdLineEdit(grpTitle,tr("Title:"));
    ledTitle->lenText->setText(tr("A fit"));

    selCompress=new CompressionSelector(this);
    selCompress->cmbCompression->lblText->setText(tr("Data compression:"));
    selCompress->cmbCompression->setToolTip(tr("Set the compression method used for the data in the project file.\nWarning: Using compression breaks compatibility with the original Grace and previous versions of QtGrace."));
    selCompress->selComprLevel->lblText->setText(tr("Compression Level:"));
    selCompress->selComprLevel->setToolTip(tr("A level of '-1' means the default compression level of the compression method.\nHigher values mean higher compression but take more time.\nValues of 2 or 3 seem most suitable for data in project files."));
    if (type!=WRITE_PROJECT_FORM)
    {
    selCompress->setVisible(false);
    }

    //ledSelection=new QLineEdit(tr(""),this);
    ledSelection=new stdLineEdit(this,tr(""));
    ledSelection->setToolTip(tr("Selected file (including path)"));
    ledSelection->lblText->setVisible(false);
    //ledSelection->layout->setMargin(0);
    ledSelection->layout->setContentsMargins(0,0,0,0);
    ledSelection->layout->setSpacing(0);
    ledSelection->setAcceptDrops(true);
    connect(ledSelection,SIGNAL(changed()),SLOT(newFileEnteredManually()));
    connect(ledSelection->lenText,SIGNAL(returnPressed()),SLOT(newFileEnteredManually()));

    txtDescription=new QTextEdit(this);
    lblProjectContent=new QLabel(QString("--"),this);

    number=2;
    entr[0]=tr("Current");
    entr[1]=tr("All");
    selParamGraph=new StdSelector(grpRead,tr("Write parameters from graph:"),number,entr);

    number=3;
    entr[0]=tr("Single set");
    entr[1]=tr("NXY");
    entr[2]=tr("Block data");
    selLoadAs=new StdSelector(grpRead,tr("Load as:"),number,entr);

    number=4;
    entr[0]=tr("None");
    entr[1]=tr("X");
    entr[2]=tr("Y");
    entr[3]=tr("XY");
    selAutoscale=new StdSelector(grpRead,tr("Autoscale on read:"),number,entr);
    selAutoscale->setCurrentIndex(3);

    number=NUMBER_OF_SETTYPES;
    for (int i=0;i<number;i++)
    {
        strToUpper(dummy,set_types(i));
        entr[i]=QString(dummy);
    }
    selType=new StdSelector(grpRead,tr("Type:"),number,entr);

    radPipe=new QRadioButton(tr("Pipe"),grpRead);
    radDisk=new QRadioButton(tr("Disk"),grpRead);
    radDisk->setChecked(TRUE);

    graphList=new uniList(GRAPHLIST,grpRead);
    setList=new uniList(SETLIST,grpWrite);

    number=1;
    entr[0]=tr("G0");
    selExportGraph=new StdSelector(this,tr("Graph:"),number,entr);
    selExportGraph->simple_graph_selector=true;
    selExportGraph->include_NONE=false;
    selExportGraph->setVisible(false);
    chkWriteWav=NULL;
    //Specials for Binary-File-Interaction
    if (type==READ_BINARY_FILE || type==WRITE_BINARY_FILE)
    {
        chkWriteWav=new QCheckBox(tr("Write set(s) in wav-file"),this);
        connect(chkWriteWav,SIGNAL(stateChanged(int)),this,SLOT(writeWavToggled(int)));
        grpBinary=new QGroupBox(tr("Binary conversion"),this);
        layout6=new QGridLayout;
        //layout6->setMargin(STD_MARGIN);
        layout6->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
        chkHeader=new QCheckBox(tr("Header"),this);
        connect(chkHeader,SIGNAL(stateChanged(int)),SLOT(headerChecked(int)));
        layout6->addWidget(chkHeader,0,0,1,2);
        selHeaderLength=new stdIntSelector(this,tr("Length of header in bytes:"),0,100000);
        layout6->addWidget(selHeaderLength,1,0,1,2);
        selHeaderLength->setEnabled(false);
        selTotalColumnNumber=new stdIntSelector(this,tr("Number of data Columns:"),1,200);
        layout6->addWidget(selTotalColumnNumber,2,0,1,2);
        selector_count=5;
        selTotalColumnNumber->setValue(selector_count);
        connect(selTotalColumnNumber->spnInt,SIGNAL(valueChanged(int)),this,SLOT(columnCountChanged(int)));
        selColFormats=new StdSelector*[selector_count];
        selImportTo=new StdSelector*[selector_count];
        selColSize=new QSpinBox*[selector_count];
        number=NUMBER_OF_COLUMN_FORMATS;
        for (int i=0;i<number;i++)
        {
            entr[i]=QString(binaryImportFormatName[i]);
            values[i]=binaryImportFormat[i].format;
        }
        layout7=new QGridLayout;
        //layout7->setMargin(STD_MARGIN);
        layout7->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
        layout7->setSpacing(STD_SPACING);
        lblFormat=new QLabel(tr("Column format:"),this);
        lblBytes=new QLabel(tr("Bytes:"),this);
        lblImport=new QLabel(tr("Import to:"),this);
        layout7->addWidget(lblFormat,0,0,1,1);
        layout7->addWidget(lblBytes,0,1,1,1);
        layout7->addWidget(lblImport,0,2,1,1);
        empty=new QWidget;
        number2=3;
        entr2[0]=QString("None");
        entr2[1]=QString("X");
        entr2[2]=QString("Y");
        offset2=1;
        for (int i=0;i<selector_count;i++)
        {
            sprintf(dummy,"%d:",i);
            selColFormats[i]=new StdSelector(this,QString(dummy),number,entr);
            selColFormats[i]->setValues(values);
            selImportTo[i]=new StdSelector(this,QString(""),number2,entr2);
            selImportTo[i]->lblText->setVisible(false);
            selColSize[i]=new QSpinBox(this);
            selColSize[i]->setMinimum(1);
            selColSize[i]->setMaximum(5000);
            layout7->addWidget(selColFormats[i],offset2,0,1,1);
            layout7->addWidget(selColSize[i],offset2,1,1,1);
            layout7->addWidget(selImportTo[i],(offset2++),2,1,1);
        }
        area=new QScrollArea;
        area->setWidget(empty);
        empty->setGeometry(0,0,320,180);
        empty->setLayout(layout7);
        layout6->addWidget(area,3,0,1,2);
        chkImportToEOF=new QCheckBox(tr("Import until EOF"),this);
        connect(chkImportToEOF,SIGNAL(stateChanged(int)),SLOT(readUntilEOFChecked(int)));
        layout6->addWidget(chkImportToEOF,4,0,1,2);
        selMaxImportData=new stdIntSelector(this,tr("Max number of data sets to import:"),1,500000);
        selMaxImportData->setValue(1000);
        layout6->addWidget(selMaxImportData,5,0,1,2);
        grpBinary->setLayout(layout6);
        grpBinary->setVisible(false);
    }

    cmdOK=new QPushButton(tr("OK"),this);
    connect(cmdOK,SIGNAL(clicked()),SLOT(doOK()));
    cmdFilter=new QPushButton(tr("Filter"),this);
    connect(cmdFilter,SIGNAL(clicked()),SLOT(doFilter()));
    cmdCancel=new QPushButton(tr("Cancel"),this);
    connect(cmdCancel,SIGNAL(clicked()),SLOT(doCancel()));
    cmdHelp=new QPushButton(tr("Help"),this);
    connect(cmdHelp,SIGNAL(clicked()),SLOT(doHelp()));

    cmdOK->setDefault(false);
    cmdFilter->setDefault(false);
    cmdCancel->setDefault(false);
    cmdHelp->setDefault(false);

    cmdOK->setAutoDefault(false);
    cmdFilter->setAutoDefault(false);
    cmdCancel->setAutoDefault(false);
    cmdHelp->setAutoDefault(false);

    chkExchangeCommaPoint=new QCheckBox(tr("Use ',' instead of '.' as decimal seperator"),this);

    layout1=new QGridLayout;
    //layout1->setMargin(STD_MARGIN);
    layout1->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout1->addWidget(lblReadGraph,0,0,1,4);
    layout1->addWidget(graphList,1,0,1,4);
    layout1->addWidget(selLoadAs,2,0,1,2);
    layout1->addWidget(selType,2,2,1,2);
    layout1->addWidget(lblDataSource,3,0,1,2);
    layout1->addWidget(radDisk,3,2);
    layout1->addWidget(radPipe,3,3);
    layout1->addWidget(selAutoscale,4,0,1,4);
    layout1->addWidget(chkExchangeCommaPoint,5,0,1,4);
    grpRead->setLayout(layout1);

    layout2=new QVBoxLayout;
    //layout2->setMargin(STD_MARGIN);
    layout2->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout2->addWidget(lblWriteSet);
    layout2->addWidget(selExportGraph);
    layout2->addWidget(setList);
    if (chkWriteWav!=NULL)
    layout2->addWidget(chkWriteWav);
    layout2->addWidget(ledFormat);
    grpWrite->setLayout(layout2);

    layout3=new QVBoxLayout;
    //layout3->setMargin(STD_MARGIN);
    layout3->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout3->addWidget(lblDescription);
    layout3->setAlignment(lblDescription,Qt::AlignHCenter);
    layout3->addWidget(txtDescription);
    layout3->addWidget(lblProjectContent);
    lblProjectContent->hide();
    layout3->addWidget(ledFormat2);
    layout3->addWidget(selCompress);
    grpDescription->setLayout(layout3);

    layout4=new QVBoxLayout;
    //layout4->setMargin(STD_MARGIN);
    layout4->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout4->addWidget(ledTitle);
    grpTitle->setLayout(layout4);

    layout5=new QVBoxLayout;
    //layout5->setMargin(STD_MARGIN);
    layout5->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout5->addWidget(selParamGraph);
    grpParamGraph->setLayout(layout5);

    layout=new QGridLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);

    selector=new FileSelector(this);
    connect(selector,SIGNAL(newSelection(QString)),SLOT(gotNewSelection(QString)));
    connect(selector,SIGNAL(newSelectionDoubleClick(QString)),SLOT(gotNewSelectionDoubleClick(QString)));
    connect(selector,SIGNAL(newSelectionManually()),SLOT(newFileEnteredManually()));

    layout->addWidget(selector,0,0,1,4);
        if (chkWriteWav!=NULL)
        chkWriteWav->setVisible(false);
    switch (type)
    {
    case READ_SET_FORM:
        setWindowTitle(tr("QtGrace: Read sets"));
        stdExtension=QString("*.dat");
        layout->addWidget(grpRead,6,0,1,4);
        offset=1;
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=true;
        break;
    case READ_NETCDF_FORM:
        setWindowTitle(tr("QtGrace: Select netCDF file"));
        stdExtension=QString("*.nc");
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=true;
        break;
    case READ_PROJECT_FORM:
        setWindowTitle(tr("QtGrace: Open project"));
        /*agrInfo=new frmAgrInfos(this);
        agrInfo->setVisibleItems(false,false);
        agrInfo->setInfoVisible(false);
        layout->addWidget(agrInfo,6,0,1,4);
        layout->setRowStretch(6,1);
        layout->setRowStretch(1,3);*/
        offset=2;
        stdExtension=QString("*.agr");
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        //grpDescription->setVisible(FALSE);

lblProjectContent->setVisible(TRUE);
grpDescription->setVisible(TRUE);//I changed this!!
//grpDescription->setEnabled(FALSE);//I changed this!!
layout->addWidget(grpDescription,6,0,1,4);//I added this!!
txtDescription->setReadOnly(true);
ledFormat2->setVisible(false);

        cmdOpenSetImport=new QPushButton(tr("Open set extraction dialog"),this);
        cmdOpenSetImport->setToolTip(tr("Open file in set extraction dialog.\nThis allows you to import just singular sets from a project file."));
        connect(cmdOpenSetImport,SIGNAL(clicked()),SLOT(doOpenSetImport()));
        layout->addWidget(cmdOpenSetImport,6+1,0,1,4);

        cmdOpenSetImport->setDefault(false);
        cmdOpenSetImport->setAutoDefault(false);

        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=true;
        break;
    case WRITE_SET_FORM:
        setWindowTitle(tr("QtGrace: Write sets"));
        stdExtension=QString("*.dat");
        grpWrite->setTitle(tr("Write set(s):"));
        grpWrite->setVisible(TRUE);
        lblWriteSet->setVisible(FALSE);
        layout->addWidget(grpWrite,6,0,1,4);
        offset=1;
        selExportGraph->setVisible(TRUE);
        grpRead->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=false;
        connect(selExportGraph,SIGNAL(currentIndexChanged(int)),SLOT(exportGraphChanged(int)));
        break;
    case WRITE_PROJECT_FORM:
        setWindowTitle(tr("QtGrace: Save project"));
        stdExtension=QString("*.agr");
        layout->addWidget(grpDescription,6,0,1,4);
        offset=1;
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=false;
        break;
    case SELECT_HOT_LINK_FILE:
        setWindowTitle(tr("QtGrace: Select hot link file"));
        stdExtension=QString("*.dat");
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=true;
        break;
    case READ_PARAMETERS:
        setWindowTitle(tr("QtGrace: Read parameters"));
        stdExtension=QString("*.par");
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=true;
        break;
    case WRITE_PARAMETERS:
        setWindowTitle(tr("QtGrace: Write parameters"));
        stdExtension=QString("*.par");
        layout->addWidget(grpParamGraph,6+offset,0,1,4);
        offset=1;
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(TRUE);
        selector->forRead=false;
        break;
    case SELECT_PRINT_FILE:
        setWindowTitle(tr("QtGrace: Select print file"));
        stdExtension=QString("*.dat");
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=false;
        break;
    case READ_FIT_PARAM:
        setWindowTitle(tr("QtGrace: Open fit parameter file"));
        stdExtension=QString("*.fit");
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=true;
        break;
    case WRITE_FIT_PARAM:
        setWindowTitle(tr("QtGrace: Save fit parameter file"));
        stdExtension=QString("*.fit");
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        layout->addWidget(grpTitle,6+offset,0,1,4);
        grpTitle->setVisible(TRUE);
        grpParamGraph->setVisible(FALSE);
        offset=1;
        selector->forRead=false;
        break;
    case READ_BINARY_FILE:
        setWindowTitle(tr("QtGrace: Read binary file"));
        stdExtension=QString("*.dat");
        layout->addWidget(grpRead,6,0,1,2);
        layout->addWidget(grpBinary,6,2,1,2);
        grpBinary->setVisible(true);
        offset=1;
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=true;
        connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(setTypeChanged(int)));
        setTypeChanged(0);
        selTotalColumnNumber->setValue(2);
        selColFormats[0]->setCurrentIndex(10);
        selColFormats[1]->setCurrentIndex(10);
        selImportTo[0]->setCurrentIndex(1);
        selImportTo[1]->setCurrentIndex(2);
        chkImportToEOF->setChecked(true);
        break;
    case WRITE_BINARY_FILE:
        setWindowTitle(tr("QtGrace: Write binary file"));
        stdExtension=QString("*.dat");
        layout->addWidget(grpWrite,6,0,1,4);
        offset=1;
        selExportGraph->setVisible(TRUE);
        grpRead->setVisible(FALSE);
        grpBinary->setVisible(FALSE);
        ledFormat->setVisible(false);
        setList->setBehavior(true,false,false);
        grpWrite->setTitle(tr("Write set:"));
        grpWrite->setVisible(TRUE);
        lblWriteSet->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=false;
        chkWriteWav->setVisible(true);
        connect(selExportGraph,SIGNAL(currentIndexChanged(int)),SLOT(exportGraphChanged(int)));
        break;
    }
    layout->addWidget(lblSelection,6+offset,0,1,4);
    layout->addWidget(ledSelection,7+offset,0,1,4);
    layout->addWidget(cmdOK,8+offset,0);
    layout->addWidget(cmdFilter,8+offset,1);
    layout->addWidget(cmdCancel,8+offset,2);
    layout->addWidget(cmdHelp,8+offset,3);
    setLayout(layout);
    QString cdir=QString(get_workingdir());
    cdir.chop(1);
    selector->setFilterFromExtern(cdir,stdExtension);

    switch (formType)
    {
    case READ_SET_FORM:
    resize(LastSize_FormReadSets);
    break;
    case READ_NETCDF_FORM:
    resize(LastSize_FormReadNetCDF);
    break;
    case READ_PROJECT_FORM:
    resize(LastSize_FormOpenProject);
    break;
    case WRITE_SET_FORM:
    resize(LastSize_FormWriteSets);
    break;
    case WRITE_PROJECT_FORM:
    resize(LastSize_FormSaveProject);
    break;
    case SELECT_HOT_LINK_FILE:
    resize(LastSize_FormSelectHotLink);
    break;
    case READ_PARAMETERS:
    resize(LastSize_FormReadParameters);
    break;
    case WRITE_PARAMETERS:
    resize(LastSize_FormWriteParameters);
    break;
    case SELECT_PRINT_FILE:
    resize(LastSize_FormSelectOutputFile);
    break;
    case READ_FIT_PARAM:
    resize(LastSize_FormOpenFitPara);
    break;
    case WRITE_FIT_PARAM:
    resize(LastSize_FormSaveFitPara);
    break;
    case READ_BINARY_FILE:
    resize(LastSize_FormReadBinary);
    break;
    case WRITE_BINARY_FILE:
    resize(LastSize_FormWriteBinary);
    break;
    default:
    resize(LastSize_FormIOForm);
    break;
    }

}

frmIOForm::~frmIOForm()
{
    switch (formType)
    {
    case READ_SET_FORM:
    LastSize_FormReadSets=this->size();
    break;
    case READ_NETCDF_FORM:
    LastSize_FormReadNetCDF=this->size();
    break;
    case READ_PROJECT_FORM:
    LastSize_FormOpenProject=this->size();
    break;
    case WRITE_SET_FORM:
    LastSize_FormWriteSets=this->size();
    break;
    case WRITE_PROJECT_FORM:
    LastSize_FormSaveProject=this->size();
    break;
    case SELECT_HOT_LINK_FILE:
    LastSize_FormSelectHotLink=this->size();
    break;
    case READ_PARAMETERS:
    LastSize_FormReadParameters=this->size();
    break;
    case WRITE_PARAMETERS:
    LastSize_FormWriteParameters=this->size();
    break;
    case SELECT_PRINT_FILE:
    LastSize_FormSelectOutputFile=this->size();
    break;
    case READ_FIT_PARAM:
    LastSize_FormOpenFitPara=this->size();
    break;
    case WRITE_FIT_PARAM:
    LastSize_FormSaveFitPara=this->size();
    break;
    case READ_BINARY_FILE:
    LastSize_FormReadBinary=this->size();
    break;
    case WRITE_BINARY_FILE:
    LastSize_FormWriteBinary=this->size();
    break;
    default:
    LastSize_FormIOForm=this->size();
    break;
    }
}

void frmIOForm::gotNewSelection(QString selection)
{
static bool function_running=false;
QFileInfo FileInf(ledSelection->lenText->text());
QString old_filename=FileInf.fileName();
//qDebug() << "OldSelection=" << ledSelection->lenText->text();
FileInf=QFileInfo(selection);
if (FileInf.fileName().isEmpty())
ledSelection->lenText->setText(QDir::toNativeSeparators(selection+old_filename));
else
ledSelection->lenText->setText(QDir::toNativeSeparators(selection));
if (function_running==true) return;
function_running=true;
//qDebug() << "gotNewSelection=" << selection;
/// selector->setFileSelectionFromExtern(selection);
    if (formType!=READ_PROJECT_FORM) return;
char * filename=new char[selection.toLocal8Bit().length()+8];
strcpy(filename,selection.toLocal8Bit().constData());
//struct agr_file_info afi;
//qDebug() << "new File=" << filename << " isAGR=" << is_agr_file(filename);
    if (is_agr_file(filename))
    {
        if (Form_AgrInfo==NULL)
        {
        Form_AgrInfo=new frmAgrInfos(0);
        //Form_AgrInfo->setWindowTitle(QString("QtGrace: ")+QObject::tr("Import set(s) from agr-file"));
        Form_AgrInfo->hide();
        }
    Form_AgrInfo->init(filename);
    txtDescription->setText(Form_AgrInfo->info.project_description);
    lblProjectContent->setText(tr("Project contains: ")+QString::number(Form_AgrInfo->info.nr_of_graphs)+tr(" Graph(s) and ")+QString::number(Form_AgrInfo->info.nr_of_sets)+tr(" Set(s)"));
        if (Form_AgrInfo->info.nr_of_sets>0)
        cmdOpenSetImport->setEnabled(true);
        else
        cmdOpenSetImport->setEnabled(false);
    }
    else//not an agr-file
    {
    txtDescription->clear();
    lblProjectContent->setText(tr("No project file."));
    cmdOpenSetImport->setEnabled(false);
    }
    //newFileEnteredManually();
delete[] filename;
    function_running=false;
    /*QFileInfo fi1(selection);
    QString suffix=fi1.completeSuffix();
    QString path_only=fi1.path();
    selector->setFilterFromExtern(path_only,suffix);*/
/// selector->setFileSelectionFromExtern(selection);
}

void frmIOForm::gotNewSelectionDoubleClick(QString selection)
{
    gotNewSelection(selection);
    doOK();
}

void frmIOForm::init(char * f_name)
{
QString f_name2;
f_name2=QString::fromLocal8Bit(f_name);
/*qDebug() << "frmIOForm:    f_name =" << f_name << "(" << (f_name==NULL?"==":"!=") << "NULL )";
qDebug() << "frmIOForm: local8bit =" << f_name2;
qDebug() << "Working dir=" << QString::fromLocal8Bit(get_workingdir());*/
int ret;
if (formType==WRITE_PROJECT_FORM || formType==WRITE_SET_FORM)
{
ret=is_valid_format_specifier(sformat);
if (ret==0)//invalid
{
format_specifier_error(sformat);
strcpy(sformat,grace_sformat);
}
strcpy(sav_sformat,sformat);//save setting for resetting later
    ledFormat->lenText->setText(QString(sformat));
    ledFormat2->lenText->setText(QString(sformat));
}
        if (formType==WRITE_PROJECT_FORM)
        {
        txtDescription->setText(get_project_description());
        selCompress->init(default_compress_data,default_compression_level);
        }
        if (formType==READ_PROJECT_FORM)
        {
        cmdOpenSetImport->setEnabled(false);
        }
selFileInfo.setFile(f_name2);
//selFileInfo.setFile(f_name);
    if (f_name==NULL)
    {
    //selFileInfo.setFile(get_workingdir());
    selFileInfo.setFile(Last_Dialog_Path[formType]);
    f_name2=Last_Dialog_Path[formType];
//qDebug() << "f_name=NULL: f_name2=" << f_name2;
    }
QString a,b;
    if (f_name==NULL)
    {
    //selectedFile=QString("");
    selectedFile=Last_Dialog_Path[formType];
//qDebug() << "f_name=NULL: selectedFile=" << selectedFile;
    }
    else
    {
    selectedFile=f_name2;
    //selectedFile=QString(f_name);
    a=selFileInfo.absoluteDir().absolutePath();
    if (!selFileInfo.suffix().isEmpty())
    b=QString("*.")+selFileInfo.suffix();
    else
    b=QString("*.agr");//+selFileInfo.suffix();
    /// selector->setFilterFromExtern(a,b);
    selector->setFileSelectionFromExtern(selectedFile);
    /*qDebug() << "path=" << a.toLatin1() << endl;
    qDebug() << "extension=" << b.toLatin1() << endl;*/
    }
    if (formType==WRITE_FIT_PARAM || formType==READ_FIT_PARAM)
    {
    selector->filterExtension=QString("*.fit");
    }
/*qDebug() << "selectedFile=" << selectedFile;
qDebug() << "selFileInfo=" << selFileInfo.fileName();*/

    /*
    selector->ledFilter->setText(QDir::toNativeSeparators(selector->currentDir).toLocal8Bit()+selector->separator+selector->filterExtension);
    ledSelection->setText(QDir::toNativeSeparators(selector->currentDir).toLocal8Bit()+selector->separator);
        if (selFileInfo.isFile())
        ledSelection->setText(QDir::toNativeSeparators(selector->currentDir).toLocal8Bit()+selector->separator+selFileInfo.fileName().toLocal8Bit());
    */
    selector->ledFilter->setPlainText(QDir::toNativeSeparators(selector->currentDir)+selector->separator+selector->filterExtension);
    ledSelection->setPlainText(QDir::toNativeSeparators(selector->currentDir)+selector->separator);
        if (selFileInfo.isFile())
        ledSelection->setPlainText(QDir::toNativeSeparators(selector->currentDir)+selector->separator+selFileInfo.fileName());

/*qDebug() << "Set1=" << selector->ledFilter->text();
qDebug() << "Set2=" << ledSelection->text();*/

    graphList->update_number_of_entries();
    setList->update_number_of_entries();
    int gno=get_cg();
    graphList->set_new_selection(1,&gno);
    if (formType==WRITE_BINARY_FILE || formType==WRITE_SET_FORM)
    {
    int number=number_of_graphs();
    QString * entr=new QString[2+number];
    int *entr_v=new int[2+number];
        for (int i=0;i<number;i++)
        {
        entr[i]=QString("G")+QString::number(i);
        entr_v[i]=i;
        }
    selExportGraph->setNewEntries(number,entr,entr_v);
    selExportGraph->setCurrentValue(gno);
    delete[] entr;
    delete[] entr_v;
    }

ledSelection->lenText->setFocus(Qt::MouseFocusReason);
}

void frmIOForm::exportGraphChanged(int g)
{
    (void)g;
setList->set_graph_number(selExportGraph->currentValue(),false);
setList->update_number_of_entries();
}

void frmIOForm::doOK(void)
{
    static char dummy[512];
    int gno, setno, ret;
    int *selset=new int[5], cd, i;
    int graphno,cursource;
    char filename[GR_MAXPATHLEN];
    bool end_now=false;
    strcpy(sav_sformat,sformat);
    selectedFile=ledSelection->text();
    if (radPipe->isChecked()==true)
        cursource=1;
    else
        cursource=0;
    autoscale_onread = GetOptionChoice(selAutoscale);
    QFile fileTest(selectedFile);
    QFileInfo fileInfo(fileTest);

    if (fileInfo.isFile()==false)
    {
        FileExists=false;
        isWriteable=false;
        isReadable=false;
    }
    else
    {
        FileExists=fileTest.exists();
        isWriteable=fileInfo.isWritable();
        isReadable=fileInfo.isReadable();
    }

    //strcpy(filename,selectedFile.toLocal8Bit());//ascii-only
    QString encodedString(QFile::encodeName(selectedFile));//should work with unicode-characters as well
    strcpy(filename,encodedString.toLocal8Bit().constData());

/*
QMessageBox::information(this,"selected File",selectedFile);
QString nonUniCodeFile=QString(FileCodec->fromUnicode(selectedFile));
strcpy(filename,nonUniCodeFile.toLocal8Bit().constData());
QMessageBox::information(this,"nonUniCodeFile",nonUniCodeFile);
QString recon=FileCodec->toUnicode(filename);//so geht's, wenn die richtige Kodierung eingestellt wurde!
QMessageBox::information(this,"recon",recon);
QMessageBox::information(this,"encoded",encodedString);
*/

    exchange_point_comma=chkExchangeCommaPoint->isChecked();

    //if (FileExists && (formType==WRITE_SET_FORM || formType==WRITE_BINARY_FILE))
    if (FileExists && (formType==WRITE_BINARY_FILE))//for write_set_form_ grace-function will ask for overwrite
    {
        int ret=QMessageBox::question(this,tr("Warning!"),tr("File exists!\nOverwrite?"),QMessageBox::Ok,QMessageBox::Cancel);
        if (ret==QMessageBox::Cancel)
        {
            delete[] selset;
            exchange_point_comma=false;
            return;
        }
    }
Last_Dialog_Path[formType]=QDir::toNativeSeparators(fileInfo.absolutePath());
    if (formType==READ_SET_FORM)
    {
        set_wait_cursor();
        int load = GetOptionChoice(selLoadAs);
        if (cursource==1)//source=pipe
        {//we load from a pipe here
            int fd;
            if (openPipe(filename,&fd)!=RETURN_SUCCESS)
                errmsg(tr("Unable to open pipe!").toLocal8Bit().constData());
            mainWin->checkForRealTimeIO();
            goto end_fromIOFormOK;
        }

        if (GetSingleListChoice(graphList, &graphno) != RETURN_SUCCESS) {
            errmsg(tr("Please select a single graph!").toLocal8Bit().constData());
        } else {

            if (load == LOAD_SINGLE)
            {
                curtype = GetOptionChoice(selType);
            }

            if (new_set_nos!=NULL)
            {
                delete[] new_set_nos;
                new_set_nos=NULL;
            }
            new_set_no=0;
            //cout << "A3 " << graphno << " " << filename << " " << cursource << " " << load << endl;

            prepare_strings_for_saving();
            getdata(graphno, filename, cursource, load);
            resume_strings_after_load_or_save();

            if (selLoadAs->currentIndex()==2)//Block data
            {
                if (frmEdBlock==NULL)
                {
                    frmEdBlock=new frmEditBlockData(mainWin);
                }
                frmEdBlock->filename=QString(filename);
                set_block_origin(filename);
                frmEdBlock->source=cursource;
                frmEdBlock->init();
                frmEdBlock->selAutoscale->setCurrentIndex(autoscale_onread);
                frmEdBlock->show();
                frmEdBlock->raise();
            }
            else if (cursource==0)//source=file
            {
                ///Undo-Stuff
                if (new_set_no==1)//only one new set
                {
                    set_set_hidden(graphno,new_set_nos[0],FALSE);
                    SetImported(graphno,new_set_nos[0],filename,cursource,load,autoscale_onread);
                }
                else if (new_set_no>1)//more than one set imported
                {
                    int * gnos=new int[new_set_no+2];
                    char ** filenames=new char *[2];
                    for (int i=0;i<new_set_no;i++)
                    {
                        gnos[i]=graphno;
                        set_set_hidden(graphno,new_set_nos[i],FALSE);
                    }
                    filenames[0]=new char[2+strlen(filename)];
                    strcpy(filenames[0],filename);
                    SetsImported(new_set_no,gnos,new_set_nos,1,filenames,cursource,load,autoscale_onread);
                    delete[] filenames[0];
                    delete[] filenames;
                    delete[] gnos;
                }
                mainWin->mainArea->completeRedraw();
            }
            /*else
        {
        mainWin->checkForRealTimeIO();
        }*/
            update_default_props();
        }
    }
    else if (formType==WRITE_SET_FORM)
    {
        set_wait_cursor();
        char format[32];
        FILE *cp;
        cp = grace_openw(filename);//overwrite? yes/no
        if (cp == NULL) {
            return;
        }
        cd = GetListChoices(setList, &selset);
        if (cd < 1) {
            errmsg(tr("No set selected!").toLocal8Bit().constData());
        } else {
            gno = selExportGraph->currentValue();//get_cg();
            strncpy(format, xv_getstr(ledFormat), 31);
            format[31]='\0';
            ret=is_valid_format_specifier(format);
            if (ret==0)//invalid
            {
            format_specifier_error(format);
            strcpy(format,grace_sformat);
            }
            for(i = 0; i < cd; i++)
            {
                setno = selset[i];
                write_set(gno, setno, cp, format, TRUE, TRUE);
            }
        }
        grace_close(cp);
    strcpy(sformat,sav_sformat);//reset the data-format
    }
    else if (formType==READ_BINARY_FILE)
    {
        set_wait_cursor();
        if (!FileExists || !isReadable)
        {
            errmsg((tr("File ")+QString(filename)+tr(" does not exist or is unreadable!")).toLocal8Bit().constData());
            unset_wait_cursor();
            return;
        }
        struct BinReadInstructions inst;

        autoscale_onread = GetOptionChoice(selAutoscale);

        if (GetSingleListChoice(graphList, &graphno) != RETURN_SUCCESS) {
            errmsg(tr("Please select a single graph!").toLocal8Bit().constData());
        }else{
            setno=nextset(graphno);
            int curtype = GetOptionChoice(selType);
            int number_of_cols = settype_cols(curtype);

            if (chkHeader->isChecked())
                inst.length_of_header=selHeaderLength->value();
            else
                inst.length_of_header=0;

            inst.column_count=selTotalColumnNumber->value();
            inst.read_until_end_is_reached=chkImportToEOF->isChecked();
            inst.datasets_to_read=selMaxImportData->value();

            inst.col_numbers_to_read=new int[number_of_cols];
            for (int i=0;i<number_of_cols;i++)
                inst.col_numbers_to_read[i]=-1;//invalid number
            inst.column_type=new struct ColumnFormat[inst.column_count];//format of all columns
            inst.n_columns_to_read=number_of_cols;

            for (unsigned int i=0;i<inst.column_count;i++)
            {
                inst.column_type[i].format=selColFormats[i]->currentValue();
                inst.column_type[i].size=selColSize[i]->value();
                if (selImportTo[i]->currentValue()>=0 && selImportTo[i]->currentValue()<number_of_cols)
                    inst.col_numbers_to_read[selImportTo[i]->currentValue()]=i;
            }
            //checking entries
            int ok=-1;
            for (int i=0;i<number_of_cols;i++)
            {
                //cout << dataset_colname(i) << "=" << inst.col_numbers_to_read[i] << endl;
                if (inst.col_numbers_to_read[i]==-1){ok=i;break;}
            }
            if (ok>-1)
            {
                sprintf(dummy,"%s%s%s",tr("Please select an import-column for every set-column! Column ").toLocal8Bit().constData(),dataset_colname(ok),tr(" is missing!").toLocal8Bit().constData());
                errmsg(dummy);
            }
            else
            {
                ok=-1;
                for (unsigned int i=0;i<inst.column_count;i++)
                {
                    if (selImportTo[i]->currentValue()==-1) continue;
                    for (unsigned int j=i+1;j<inst.column_count;j++)
                    {
                        if (selImportTo[i]->currentValue()==selImportTo[j]->currentValue())
                        {
                            ok=selImportTo[i]->currentValue();
                            i=inst.column_count;
                            break;
                        }
                    }
                }
                if (ok>-1)
                {
                    sprintf(dummy,"%s%s%s",tr("Import-column for ").toLocal8Bit().constData(),dataset_colname(ok),tr(" is ambiguous! Binary import aborted!").toLocal8Bit().constData());
                    errmsg(dummy);
                }
                else
                {
                    LoadBinaryData(graphno,setno,selType->currentValue(),filename,inst);
                    autoscale_graph(graphno, autoscale_onread);
                    mainWin->mainArea->completeRedraw();
                }
            }
            delete[] inst.column_type;
            delete[] inst.col_numbers_to_read;
        }
    }
    else if (formType==WRITE_BINARY_FILE)
    {
        set_wait_cursor();
        cd = GetListChoices(setList, &selset);
        gno = selExportGraph->currentValue();
        if (cd < 1)
        {
            errmsg(tr("No set selected!").toLocal8Bit().constData());
        }
        else
        {
            if (chkWriteWav->isChecked()==true)
            {
            int * selgnos=new int[cd+2];
            for (int jkl=0;jkl<cd;jkl++) selgnos[jkl]=gno;
                if (cd>2)
                {
                errmsg(tr("More than two sets selected! Only the Y-values of the first two sets will be written into wav-file (stereo).").toLocal8Bit().constData());
                }
            write_data_as_wav(filename,cd,selgnos,selset);
            delete[] selgnos;
            }
            else
            {
            plotarr pa;
            get_graph_plotarr(gno, selset[0], &pa);
            ofstream ofi;
            ofi.open(filename,ios::binary);
            unsigned int channels=dataset_cols(gno,selset[0]);
            unsigned int len=pa.data.len;
            ofi.write((char*)((void*)&channels),sizeof(unsigned int));
            ofi.write((char*)((void*)&len),sizeof(unsigned int));
            for (unsigned int i=0;i<channels;i++)
            {
                for (unsigned int j=0;j<len;j++)
                {
                    ofi.write((char*)((void*)(pa.data.ex[i]+j)),sizeof(double));
                }
            }
            ofi.close();
            }
        }
    }
    else
    {
        if (formType==WRITE_PROJECT_FORM)
        {
            current_compression_method=selCompress->method();
            current_compression_level=selCompress->level();
            strncpy(sformat, xv_getstr(ledFormat2), 31);
            sformat[31]='\0';
            ret=is_valid_format_specifier(sformat);
            if (ret==0)//invalid
            {
            format_specifier_error(sformat);
            strcpy(sformat,grace_sformat);
            }
            QString nDescr=txtDescription->toPlainText();
            char * neDescr=new char[2+nDescr.length()];
            strcpy(neDescr,nDescr.toLocal8Bit().constData());
            set_project_description(neDescr);
            delete[] neDescr;
        }
//qDebug() << "io-doOK A1, futur_load_status=" << mainWin->future_load_status;//==3?
        if (mainWin->future_load_status==3) end_now=true;
        emit(newFileSelectedForIO(formType,selectedFile,FileExists,isWriteable,isReadable));
//qDebug() << "io-doOK A2, futur_load_status=" << mainWin->future_load_status;//==3?
        if (end_now)//problematic state, everything should be gone by now, just finish as soon as possible
        {
        //qDebug() << "using END_NOW";
        delete[] selset;
        return;
        }
    }

    if (formType==WRITE_PROJECT_FORM || formType==WRITE_BINARY_FILE || formType==WRITE_SET_FORM)
    {
//qDebug() << "io-doOK B";
    newFileEnteredManually();//to update the list of files
//qDebug() << "io-doOK C";
    }
end_fromIOFormOK:
    exchange_point_comma=false;
//qDebug() << "io-doOK D";
    unset_wait_cursor();
//qDebug() << "io-doOK E";
    //doFilter();
    delete[] selset;
}

void frmIOForm::doFilter(void)
{
/// cout << "Filter pressed" << endl;
    selector->newFilterEntered();
}

void frmIOForm::doCancel(void)
{
    if (formType==WRITE_PROJECT_FORM || formType==WRITE_SET_FORM)
    strcpy(sformat,sav_sformat);

    if (formType==WRITE_PROJECT_FORM && mainWin->future_load_status!=0)
    {
        if (mainWin->future_load_status==1 || mainWin->future_load_status==2)
        {
        errmsg(tr("Saving cancelled, Load-operation cancelled.").toLocal8Bit().constData());
        mainWin->future_load_status=0;
        }
        else if (mainWin->future_load_status==3)
        {
        errmsg(tr("Saving cancelled, Close-operation cancelled.").toLocal8Bit().constData());
        mainWin->future_load_status=0;
        }
    }
hide();
}

void frmIOForm::doHelp(void)
{
    HelpCB("doc/UsersGuide.html#FS-dialog");
}

void frmIOForm::doOpenSetImport(void)
{
    if (Form_AgrInfo==NULL)
    {
    Form_AgrInfo=new frmAgrInfos(0);
    Form_AgrInfo->hide();
    }
char * filename=new char[ledSelection->text().length()+8];
strcpy(filename,ledSelection->text().toLocal8Bit().constData());
    if (is_agr_file(filename)==TRUE)
    {
    Form_AgrInfo->init(filename);
    /*Form_AgrInfo->show();
    Form_AgrInfo->raise();
    Form_AgrInfo->activateWindow();*/
    Form_AgrInfo->exec();
    }
    else
    {
    errmsg(tr("Selected file is not a project file.").toLocal8Bit().constData());
    }
delete[] filename;
}

void frmIOForm::newFileEnteredManually(void)
{
QString text=ledSelection->lenText->text();
QFileInfo fi(text);
//qDebug() << "New File Selected Manually=#" << text << "#";
if (fi.exists()==false) return;
//QString name_only=fi.completeBaseName();
QString path_only=fi.absolutePath()+QDir::separator();
QString suffix_only=fi.suffix();
/*qDebug() << "Name  =#" << name_only << "#";
qDebug() << "Path  =#" << path_only << "#";
qDebug() << "Suffix=#" << suffix_only << "#";*/
selector->ledFilter->setText(path_only+QString("*.")+suffix_only);
selector->setFilterFromExtern(path_only,suffix_only);
selector->setFileSelectionFromExtern(text);
//qDebug() << "NewFileEnteredManually=" << text;
gotNewSelection(text);
}

void frmIOForm::headerChecked(int c)
{
    selHeaderLength->setEnabled((bool)c);
}

void frmIOForm::readUntilEOFChecked(int c)
{
    selMaxImportData->setEnabled(!((bool)c));
}

void frmIOForm::setTypeChanged(int c)
{
    int curtype = GetOptionChoice(selType);
    int number_of_cols = settype_cols(curtype),index;
    int * values=new int[number_of_cols+2];
    QString * entries=new QString[number_of_cols+2];
    (void)c;
    values[0]=-1;
    entries[0]=tr("None");
    for (int i=0;i<number_of_cols;i++)
    {
        entries[i+1]=QString(dataset_colname(i));
        values[i+1]=i;
    }
    for (int i=0;i<selector_count;i++)
    {
        index=selImportTo[i]->currentIndex();
        selImportTo[i]->setNewEntries(number_of_cols+1,entries,values);
        selImportTo[i]->setCurrentIndex(index);
    }
    delete[] values;
    delete[] entries;
}

void frmIOForm::columnCountChanged(int c)
{
    int * sel_ind=new int[selector_count];
    int * sel_ind2=new int[selector_count];
    int * sel_ind3=new int[selector_count];
    for (int i=0;i<selector_count;i++)
    {
        sel_ind[i]=selColFormats[i]->currentIndex();
        sel_ind2[i]=selImportTo[i]->currentIndex();
        sel_ind3[i]=selColSize[i]->value();
        delete selColFormats[i];
        delete selImportTo[i];
        delete selColSize[i];
    }
    delete[] selColFormats;
    delete[] selImportTo;
    delete[] selColSize;
    selColFormats=new StdSelector*[c];
    selImportTo=new StdSelector*[c];
    selColSize=new QSpinBox*[c];

    empty->setGeometry(0,0,empty->width(),(int)(empty->height()*c*1.0/selector_count));

    int number=NUMBER_OF_COLUMN_FORMATS;
    char dummy[128];
    QString entr[NUMBER_OF_COLUMN_FORMATS];
    int vals[NUMBER_OF_COLUMN_FORMATS];
    for (int i=0;i<number;i++)
    {
        entr[i]=QString(binaryImportFormatName[i]);
        vals[i]=binaryImportFormat[i].format;
    }

    int offset=1;
    for (int i=0;i<c;i++)
    {
        sprintf(dummy,"%d:",i);
        selColFormats[i]=new StdSelector(this,QString(dummy),number,entr);
        selColFormats[i]->setValues(vals);
        selImportTo[i]=new StdSelector(this,QString(""),number,entr);
        selImportTo[i]->lblText->setVisible(false);
        selColSize[i]=new QSpinBox(this);
        selColSize[i]->setMinimum(1);
        selColSize[i]->setMaximum(5000);
        layout7->addWidget(selColFormats[i],offset,0,1,1);
        layout7->addWidget(selColSize[i],offset,1,1,1);
        layout7->addWidget(selImportTo[i],offset++,2,1,1);
    }

    int curtype = GetOptionChoice(selType);
    int number_of_cols = settype_cols(curtype);
    int * values=new int[number_of_cols+2];
    QString * entries=new QString[number_of_cols+2];
    values[0]=-1;
    entries[0]=tr("None");
    for (int i=0;i<number_of_cols;i++)
    {
        entries[i+1]=QString(dataset_colname(i));
        values[i+1]=i;
    }
    for (int i=0;i<c;i++)
    {
        selImportTo[i]->setNewEntries(number_of_cols+1,entries,values);
        connect(selColFormats[i]->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(columnSizeChanged(int)));
        if (i<selector_count)
        {
            selColFormats[i]->setCurrentIndex(sel_ind[i]);
            selImportTo[i]->setCurrentIndex(sel_ind2[i]);
            selColSize[i]->setValue(sel_ind3[i]);
            if (selColFormats[i]->currentValue())
                selColSize[i]->setEnabled(false);
            else
                selColSize[i]->setEnabled(true);
        }
        else
        {
            selColSize[i]->setValue(1);
            selColSize[i]->setEnabled(true);
        }
    }

    selector_count=c;
    delete[] sel_ind;
    delete[] sel_ind2;
}

void frmIOForm::columnSizeChanged(int c)
{
    (void)c;
    for (int i=0;i<selector_count;i++)
    {
        if (selColFormats[i]->currentValue())
        {
            selColSize[i]->setEnabled(false);
            selColSize[i]->setValue(binaryImportFormat[selColFormats[i]->currentValue()].size);
            selImportTo[i]->setEnabled(true);
        }
        else
        {
            selColSize[i]->setEnabled(true);
            selImportTo[i]->setEnabled(false);
            selImportTo[i]->setCurrentIndex(0);
        }
    }
}

void frmIOForm::writeWavToggled(int c)
{
(void) c;
QString wavExtension("*.wav");
    if (chkWriteWav->isChecked()==true)
    {
    savedExtension=selector->filterExtension;
    setList->setBehavior(setList->deselect_possible,true,setList->show_all_sets_marker);
    selector->ledFilter->setText(selector->currentDir+QDir::separator()+wavExtension);
    selector->setFilterFromExtern(selector->currentDir,wavExtension);
    }
    else
    {
    setList->setBehavior(setList->deselect_possible,false,setList->show_all_sets_marker);
    selector->ledFilter->setText(selector->currentDir+QDir::separator()+savedExtension);
    selector->setFilterFromExtern(selector->currentDir,savedExtension);
    int nr_of_sets,*sets=new int[2];
    setList->get_selection(&nr_of_sets,&sets);
        if (nr_of_sets>1)
        setList->set_new_selection(1,sets);//just select first selected set
    delete[] sets;
    }
}

frmFourier::frmFourier(QWidget * parent):QDialog(parent)
{
    int number;
    QString entr[7];
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));
    setWindowTitle(tr("QtGrace: Fourier transforms"));

    lblApplyTo=new QLabel(tr("Apply to set:"),this);
    sel=new uniList(SETCHOICE,this);

    buttonGroup=new stdButtonGroup(this,true,true,true);
    buttonGroup->cmdAccept->setText(tr("FFT"));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doFFT()));
    buttonGroup->cmdApply->setText(tr("DFT"));
    buttonGroup->cmdApply->setDefault(TRUE);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doDFT()));
    buttonGroup->cmdClose->setText(tr("Window only"));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doWindowOnly()));
    buttonGroup->cmdHelp->setText(tr("Close"));
    connect(buttonGroup->cmdHelp,SIGNAL(clicked()),this,SLOT(doClose()));

    chk_scale=new QCheckBox(tr("Divide magnitude by set-length"),this);
    chk_scale->setChecked(true);

    number=7;
    entr[0]=tr("None (Rectangular)");
    entr[1]=tr("Triangular");
    entr[2]=tr("Hanning");
    entr[3]=tr("Welch");
    entr[4]=tr("Hamming");
    entr[5]=tr("Blackman");
    entr[6]=tr("Parzen");
    selectors[0]=new StdSelector(this,tr("Data window:"),number,entr);
    number=3;
    entr[0]=tr("Magnitude");
    entr[1]=tr("Phase");
    entr[2]=tr("Coefficients");
    selectors[1]=new StdSelector(this,tr("Load result as:"),number,entr);
    number=3;
    entr[0]=tr("Index");
    entr[1]=tr("Frequency");
    entr[2]=tr("Period");
    selectors[2]=new StdSelector(this,tr("Let result X="),number,entr);
    number=2;
    entr[0]=tr("Transform");
    entr[1]=tr("Inverse transform");
    selectors[3]=new StdSelector(this,tr("Perform:"),number,entr);
    number=2;
    entr[0]=tr("Real");
    entr[1]=tr("Complex");
    selectors[4]=new StdSelector(this,tr("Data is:"),number,entr);
    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->addWidget(lblApplyTo);
    layout->addWidget(sel);
    layout->addWidget(selectors[0]);
    layout->addWidget(selectors[1]);
    layout->addWidget(selectors[2]);
    layout->addWidget(selectors[3]);
    layout->addWidget(selectors[4]);
    layout->addWidget(chk_scale);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    resize(LastSize_FormFourier);
}

frmFourier::~frmFourier()
{
    LastSize_FormFourier=this->size();
}

void frmFourier::init(void)
{
    sel->update_number_of_entries();
}

void frmFourier::doDFT(void)
/*
 * DFT
 */
{
    int gno = get_cg();
    int *selsets=new int[5];
    int i, cnt;
    int setno, load, loadx, invflag, type, wind;
    cnt = GetSelectedSets(sel, &selsets);
    if (cnt == SET_SELECT_ERROR)
    {
        errwin(tr("No sets selected").toLocal8Bit().constData());
        return;
    }
    wind = GetChoice(selectors[0]);
    load = GetChoice(selectors[1]);
    loadx = GetChoice(selectors[2]);
    invflag = GetChoice(selectors[3]);
    type = GetChoice(selectors[4]);
    set_wait_cursor();
    int *gnos=new int[cnt];
    int *snos=new int[cnt];
    int counter=0;//,resno;
    char dummy[64];
    //double factor;
    for (i = 0; i < cnt; i++)
    {
        setno = selsets[i];
        new_set_no=-1;
        do_fourier(gno, setno, 0, load, loadx, invflag, type, wind);
        if (new_set_no>=0)
        {
            gnos[counter]=gno;
            snos[counter++]=new_set_no;
        }
        if (chk_scale->isChecked()==true && wind>0 && load==0)
        {
            sprintf(dummy,"y=y*2.0");
            //factor=2.0/getsetlength(gno,new_set_no);
            //sprintf(dummy,"Y=Y*%lf",1.0/factor);
            //resno = do_compute(gno, new_set_no, gno, new_set_no, NULL, dummy);
            (void)do_compute(gno, new_set_no, gno, new_set_no, NULL, dummy);
        }
    }
    if (counter>0)
    {
        ///Undo-Stuff
        SetsCreated(counter,gnos,snos,UNDO_COMPLETE);
        if (counter==1)
        {
            sprintf(dummy,"[G%d.S%d]",gno,selsets[0]);
            addAditionalDescriptionToLastNode(-1,QObject::tr("Fourier transformation (DFT)")+QString(dummy),QString());
        }
        else
        {
            addAditionalDescriptionToLastNode(-1,QObject::tr("Fourier transformation (DFT)"),QString());
        }
    }
    delete[] snos;
    delete[] gnos;
    update_set_lists(gno);
    delete[] selsets;
    unset_wait_cursor();
    mainWin->mainArea->completeRedraw();
}

void frmFourier::doFFT(void)
/*
 * DFT by FFT
 */
{
    int gno = get_cg();
    int *selsets=new int[5];
    int i, cnt;
    int setno, load, loadx, invflag, type, wind;
    cnt = GetSelectedSets(sel, &selsets);
    if (cnt == SET_SELECT_ERROR)
    {
        errwin(tr("No sets selected").toLocal8Bit().constData());
        return;
    }
    wind = GetChoice(selectors[0]);
    load = GetChoice(selectors[1]);
    loadx = GetChoice(selectors[2]);
    invflag = GetChoice(selectors[3]);
    type = GetChoice(selectors[4]);
    set_wait_cursor();
    int *gnos=new int[cnt+2];
    int *snos=new int[cnt+2];
    int counter=0;//,resno;
    double factor;
    char dummy[64];
    for (i = 0; i < cnt; i++)
    {
        setno = selsets[i];
        new_set_no=-1;
        do_fourier(gno, setno, 1, load, loadx, invflag, type, wind);
        if (new_set_no>=0)
        {
            gnos[counter]=gno;
            snos[counter++]=new_set_no;
            if (chk_scale->isChecked()==true && load==0 && !(use_fftw3==TRUE && have_fftw3==TRUE))
            {
                if (wind==0)
                factor=2.0;
                else
                factor=1.0;
            factor*=getsetlength(gno,new_set_no);
            factor=1.0/factor;
                for (int k=0;k<g[gno].p[new_set_no].data.len;k++)
                {
                g[gno].p[new_set_no].data.ex[1][k]*=factor;
                }
            //sprintf(dummy,"Y=Y*%lf",factor);
            //cout << "Umrechnungsfaktor: " << dummy << endl;
            //resno = do_compute(gno, new_set_no, gno, new_set_no, NULL, dummy);
            }
        }
    }
    if (counter>0)
    {
        ///Undo-Stuff
        SetsCreated(counter,gnos,snos,UNDO_COMPLETE);
        if (counter==1)
        {
            sprintf(dummy,"[G%d.S%d]",gno,selsets[0]);
            addAditionalDescriptionToLastNode(-1,QObject::tr("Fourier transformation (FFT)")+QString(dummy),QString());
        }
        else
        {
            addAditionalDescriptionToLastNode(-1,QObject::tr("Fourier transformation (FFT)"),QString());
        }
    }
    delete[] snos;
    delete[] gnos;
    update_set_lists(gno);
    delete[] selsets;
    unset_wait_cursor();
    mainWin->mainArea->completeRedraw();
}

void frmFourier::doWindowOnly(void)
/*
 * Apply data window only
 */
{
    int *selsets=new int[5];
    int i, cnt;
    int setno, type, wind;
    //Four_ui *ui = (Four_ui *) client_data;
    cnt = GetSelectedSets(sel, &selsets);
    if (cnt == SET_SELECT_ERROR) {
        errwin(tr("No sets selected").toLocal8Bit().constData());
        return;
    }
    wind = GetChoice(selectors[0]);
    type = GetChoice(selectors[4]);
    set_wait_cursor();
    for (i = 0; i < cnt; i++) {
        setno = selsets[i];
        do_window(setno, type, wind);
    }
    update_set_lists(get_cg());
    delete[] selsets;
    unset_wait_cursor();
    mainWin->mainArea->completeRedraw();
}

void frmFourier::doClose(void)
{
    hide();
}

void generateLowPass_Brickwall(double * f,int n,double f_cutoff,double * cutoff_Function_r,double * cutoff_Function_i)
{
    for (int i=0;i<n;i++)
        cutoff_Function_i[i]=cutoff_Function_r[i]=((fabs(f[i])<f_cutoff)?1.0:(fabs(f[i])==f_cutoff?0.5:0.0));
}

void generateLowPass_Butterworth_simple(double * f,int n,double f_cutoff,int order,double * cutoff_Function_r,double * cutoff_Function_i)
{
    for (int i=0;i<n;i++)
        cutoff_Function_i[i]=cutoff_Function_r[i]=1.0/sqrt(1.0+pow(f[i]/f_cutoff,2.0*order));
}

void generateLowPass_Butterworth(double * f,int n,double f_cutoff,int order,double * cutoff_Function_r,double * cutoff_Function_i)
{
    struct komplex * ko=new struct komplex[n];
    struct komplex help1;
    double help2;
    double ai,bi;
    for (int i=0;i<n;i++)
        ko[i]=one;
    for (int j=1;j<=(order+1)/2;j++)
    {
        if (1-(order%2))//even
        {
            if (j>order/2) continue;
            bi=1.0;
            ai=2.0*cos((2.0*j-1.0)*M_PI/order*0.5);
        }
        else//odd
        {
            if (j==1)
            {
                bi=0.0;
                ai=1.0;
            }
            else
            {
                bi=1.0;
                ai=2.0*cos((j-1.0)*M_PI/order);
            }
        }
        for (int i=0;i<n;i++)
        {
            help2=f[i]/f_cutoff;
            help1.real=1.0-bi*help2*help2;
            help1.imag=-ai*help2;//ACHTUNG: '-' hinzugefgt
            ko[i]=mult_komplex(ko[i],help1);
        }
    }
    for (int i=0;i<n;i++)
    {
        ko[i]=div_komplex(one,ko[i]);
        cutoff_Function_r[i]=ko[i].real;
        cutoff_Function_i[i]=ko[i].imag;
    }
    delete[] ko;
}

void generateLowPass_Bessel(double * f,int n,double f_cutoff,int order,double * cutoff_Function_r,double * cutoff_Function_i)
{
    struct komplex * ko=new struct komplex[n];
    struct komplex help1=zero;
    struct komplex help2=zero;
    double ci=1.0;
    //initialize with order=1
    for (int i=0;i<n;i++)//n=number of points
    {
        ko[i].real=1.0;
        ko[i].imag=ci*f[i]/f_cutoff;
    }
    for (int j=2;j<=order;j++)//j = order of filter up to 'order'
    {
        ci*=(2.0*(order-j+1.0))/(j*(2.0*order-j+1.0));
        for (int i=0;i<n;i++)//go through all points
        {
            help2.real=0.0;//just for safety
            help2.imag=f[i]/f_cutoff;
            help1=pow_komplex(help2,j);
            help1.real*=ci;
            help1.imag*=ci;
            ko[i]=add_komplex(ko[i],help1);
        }
    }
    for (int i=0;i<n;i++)
    {
        ko[i]=div_komplex(one,ko[i]);
        cutoff_Function_r[i]=ko[i].real;
        cutoff_Function_i[i]=-ko[i].imag;//WARNING: '-' added to generate a phase shift in the resulting curve in positive x-direction (if x=time --> causality)
    }
    delete[] ko;
}

void generateLowPass_Chebychev(double * f,int n,double f_cutoff,int order,double ripple,double * cutoff_Function_r,double * cutoff_Function_i)
{
    struct komplex help1;
    struct komplex * ko=new struct komplex[n];
    double gamma=asinh(ripple)/order;//ripples are in dB
    double ai,bi;
    double help;
    for (int i=0;i<n;i++)
        ko[i]=one;
    for (int j=1;j<=order;j++)
    {
        if (1-(order%2))//even
        {
            help=cos((2.0*j-1.0)*M_PI*0.5/order);
            bi=1.0/(cosh(gamma)*cosh(gamma)-help*help);
            ai=2.0*bi*sinh(gamma)*help;
        }
        else//odd
        {
            if (j==1)
            {
                bi=0.0;
                ai=1.0/sinh(gamma);
            }
            else
            {
                help=cos((j-1.0)*M_PI/order);
                bi=1.0/(cosh(gamma)*cosh(gamma)-help*help);
                ai=2.0*bi*sinh(gamma)*help;
            }
        }
        for (int i=0;i<n;i++)
        {
            help=f[i]/f_cutoff;
            help1.real=1.0-bi*help*help;
            help1.imag=ai*help;
            ko[i]=mult_komplex(ko[i],help1);
        }
    }
    for (int i=0;i<n;i++)
    {
        ko[i]=div_komplex(one,ko[i]);
        cutoff_Function_r[i]=ko[i].real;
        cutoff_Function_i[i]=ko[i].imag;
    }
    delete[] ko;
}

void generateLowPass_Chebychev2(double * f,int n,double f_cutoff,int order,double ripple,double * cutoff_Function_r,double * cutoff_Function_i)
{
    double epsilon=1.0/sqrt(pow(10.0,0.1*ripple)-1.0);
    komplex t1={1.0,0.0};
    komplex t2={1.0,0.0};
    komplex T;
    komplex x;
    for (int i=0;i<n;i++)
    {
        x.imag=t2.imag=f[i]/f_cutoff;
        x.real=t2.real=0.0;
        if (order==1)
            T=t1;//order=1
        else
            T=t2;//order=2 or greater
        for (int j=3;j<order;j++)
        {
            T=mult_komplex(t2,x);
            T.real*=2.0;
            T.imag*=2.0;
            T=sub_komplex(T,t1);
            ///T=2.0*x*t2-t1;//order=3 --> T=T3=2*x*T2-t1
            t1=t2;
            t2=T;
        }
        x=T;
        x.real*=epsilon;
        x.imag*=epsilon;
        ///x=epsilon*T;
        x=mult_komplex(x,x);
        x.real+=1.0;
        T=pow_komplex(x,-0.5);
        cutoff_Function_r[i]=T.real;
        cutoff_Function_i[i]=T.imag;
        //cutoff_Function_r[i]=cutoff_Function_i[i]=1.0/sqrt(1.0+x);
    }
}

void generateLowPass_Gaussian(double * f,int n,double f_cutoff,int order,double * cutoff_Function_r,double * cutoff_Function_i)
{
    static double alpha=M_PI/sqrt(log(2.0));
/// Order of Gaussian is missing!? Is there a order in gaussian?
    (void)order;
    for (int i=0;i<n;i++)
        cutoff_Function_r[i]=cutoff_Function_i[i]=exp(-f[i]*f[i]/(2.0*alpha*f_cutoff*f_cutoff))/sqrt(2.0);
}

frmFourier2::frmFourier2(QWidget * parent):QDialog(parent)
{
    int rowcount=0;
    int number;
    char dummy[128];
    QString entr[9];
    int values[9];
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));
    setWindowTitle(tr("QtGrace: Filters"));

    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    buttonGroup->cmdApply->setDefault(TRUE);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doFilter()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    grpSource=new grpSelect(tr("Source"),this);
    grpDestination=new grpSelect(tr("Destination"),this);
    grpDestination->enable_sync(grpSource->listSet);

    entr[0]=tr("Low-Pass");
    values[0]=FILTER_LOW_PASS;
    entr[1]=tr("High-Pass");
    values[1]=FILTER_HIGH_PASS;
    entr[2]=tr("Band-Pass");
    values[2]=FILTER_BAND_PASS;
    entr[3]=tr("Band-Stop");
    values[3]=FILTER_BAND_STOP;
    number=4;
    selType=new StdSelector(this,tr("Filter type:"),number,entr);
    selType->setValues(values);
    connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(filterTypeChanged(int)));

    entr[0]=tr("Brickwall");
    values[0]=FILTER_BRICKWALL;
    entr[1]=tr("Butterworth");
    values[1]=FILTER_BUTTERWORTH;
    entr[2]=tr("Bessel");
    values[2]=FILTER_BESSEL;
    entr[3]=tr("Chebychev");
    values[3]=FILTER_CHEBYCHEV;
    entr[4]=tr("Gaussian");
    values[4]=FILTER_GAUSSIAN;
    entr[5]=tr("Butterworth-simple");
    values[5]=FILTER_BUTTERWORTH_SIMPLE;
    number=5;//Number 5 is not used/not accessible here
    selKind=new StdSelector(this,tr("Realization:"),number,entr);
    selKind->setValues(values);
    connect(selKind->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(filterKindChanged(int)));

    entr[0]=tr("No");
    for (int i=1;i<=7;i++)
    {
        sprintf(dummy,"%dx",1<<i);
        entr[i]=QString(dummy);
    }
    number=8;
    selOversampling=new StdSelector(this,tr("Oversampling:"),number,entr);
    chkAbsValue=new QCheckBox(tr("Use absolute value of transfer-function"),this);
    chkAbsValue->setToolTip(tr("If this option is deactivated the filters may induce a phase shift that may shift structures in the sets.\nIf only the absolute value of the transfer function is used there should be no phase shifts.\nThis is especially useful for non-periodic-sets."));
    chkDebug=new QCheckBox(tr("Debug"),this);
    chkDebug->setToolTip(tr("If 'debug' is activated additional sets will be created showing the original set extended to a number of points that is a power of 2.\nAlso the frequency spectrum of the set, the cut-off-filter-function and the filtered frequencies are shown."));
    lenRipple=new stdLineEdit(this,tr("Ripples in transfer-function in dB:"));

    gpbLow=new QGroupBox(tr("First Cut-Off"),this);
    gpbHigh=new QGroupBox(tr("Second Cut-Off"),this);
    layout1=new QHBoxLayout;
    //layout1->setMargin(STD_MARGIN);
    layout1->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout2=new QHBoxLayout;
    //layout2->setMargin(STD_MARGIN);
    layout2->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);

    lenLowFrequency=new stdLineEdit(gpbLow,tr("Frequency (kHz):"));
    selLowOrder=new stdIntSelector(gpbLow,tr("Order:"),1,30);
    layout1->addWidget(lenLowFrequency);
    layout1->addWidget(selLowOrder);

    lenHighFrequency=new stdLineEdit(gpbHigh,tr("Frequency (kHz):"));
    selHighOrder=new stdIntSelector(gpbHigh,tr("Order:"),1,30);
    layout2->addWidget(lenHighFrequency);
    layout2->addWidget(selHighOrder);

    gpbLow->setLayout(layout1);
    gpbHigh->setLayout(layout2);

    gpbProcessing=new QGroupBox(tr("FFT-processing options"),this);
    layout3=new QGridLayout;
    //layout3->setMargin(STD_MARGIN);
    layout3->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    lenTimeFormula=new stdLineEdit(this,tr("Conversion-factor for x-axis to time in seconds: X=X*"));
    lenTimeFormula->setToolTip(tr("For the calculations the x-values have to be time-values in seconds.\nIf this is not the case the filter-frequency is not was has been entered.\nOnly simple linear conversations are possible here."));
    entr[0]=tr("Interpolation");
    values[0]=PROCESSING_INTERPOLATION;
    entr[1]=tr("Zero Padding");
    values[1]=PROCESSING_ZERO_PADDING;
    entr[2]=tr("Pad first and last value");
    values[2]=PROCESSING_FIRST_LAST_PADDING;
    number=3;
    selPoints=new StdSelector(this,tr("Point extension:"),number,entr);
    selPoints->setValues(values);
    connect(selPoints->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(selPointsChanged(int)));

    layout3->addWidget(lenTimeFormula,0,0,1,2);
    layout3->addWidget(selPoints,1,0,1,1);
    layout3->addWidget(selOversampling,1,1,1,1);
    layout3->addWidget(chkAbsValue,2,0,1,1);
    layout3->addWidget(chkDebug,2,1,1,1);
    layout3->addWidget(lenRipple,3,0,1,2);
    gpbProcessing->setLayout(layout3);

    fraSourceDatFilt=new QGroupBox(tr("Source data filtering"),this);
    number=7;
    entr[0]=tr("None");
    entr[1]=tr("Region 0");
    entr[2]=tr("Region 1");
    entr[3]=tr("Region 2");
    entr[4]=tr("Region 3");
    entr[5]=tr("Region 4");
    entr[6]=tr("Inside graph");
    selRestriction=new StdSelector(fraSourceDatFilt,tr("Restriction:"),number,entr);
    chkNeg=new QCheckBox(tr("Negated"),fraSourceDatFilt);
    chkNeg->setChecked(FALSE);
    layout0=new QHBoxLayout;
    //layout0->setMargin(STD_MARGIN);
    layout0->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout0->addWidget(selRestriction);
    layout0->addWidget(chkNeg);
    fraSourceDatFilt->setLayout(layout0);

    layout=new QGridLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->addWidget(grpSource,rowcount,0,1,1);
    layout->addWidget(grpDestination,rowcount++,1,1,1);
    layout->addWidget(selType,rowcount,0,1,1);
    layout->addWidget(selKind,rowcount++,1,1,1);

    layout->addWidget(gpbLow,rowcount++,0,1,2);
    layout->addWidget(gpbHigh,rowcount++,0,1,2);
    layout->addWidget(gpbProcessing,rowcount++,0,1,2);

    layout->addWidget(fraSourceDatFilt,rowcount++,0,1,2);
    layout->addWidget(buttonGroup,rowcount++,0,1,2);
    setLayout(layout);
    chkAbsValue->setChecked(true);
    resize(LastSize_FormFourier2);
}

frmFourier2::~frmFourier2()
{
    LastSize_FormFourier2=this->size();
}

void frmFourier2::init(void)
{
    lenLowFrequency->setText(QString("50"));
    lenHighFrequency->setText(QString("100"));
    lenTimeFormula->setText(QString("1"));
    lenRipple->setText(QString("10"));
    selOversampling->setCurrentIndex(0);
    selLowOrder->setValue(2);
    selHighOrder->setValue(2);
    selPoints->setCurrentValue(PROCESSING_ZERO_PADDING);
    selKind->setCurrentValue(FILTER_BUTTERWORTH);
    filterKindChanged(FILTER_BUTTERWORTH);
    selType->setCurrentValue(FILTER_LOW_PASS);
    filterTypeChanged(FILTER_LOW_PASS);
    grpSource->update_number_of_entries();
    grpDestination->update_number_of_entries();
}

void frmFourier2::doAccept(void)
{
    doFilter();
    if (ApplyError==false)
        doClose();
}

void frmFourier2::doFilter(void)
{
    ApplyError=false;
    double f1,f2,ripple;
    int order1,order2;
    double factor=1.0;
    if (selKind->currentValue()==FILTER_BRICKWALL && chkAbsValue->isChecked())
    {
        factor=1.0/sqrt(2.0);
    }
    int error, resno, absolute;
    int g1_ok, g2_ok, ns1, ns2, * svalues1=new int[2], * svalues2=new int[2],gno1, gno2, setno1, setno2;
    char fstr[256];
    int restr_type, restr_negate;
    char * rarray;
    int * sel_graphs=new int[2];
    int setlen;
    int n_setlen;
    double xspace;
    bool mono;
    int * o_snos=NULL,*o_gnos=NULL;
    int * snos=NULL,*gnos=NULL;
    int n_n_sets=0;
    int workset1,workset2,workset3,workset4,workset5;
    double * mesh = NULL;
    char old_comment[MAX_STRING_LENGTH],old_orig_comment[MAX_STRING_LENGTH];
    char old_legend[MAX_STRING_LENGTH],old_orig_legend[MAX_STRING_LENGTH];
    set_wait_cursor();
    setno1=setno2=-1;
    gno1=gno2=0;
    error=xv_evalexpr(lenLowFrequency,&f1);
    f1*=1000.0;//input is in kHz, calculation in Hz
    if ((selType->currentValue()==FILTER_LOW_PASS || selType->currentValue()==FILTER_BAND_PASS || selType->currentValue()==FILTER_BAND_STOP) && error==RETURN_FAILURE)
    {
        errmsg(tr("Invalid low pass cut-off-frequency entered!").toLocal8Bit().constData());
        ApplyError=true;
        goto end_of_filter_function;
    }
    error=xv_evalexpr(lenHighFrequency,&f2);
    f2*=1000.0;
    if ((selType->currentValue()==FILTER_HIGH_PASS || selType->currentValue()==FILTER_BAND_PASS || selType->currentValue()==FILTER_BAND_STOP) && error==RETURN_FAILURE)
    {
        errmsg(tr("Invalid high pass cut-off-frequency entered!").toLocal8Bit().constData());
        ApplyError=true;
        goto end_of_filter_function;
    }
    order1=selLowOrder->value();
    order2=selHighOrder->value();
    error=xv_evalexpr(lenRipple,&ripple);
    if (selKind->currentValue()==FILTER_CHEBYCHEV && error==RETURN_FAILURE)
    {
        errmsg(tr("Invalid ripple-value entered for Chebychev filter!").toLocal8Bit().constData());
        ApplyError=true;
        goto end_of_filter_function;
    }
    switch (selRestriction->currentIndex())
    {
    case 0:
    default:
        restr_type=RESTRICT_NONE;
        break;
    case 1:
        restr_type=RESTRICT_REG0;
        break;
    case 2:
        restr_type=RESTRICT_REG1;
        break;
    case 3:
        restr_type=RESTRICT_REG2;
        break;
    case 4:
        restr_type=RESTRICT_REG3;
        break;
    case 5:
        restr_type=RESTRICT_REG4;
        break;
    case 6:
        restr_type=RESTRICT_WORLD;
        break;
    }

    restr_negate = chkNeg->isChecked()==TRUE?1:0;
    grpSource->listGraph->get_selection(&g1_ok,&sel_graphs);
    if (g1_ok==1)
    {
        gno1=sel_graphs[0];
        g1_ok=RETURN_SUCCESS;
    }
    else
        g1_ok=RETURN_FAILURE;

    grpDestination->listGraph->get_selection(&g2_ok,&sel_graphs);
    if (g2_ok==1)
    {
        gno2=sel_graphs[0];
        g2_ok=RETURN_SUCCESS;
    }
    else
        g2_ok=RETURN_FAILURE;

    grpSource->listSet->get_selection(&ns1,&svalues1);
    grpDestination->listSet->get_selection(&ns2,&svalues2);

    error = FALSE;
    if (g1_ok == RETURN_FAILURE || g2_ok == RETURN_FAILURE) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("Please select single source and destination graphs").toLocal8Bit().constData());
    } else if (ns1 == 0) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("No source sets selected").toLocal8Bit().constData());
    } else if (ns1 != ns2 && ns2 != 0) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("Different number of source and destination sets").toLocal8Bit().constData());
    } else {
        o_snos=new int[ns1];
        o_gnos=new int[ns1];
        snos=new int[ns1];
        gnos=new int[ns1];
        for (int i=0;i<ns1;i++)
        {
            o_gnos[i]=gno1;
            o_snos[i]=svalues1[i];
            gnos[i]=gno2;
        }
        n_n_sets=ns2;
        for (int i=0;i<ns2;i++)
            snos[i]=svalues2[i];
        SaveSetStatesPrevious(n_n_sets,gnos,snos,UNDO_COMPLETE);
        n_n_sets=0;
        //actually do the filtering
        for (int i = 0; i < ns1; i++)//go through all source-sets
        {
            strcpy(old_comment,g[gno1].p[svalues1[i]].comments);
            strcpy(old_orig_comment,g[gno1].p[svalues1[i]].orig_comments);
            strcpy(old_legend,g[gno1].p[svalues1[i]].lstr);
            strcpy(old_orig_legend,g[gno1].p[svalues1[i]].orig_lstr);

            sprintf(fstr,"X=X*(%s)",lenTimeFormula->text().toLatin1().constData());
            ReplaceDecimalSeparator(fstr);//replacing wrong decimal separators in the formula
            setno1 = svalues1[i];
            setno2 = -1;
            if (ns2 != 0)//do replace existing sets
            {
                setno2 = svalues2[i];
                snos[n_n_sets++]=setno2;
            }
            else
            {
                setno2 = nextset(gno2);
                set_set_hidden(gno2, setno2, FALSE);
                snos[n_n_sets++]=setno2;
            }
            workset5=-1;
            /*if (setno2==setno1 && gno2==gno1)//source and destination are the same
            {
            workset5=setno2;
            setno2=nextset(gno2);//we need an extra set here!
            }*/

            /*
            sprintf(dummy,"Original: factor=%f",factor);
            qDebug(dummy);
            */
            absolute=chkAbsValue->isChecked()==true?1:0;
            if (selKind->currentValue()==FILTER_GAUSSIAN) absolute=0;//Guassian filter is always absolute because it has a non-complex transfer function
            strcpy(fstr,lenTimeFormula->text().toLatin1().constData());
            if (do_filter_on_one_set(gno2,setno2,gno1,setno1,selType->currentValue(),selKind->currentValue(),restr_type,restr_negate,absolute,chkDebug->isChecked(),fstr,selPoints->currentValue(),selOversampling->currentIndex(),ripple,order1,order2,f1,f2)==RETURN_FAILURE)
            {
                strcpy(g[gno1].p[svalues1[i]].comments,old_comment);
                strcpy(g[gno1].p[svalues1[i]].orig_comments,old_orig_comment);
                strcpy(g[gno1].p[svalues1[i]].lstr,old_legend);
                strcpy(g[gno1].p[svalues1[i]].orig_lstr,old_orig_legend);
                ApplyError=true;
                break;
            }
            else
            {
                strcpy(g[gno1].p[svalues1[i]].comments,old_comment);
                strcpy(g[gno1].p[svalues1[i]].orig_comments,old_orig_comment);
                strcpy(g[gno1].p[svalues1[i]].lstr,old_legend);
                strcpy(g[gno1].p[svalues1[i]].orig_lstr,old_orig_legend);
                continue;
            }
        }//end of for-loop
    }//end of if-condition
end_of_filter_function:
    if (error == FALSE && ApplyError==false)
    {
        if (gno1 != gno2)
        {
            update_set_lists(gno1);
            update_set_lists(gno2);
        }
        else
        {
            update_set_lists(gno1);
        }
        /// replaced!
        /// SetsModified(n_n_sets,gnos,snos,UNDO_COMPLETE);
        ///do_filter_on_one_set(gno2,setno2,gno1,setno1,selType->currentValue(),selKind->currentValue(),restr_type,restr_negate,chkAbsValue->isChecked()==true?1:0,chkDebug->isChecked(),fstr,selPoints->currentValue(),selOversampling->currentIndex(),ripple,order1,order2,f1,f2);
        int orders[2]={order1,order2};
        double limits[2]={f1,f2};
        SetFilter(ns1,o_gnos,o_snos,n_n_sets,gnos,snos,selType->currentValue(),selKind->currentValue(),limits,orders,fstr,ripple,chkAbsValue->isChecked()==true?1:0,chkDebug->isChecked(),selPoints->currentValue(),selOversampling->currentIndex(),restr_type,restr_negate);
        mainWin->mainArea->completeRedraw();
        grpSource->mark_multiple_sets(gno1,ns1,svalues1);
        if (ns2==0)
        {
            ns2=1;
            svalues2[0]=setno2;
        }
        if (n_n_sets>0)
            grpDestination->mark_multiple_sets(gno2,n_n_sets,snos);
    }
    unset_wait_cursor();
    if (sel_graphs!=NULL)
        delete[] sel_graphs;
    if (svalues1!=NULL)
        delete[] svalues1;
    if (svalues2!=NULL)
        delete[] svalues2;
    if (o_snos!=NULL)
        delete[] o_snos;
    if (o_gnos!=NULL)
        delete[] o_gnos;
    if (snos!=NULL)
        delete[] snos;
    if (gnos!=NULL)
        delete[] gnos;
    if (mesh!=NULL)
        xfree(mesh);
}

void frmFourier2::selPointsChanged(int i)
{
    (void)i;
    switch (selPoints->currentIndex())
    {
    case 0:
        selOversampling->setEnabled(true);
        break;
    case 1:
    case 2:
        selOversampling->setEnabled(false);
        break;
    }
}

void frmFourier2::filterKindChanged(int i)
{
    (void)i;
    if (selKind->currentValue()==FILTER_CHEBYCHEV)
    {
        lenRipple->setVisible(true);
    }
    else
    {
        lenRipple->setVisible(false);
    }
    switch (selKind->currentIndex())
    {
    case FILTER_BRICKWALL:
    case FILTER_GAUSSIAN:
        selLowOrder->setEnabled(false);
        selHighOrder->setEnabled(false);
        break;
    default:
        selLowOrder->setEnabled(true);
        selHighOrder->setEnabled(true);
        break;
    }
    if (selKind->currentIndex()==FILTER_GAUSSIAN)
    {
    chkAbsValue->setEnabled(false);
    }
    else
    {
    chkAbsValue->setEnabled(true);
    }
}

void frmFourier2::filterTypeChanged(int i)
{
    (void)i;
    switch (selType->currentValue())
    {
    case FILTER_LOW_PASS:
        gpbLow->setVisible(true);
        gpbHigh->setVisible(false);
        gpbLow->setTitle(tr("Cut-Off"));
        break;
    case FILTER_HIGH_PASS:
        gpbLow->setVisible(true);
        gpbHigh->setVisible(false);
        gpbLow->setTitle(tr("Cut-Off"));

        break;
    case FILTER_BAND_PASS:
        gpbLow->setVisible(true);
        gpbHigh->setVisible(true);
        gpbLow->setTitle(tr("High Pass Cut-Off"));
        gpbHigh->setTitle(tr("Low Pass Cut-Off"));
        break;
    case FILTER_BAND_STOP:
        gpbLow->setVisible(true);
        gpbHigh->setVisible(true);
        gpbLow->setTitle(tr("Low Pass Cut-Off"));
        gpbHigh->setTitle(tr("High Pass Cut-Off"));
        break;
    }
}

void frmFourier2::doClose(void)
{
    hide();
}


frmEditBlockData::frmEditBlockData(QWidget * parent):QDialog(parent)
{
    char dummy[96];
    int number;
    initialized=FALSE;
    QString entr[NUMBER_OF_SETTYPES>20?NUMBER_OF_SETTYPES:20];
    QString ending=tr(" from column:");
    QString iformats[NUM_FMT_OPTION_ITEMS];
    for (int i=0;i<NUM_FMT_OPTION_ITEMS;i++) iformats[i]=QString(fmt_option_items[i].label);
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));
    setWindowTitle(tr("QtGrace: Edit block data"));

    extendedBlockInput=new frmExtendedEditBlockData(this);
    extendedBlockInput->hide();

    block_curtype = SET_XY;
    begining=tr("Block data: ");
    middle=tr(" column(s) of length ");
    chkExtendedInput=new QCheckBox(tr("Extended format input"),this);

    showBlockData=new show_text_file_widget(this);
    grpBlockContents=new QGroupBox(QString(""),this);
    lblBlockContents=new QLabel(QString(""),this);
    layout1=new QVBoxLayout();
    //layout1->setMargin(STD_MARGIN);
    layout1->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
    layout1->addWidget(lblBlockContents);
    layout1->addWidget(showBlockData);
    grpBlockContents->setLayout(layout1);

    grpLoadTo=new grpSelect(tr("Load to:"),this);
    grpLoadTo->listSet->setSelectionMode(QAbstractItemView::SingleSelection);
    lblData=new QLabel(QString(""),this);
    lblData->setFrameStyle(QFrame::Box | QFrame::Sunken);
    grpColumns=new QGroupBox(QString(""),this);
    number=5;
    entr[0]=QString("Index");
    for (int i=0;i<number;i++)
    {
        sprintf(dummy,"%d",i+1);
        entr[i+1]=QString(dummy);
    }
    for (int i=0;i<6;i++)
    {
        columnSelector[i]=new StdSelector(grpColumns,QString(""),number,entr);
    }
    columnSelector[0]->lblText->setText(QString("X")+ending);
    columnSelector[1]->lblText->setText(QString("Y")+ending);
    columnSelector[2]->lblText->setText(QString("Y1")+ending);
    columnSelector[3]->lblText->setText(QString("Y2")+ending);
    columnSelector[4]->lblText->setText(QString("Y3")+ending);
    columnSelector[5]->lblText->setText(QString("Y4")+ending);
    for (int i=0;i<6;i++)
    {
    columnSelector[i]->setCurrentIndex(i);
    }
    number=NUMBER_OF_SETTYPES;
    for (int i=0;i<NUMBER_OF_SETTYPES;i++)
    {
        strToUpper(dummy,set_types(i));
        entr[i]=QString(dummy);
    }
    selType=new StdSelector(grpColumns,tr("Set type:"),number,entr);
    connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(setTypeChanged(int)));
    number=5;
    for (int i=0;i<number;i++)
    {
        sprintf(dummy,"%d",i);
        entr[i]=QString(dummy);
    }
    entr[0]=tr("None");
    selStringColumn=new StdSelector(grpColumns,tr("Strings from column:"),number,entr);
    number=4;
    entr[1]=QString("X");
    entr[2]=QString("Y");
    entr[3]=QString("XY");
    selAutoscale=new StdSelector(this,tr("Autoscale graph on load:"),number,entr);
    selAutoscale->setCurrentIndex(3);
    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(chkExtendedInput,SIGNAL(toggled(bool)),this,SLOT(extInputToggled(bool)));

    layout0=new QGridLayout;
    //layout0->setMargin(STD_MARGIN);
    layout0->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout0->setSpacing(STD_SPACING);
    layout0->addWidget(selType,0,0,1,1);
    for (int i=0;i<6;i++)
    {
        layout0->addWidget(columnSelector[i],1+i,0,1,1);
    }
    layout0->addWidget(selStringColumn,7,0,1,1);
    grpColumns->setLayout(layout0);
    layout=new QGridLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    int row=0;
    layout->addWidget(lblData,row++,0);
    layout->addWidget(chkExtendedInput,row++,0);
    layout->addWidget(grpBlockContents,row++,0);
    layout->addWidget(grpLoadTo,row++,0);
    layout->addWidget(grpColumns,row++,0);
    layout->addWidget(selAutoscale,row++,0);
    layout->addWidget(buttonGroup,row++,0);
    layout->addWidget(extendedBlockInput,0,1,row,1);
    setLayout(layout);
    setTypeChanged(0);
    buttonGroup->cmdApply->setDefault(true);
    connect(extendedBlockInput,SIGNAL(newBlockData()),SLOT(gotNewBlockData()));
    resize(LastSize_FormEditBlockData);
    initialized=FALSE;
}

frmEditBlockData::~frmEditBlockData()
{
    LastSize_FormEditBlockData=this->size();
}

void frmEditBlockData::setCompleteData(int columns,int length)
{
    char dummy[32],dummy2[32];
    sprintf(dummy,"%d",columns);
    sprintf(dummy2,"%d",length);
    lblData->setText(begining+QString(dummy)+middle+QString(dummy2));
}

void frmEditBlockData::setTypeChanged(int i)
{
    int ncols=settype_cols(i);
    block_curtype = i;
    for (int i=0;i<ncols;i++)
    {
        columnSelector[i]->setEnabled(TRUE);
    }
    for (int i=ncols;i<6;i++)
    {
        columnSelector[i]->setEnabled(FALSE);
    }
}

void frmEditBlockData::init(void)
{
    grpLoadTo->listGraph->update_number_of_entries();
    grpLoadTo->listSet->update_number_of_entries();
    update_eblock(get_cg());
    if (chkExtendedInput->isChecked()==true) extInputToggled(true);
}

void frmEditBlockData::update_eblock(int gno)
{
    //init();
    int number;
    QString * entr1,*entr2;
    int * values1,*values2;
    int blocklen, blockncols;
    int *blockformats;
    int i, nncols, nscols;//ncols
    char buf[128];

    blockncols = get_blockncols();
    if (blockncols == 0)
    {
        QString err=tr("Need to read block data first");
        char * dummy_err=new char[err.length()+1];
        strcpy(dummy_err,err.toLocal8Bit());
        errmsg(dummy_err);
        delete[] dummy_err;
        return;
    }
    blocklen = get_blocknrows();
    blockformats = get_blockformats();
    lblBlockContents->setText(tr("Block data read from file:\n")+QString(get_block_origin()));
    QString html;
    html.clear();
    create_html_from_blockdata(html);
    showBlockData->setText(html);

/*ofstream ostr;
ostr.open("/Users/andreaswinter/html_testfile1.txt");
ostr << html.toLocal8Bit().constData();
ostr.close();*/

// Test output
/*
    qDebug() << " block_cols=" << blockncols << "rows=" << blocklen;
        for (int i=0;i<blockncols;i++)
        qDebug() << i << "Format=" << blockformats[i];
        */
// End Test Output

    if (is_valid_gno(gno))
    {
        ///SelectListChoice(eblock_graphset_item->graph_sel, gno);
        int selection[2]={gno,0};
        grpLoadTo->listGraph->set_new_selection(1,selection);
        grpLoadTo->listSet->set_graph_number(gno,false);
    }
    setCompleteData(blockncols,blocklen);
    ///sprintf(buf, "Block data: %d column(s) of length %d",blockncols, blocklen);
    ///SetLabel(eblock_ncols_item, buf);
    /* TODO: check if new data arrived */
    if (1)
    {
        number=blockncols+1;
        entr1=new QString[number];
        values1=new int[number];
        entr2=new QString[number];
        values2=new int[number];
        entr1[0]=tr("Index");
        entr2[0]=tr("None");
        values1[0]=values2[0]=-1;

        /*blockitems  = xmalloc((blockncols + 1)*sizeof(OptionItem));
        sblockitems = xmalloc((blockncols + 1)*sizeof(OptionItem));
        blockitems[0].value = -1;
        blockitems[0].label = copy_string(NULL, "Index");
        sblockitems[0].value = -1;
        sblockitems[0].label = copy_string(NULL, "None");*/
        nncols = 0;
        nscols = 0;

        for (i = 0; i < blockncols; i++)
        {
            //qDebug() << i << "Column-Format=" << blockformats[i];
            sprintf(buf, "%d", i + 1);
            if (blockformats[i] != FFORMAT_STRING)
            {
                nncols++;
                values1[nncols]=i;
                entr1[nncols]=QString(buf);
                /*blockitems[nncols].value = i;
                blockitems[nncols].label = copy_string(NULL, buf);*/
            }
            else
            {
                nscols++;
                values2[nscols]=i;
                entr2[nscols]=QString(buf);
                /*sblockitems[nscols].value = i;
                sblockitems[nscols].label = copy_string(NULL, buf);*/
            }
        }

        for (i = 0; i < MAX_SET_COLS; i++)
        {
            int oldchoice = columnSelector[i]->currentValue();///GetOptionChoice(eblock_nchoice_items[i]);
            ///UpdateOptionChoice(eblock_nchoice_items[i],nncols + 1, blockitems);
            columnSelector[i]->setNewEntries(nncols+1,entr1,values1);
            if (oldchoice < blockncols)
            {
                ///SetOptionChoice(eblock_nchoice_items[i], oldchoice);
                columnSelector[i]->setCurrentValue(oldchoice);
            }
            else if (i < blockncols)
            {
                ///SetOptionChoice(eblock_nchoice_items[i], i);
                columnSelector[i]->setCurrentValue(i);
            }
        }
        if (initialized==FALSE)
        {
           for (i = 0; i < MAX_SET_COLS; i++)
           {
           columnSelector[i]->setCurrentIndex(i+1);
           }
        initialized=TRUE;
        }
        ///UpdateOptionChoice(eblock_schoice_item, nscols + 1, sblockitems);
        selStringColumn->setNewEntries(nscols+1,entr2,values2);

        /*for (i = 0; i < nncols + 1; i++) {
            xfree(blockitems[i].label);
        }
        xfree(blockitems);
        for (i = 0; i < nscols + 1; i++) {
            xfree(sblockitems[i].label);
        }
        xfree(sblockitems);*/
        delete[] entr1;
        delete[] values1;
        delete[] entr2;
        delete[] values2;
    }

    //ncols = settype_cols(block_curtype);
    setTypeChanged(block_curtype);
    /*for (i = 0; i < MAX_SET_COLS; i++) {
        SetSensitive(eblock_nchoice_items[i]->menu, (i < ncols));
    }*/
}

void frmEditBlockData::extInputToggled(bool ch)
{
//qDebug() << "selTypeCMB.height=" << selType->height();
    if (ch==true)
    {
//qDebug() << "extended checked";
    width_without=this->width();
    extendedBlockInput->init(this->filename.toLocal8Bit().constData());
/*#ifdef WINDOWS_SYSTEM
    extendedBlockInput->init("D:\\old_data\\qtgrace_w_undo\\test_dataformat_3.txt");
#else
    extendedBlockInput->init("/Users/andreaswinter/test_dataformat_3.txt");
#endif*/
    extendedBlockInput->show();
    qApp->processEvents();
    this->update();
    this->repaint();
    qApp->processEvents();

    //extendedBlockInput->raise();
    }
    else
    {
//qDebug() << "NOT extended / unchecked";
    extendedBlockInput->hide();
    qApp->processEvents();
    this->update();
    this->repaint();
    qApp->processEvents();
    this->resize(width_without,this->height());
    qApp->processEvents();
    }
}

void frmEditBlockData::gotNewBlockData(void)
{
//qDebug() << "new block data";
update_eblock(get_cg());
}

void frmEditBlockData::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmEditBlockData::doApply(void)
{
    ApplyError=false;
    int i, gno, setno;
    int cs[MAX_SET_COLS], nncols, scol, autoscale;
    int * graphs=new int[2];
    int anz_graphs;
    int * sets=new int[2];
    int anz_sets;
    set_wait_cursor();
    //get current selection
    grpLoadTo->listGraph->get_selection(&anz_graphs,&graphs);
    grpLoadTo->listSet->get_selection(&anz_sets,&sets);
    if (anz_graphs==0)
    {
        errmsg(tr("Please select a single graph").toLocal8Bit().constData());
        ApplyError=true;
        return;
    }
    else
    {
        gno=graphs[0];
    }
    if (anz_sets==0)
    {
        setno = NEW_SET;
    }
    else
    {
        setno=sets[0];
    }

    /*if (GetSingleListChoice(eblock_graphset_item->graph_sel, &gno)
        != RETURN_SUCCESS) {
        errmsg(tr("Please select a single graph").toLocal8Bit().constData());
        return RETURN_FAILURE;
    }*/
    /*if (GetSingleListChoice(eblock_graphset_item->set_sel, &setno) !=
        RETURN_SUCCESS) {
        // no set selected; allocate new one
        setno = NEW_SET;
    }*/
    
    nncols = settype_cols(block_curtype);
    for (i = 0; i < nncols; i++)
    {
        cs[i] = columnSelector[i]->currentValue();//-1 means "Index"
    }
    scol = selStringColumn->currentValue();
    autoscale = selAutoscale->currentValue();

    char * filen=new char[filename.length()+2];
    strcpy(filen,filename.toLocal8Bit());
    SetImportBlockData(gno,setno,filen,source,nncols, cs, scol,block_curtype,autoscale);
    new_set_no=-1;
    create_set_fromblock(gno, setno, block_curtype, nncols, cs, scol, autoscale);
    SetNewSetNo(new_set_no);
    mainWin->mainArea->completeRedraw();
    delete[] filen;
    delete[] graphs;
    delete[] sets;
    unset_wait_cursor();
}

void frmEditBlockData::doClose(void)
{
    hide();
}

frmExtendedEditBlockData::frmExtendedEditBlockData(QWidget * parent):QWidget(parent)
{
    /*setWindowIcon(QIcon(*GraceIcon));
    setWindowTitle(tr("QtGrace: Extended block data input"));*/
    filename=NULL;
    init_block_input_data(&block);
    lblFilename=new QLabel(tr("Filename: ---"),this);
    lblContents=new QLabel(tr("File contents: x Row(s), y Column(s) (z Set(s))"),this);
    selMaxLines=new stdIntSelector(this,tr("Nr of lines to show:"),1,100);
    selMaxLines->setValue(5);
    lblContentsTitle=new QLabel(tr("File contents:"),this);
    lblValuesTitle=new QLabel(tr("Read double values:"),this);
    scroll=new QScrollArea(this);
    empty=new QWidget(scroll);
    selectors_alloc=rows_alloc=cols_alloc=0;
    lblColumns=NULL;
    cmbColumns=NULL;
    lblSetInfos=NULL;
    grid1=new QGridLayout();
    grid2=new QGridLayout();
    grid1->setSpacing(STD_SPACING);
    grid2->setSpacing(STD_SPACING);
    //grid1->setMargin(STD_MARGIN);
    //grid2->setMargin(STD_MARGIN);
    grid1->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    grid2->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    empty->setLayout(grid2);
    scroll->setWidget(empty);
    selLoadSet=new StdSelector(this,tr("Origin for block-data:"),0,NULL);
    cmdReRead=new QPushButton(tr("Re-read data from file"),this);
    cmdStore=new QPushButton(tr("<== Store as block data"),this);
    cmdReRead->setToolTip(tr("Read the data from the file again according to the column formats set above\nYou have to use this button if the file contents changed since last reading or if you altered the column-formats\nThe formats will be used as set (no further column-format-guessing)"));
    cmdStore->setToolTip(tr("Store the data read from one set in the file as block data (block data can only hold one set at a time, but lots of columns)"));

    showFile=new show_text_file_widget(this);
    showResult=new show_text_file_widget(this);
    int row=0,row1,row2;
    grid1->addWidget(lblFilename,row++,0);
    grid1->addWidget(lblContents,row++,0);
    grid1->addWidget(selMaxLines,row++,0);
    grid1->addWidget(lblContentsTitle,row++,0);
    row1=row;
    grid1->addWidget(showFile,row++,0);
    grid1->addWidget(scroll,row++,0);
    grid1->addWidget(cmdReRead,row++,0);
    grid1->addWidget(lblValuesTitle,row++,0);
    row2=row;
    grid1->addWidget(showResult,row++,0);
    grid1->addWidget(selLoadSet,row++,0);
    grid1->addWidget(cmdStore,row++,0);
        for (int i=0;i<row;i++)
        grid1->setRowStretch(i,0);
        grid1->setRowStretch(row1,5);
        grid1->setRowStretch(row2,5);
    this->setLayout(grid1);
    connect(cmdReRead,SIGNAL(pressed()),this,SLOT(doTestRead()));
    connect(cmdStore,SIGNAL(pressed()),this,SLOT(doStore()));
}

void frmExtendedEditBlockData::init(const char * file_name)
{
if (filename!=NULL) delete[] filename;
filename=new char[2+strlen(file_name)];
strcpy(filename,file_name);
//qDebug() << "INIT";
block.nr_of_errors=guess_block_data_column_format(filename,block,selMaxLines->value(),'.');
//qDebug() << "GUESS_ENDE";
show_results();
//qDebug() << "SHOW_ENDE";
}

void frmExtendedEditBlockData::show_results(void)
{
lblFilename->setText(tr("Filename: ")+QString(filename));
    if (block.filename!=NULL) delete[] block.filename;
    block.filename=new char[2+strlen(filename)];
strcpy(block.filename,filename);
    //qDebug() << "Error-Count=" << block.nr_of_errors;
QFileInfo fi(filename);
QString tmp_text;
    tmp_text.clear();
        if (!fi.isReadable())
        {
        lblContents->setText(tr("Unable to read file: ")+QString(filename));
        }
        else
        {
            tmp_text=tr("File contains ")+QString::number(block.nr_of_sets) +tr(" set(s); ")+QString::number(block.nr_of_errors)+tr(" read-errors");
            /*for (int i=0;i<block.nr_of_sets;i++)
            {
            tmp_text+=tr("Set ")+QString::number(i)+QString(": ")+QString::number(block.set_infos[i].nr_of_rows) +tr(" Row(s), ")+ QString::number(block.set_infos[i].nr_of_columns) +tr(" Column(s)");
            if (i<block.nr_of_sets-1) tmp_text+=QString("; ");
            }*/
        lblContents->setText(tmp_text);
        }
showFile->init(filename,selMaxLines->value());
tmp_text.clear();
        for (int i=0;i<block.nr_of_sets;i++)
        {
        tmp_text+=block.set_infos[i].read_results_text;
        if (i<block.nr_of_sets-1) tmp_text+=QString("\n<tr><td> </td></tr>\n");//QString("\n...\n");
        }
showResult->setHtml(tmp_text);
recreateInputColumns();
}

void frmExtendedEditBlockData::recreateInputColumns(void)
{
    //delete existing input-columns
    if (selectors_alloc>0)
    {
        for (int i=0;i<selectors_alloc;i++)
        {
        delete lblColumns[i];
        delete cmbColumns[i];
        }
    delete[] lblColumns;
    delete[] cmbColumns;
    lblColumns=NULL;
    cmbColumns=NULL;
    }
    if (rows_alloc>0)
    {
        for (int i=0;i<=rows_alloc;i++)
        delete lblSetInfos[i];
    delete[] lblSetInfos;
    lblSetInfos=NULL;
    }
    selLoadSet->cmbSelect->clear();
int label_and_combo_counter=0,column_index=0,max_cols=0;
QString entries[2+block.nr_of_sets];
    if (block.nr_of_sets>0)
    {
    //count sets and columns in sets and allocate memory for the selectors
        lblSetInfos=new QLabel*[block.nr_of_sets+1];
        lblSetInfos[0]=new QLabel(tr("Column formats of sets in file:"),this);
            for (int i=0;i<block.nr_of_sets;i++)
            {
            entries[i]=tr("Set ")+QString::number(i);
            label_and_combo_counter+=block.set_infos[i].nr_of_columns;
            if (block.set_infos[i].nr_of_columns>max_cols) max_cols=block.set_infos[i].nr_of_columns;
            lblSetInfos[i+1]=new QLabel(tr("Set ")+QString::number(i)+tr(": ")+QString::number(block.set_infos[i].nr_of_rows)+tr(" Row(s), ")+QString::number(block.set_infos[i].nr_of_columns)+tr(" Column(s), begins at row ")+QString::number(block.set_infos[i].start_row),this);
            }
        rows_alloc=block.nr_of_sets;
        cols_alloc=0;
        selectors_alloc=label_and_combo_counter;
        if (label_and_combo_counter>0)
        {
        lblColumns=new QLabel*[label_and_combo_counter];
        cmbColumns=new QComboBox*[label_and_combo_counter];
        column_index=0;
        cols_alloc=label_and_combo_counter;
            for (int i=0;i<block.nr_of_sets;i++)
            {
                for (int k=0;k<block.set_infos[i].nr_of_columns;k++)
                {
                lblColumns[column_index]=new QLabel(tr("Column ")+QString::number(k+1)+QString(":"),this);
                cmbColumns[column_index]=new QComboBox(this);
                    for (int j=0;j<NUM_FMT_OPTION_ITEMS;j++)
                    {
                    cmbColumns[column_index]->addItem(QString(fmt_option_items[j].label));
                    }
                    cmbColumns[column_index]->addItem(tr("Strings"));
                    if (block.set_infos[i].column_format[k]>=0)
                    cmbColumns[column_index]->setCurrentIndex(block.set_infos[i].column_format[k]);
                    else
                    cmbColumns[column_index]->setCurrentIndex(NUM_FMT_OPTION_ITEMS);//if not recognized-->its strings (maybe)
                column_index++;
                }
            }
//qDebug() << "For Checking: cols_alloc=" << cols_alloc << "column_index=" << column_index << "max_cols=" << max_cols << "selectors_alloc=" << selectors_alloc;
        //now everything should be allocated and initializised --> now arrange the settings on the screen
            column_index=0;
            grid2->addWidget(lblSetInfos[0],0,0,1,max_cols);//general title
            for (int i=0;i<block.nr_of_sets;i++)
            {
            grid2->addWidget(lblSetInfos[i+1],1+i*3,0,1,max_cols);//set-properties title
                for (int k=0;k<block.set_infos[i].nr_of_columns;k++)
                {
                grid2->addWidget(lblColumns[column_index],2+i*3,k,1,1);
                grid2->addWidget(cmbColumns[column_index],3+i*3,k,1,1);
                column_index++;
                }
            }
        int empty_w=2*STD_MARGIN+1.5*(cmbColumns[0]->width()+STD_SPACING)*(max_cols),empty_h=2*STD_MARGIN-STD_SPACING+(STD_SPACING+MIN2(cmbColumns[0]->height(),20))*(1+3*block.nr_of_sets);
        /*qDebug() << "Font_Pixel_size=" << qApp->font().pixelSize();
        qDebug() << "empty.width=" << empty_w << "contents.width=" << lblContents->width();
        qDebug() << "empty.height=" << empty_h;*/
        if (empty_h<4*1.2*qApp->font().pixelSize()) empty_h=4*1.2*qApp->font().pixelSize();
        if (empty_w<empty_h*3*max_cols) empty_w=empty_h*2.3*max_cols;

        /*if (empty_w<0.85*lblContents->width()) empty_w=0.85*lblContents->width();
        if (empty_h<empty_w/max_cols/3) empty_h=empty_w/max_cols/3;*/
        empty->resize(empty_w,empty_h);

        //empty->resize(2*STD_MARGIN+(cmbColumns[0]->width()+STD_SPACING)*(max_cols),2*STD_MARGIN-STD_SPACING+(STD_SPACING+MIN2(cmbColumns[0]->height(),20))*(1+3*block.nr_of_sets));//old
        /// empty->resize(2*STD_MARGIN+1.5*(cmbColumns[0]->width()+STD_SPACING)*(max_cols),2*STD_MARGIN-STD_SPACING+(STD_SPACING+MIN2(cmbColumns[0]->height(),20))*(1+3*block.nr_of_sets));//new
        //qDebug() << "ColumnsCMB.width=" << cmbColumns[0]->width() << "ColumnsCMB.height=" << cmbColumns[0]->height();
        }//end of if (label_and_combo_counter>0)
    selLoadSet->setNewEntries(block.nr_of_sets,entries);
    }//end of if (block.nr_of_sets)
    else//no sets
    {
    entries[0]=tr("None");
    selLoadSet->setNewEntries(1,entries);
    }
}

void frmExtendedEditBlockData::readInputColumns(void)
{
//qDebug() << "overwriting the column-formats with what the users has set";
block.read_from_set=selLoadSet->currentIndex();
int column_index=0;
    for (int i=0;i<block.nr_of_sets;i++)
    {
        for (int k=0;k<block.set_infos[i].nr_of_columns;k++)
        {
            if (cmbColumns[column_index]->currentIndex()<NUM_FMT_OPTION_ITEMS)
            {
            block.set_infos[i].column_format[k]=cmbColumns[column_index]->currentIndex();
            }
            else
            {
            block.set_infos[i].column_format[k]=FORMAT_STRING;//strings
            }
        column_index++;
        }
    }
}

void frmExtendedEditBlockData::doTestRead(void)
{
//qDebug() << "Re-Read Inputs";
readInputColumns();
(void)read_block_data_from_file(filename,block,selMaxLines->value(),'.');
show_results();
}

void frmExtendedEditBlockData::doStore(void)
{
//qDebug() << "Store into block Data";
int load_set=selLoadSet->currentValue();
transfer_set_data_to_blockData(block.set_infos+load_set);
emit(newBlockData());
}

void frmExtendedEditBlockData::doClose(void)
{
    hide();
}

frmLoadEval::frmLoadEval(QWidget * parent):QDialog(parent)
{
    QString entr[MAX_SET_COLS];
    entr[0]=QString("X =");
    entr[1]=QString("Y =");
    entr[2]=QString("Y1 =");
    entr[3]=QString("Y2 =");
    entr[4]=QString("Y3 =");
    entr[5]=QString("Y4 =");
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Load & evaluate"));
    setWindowIcon(QIcon(*GraceIcon));
    grpParameterMesh=new QGroupBox(tr("Parameter mesh ($t)"),this);
    ststst=new stdStartStop(this);
    ststst->lblStart->setText(tr("Start at:"));
    ststst->lblStop->setText(tr("Stop at:"));
    ststst->lblLength->setText(tr("Length:"));
    layout0=new QHBoxLayout;
    //layout0->setMargin(STD_MARGIN);
    layout0->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout0->setSpacing(STD_SPACING);
    layout0->addWidget(ststst);
    grpParameterMesh->setLayout(layout0);
    selType=new stdSetTypeSelector(this);
    selType->setShowAll(true);
    selType->lblText->setText(tr("Set type:"));
    connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(typeChanged(int)));
    layout=new QGridLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    layout->addWidget(grpParameterMesh,0,0,1,6);
    layout->addWidget(selType,1,0,1,3);
    for (int i=0;i<MAX_SET_COLS;i++)
    {
        lblText[i]=new QLabel(entr[i],this);
        ledText[i]=new QLineEdit(QString(""),this);
        layout->addWidget(lblText[i],i+2,0,1,1);
        layout->addWidget(ledText[i],i+2,1,1,5);
        if (i>1)
        {
            lblText[i]->setVisible(false);
            ledText[i]->setVisible(false);
        }
        else
        {
            lblText[i]->setVisible(true);
            ledText[i]->setVisible(true);
        }
    }
    ledText[0]->setText(QString("$t"));
    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    layout->addWidget(buttonGroup,MAX_SET_COLS+2,0,1,6);
    setLayout(layout);
    parentList=NULL;
    resize(LastSize_FormLoadAndEvaluate);
//qDebug() << "LastSize_FormLoadAndEvaluate=" << LastSize_FormLoadAndEvaluate;
}

frmLoadEval::~frmLoadEval()
{
    LastSize_FormLoadAndEvaluate=this->size();
//qDebug() << "Destructor: " << LastSize_FormLoadAndEvaluate;
}

void frmLoadEval::Redisplay(void)
{
//qDebug() << "Redisplay";
    if (OldDecimalPoint==DecimalPointToUse) return;
    QString te;
    ststst->Redisplay();
    for (int i=0;i<MAX_SET_COLS;i++)
    {
        te=ledText[i]->text();
        if (OldDecimalPoint=='.')//.-->,
        {
        te.replace(QChar(','),QChar('|'));
        te.replace(QChar(OldDecimalPoint),QChar(DecimalPointToUse));
        }
        else//,-->.
        {
        te.replace(QChar(OldDecimalPoint),QChar(DecimalPointToUse));
        te.replace(QChar('|'),QChar(','));
        }
        ledText[i]->setText(te);
    }
}

void frmLoadEval::typeChanged(int i)
{
//qDebug() << "TypeChanged";
    (void)i;
int cols=selType->getColumnCount();
    for (int i=0;i<cols;i++)
    {
        lblText[i]->setVisible(true);
        ledText[i]->setVisible(true);
    }
    for (int i=cols;i<MAX_SET_COLS;i++)
    {
        lblText[i]->setVisible(false);
        ledText[i]->setVisible(false);
    }
}

void frmLoadEval::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmLoadEval::doApply(void)
{
    ApplyError=false;
    double start=ststst->start();
    if (ststst->error==true)
    {
        errmsg(tr("Start item undefined").toLocal8Bit().constData());
        ApplyError=true;
        return;
    }
    double stop=ststst->stop();
    if (ststst->error==true)
    {
        errmsg(tr("Stop item undefined").toLocal8Bit().constData());
        ApplyError=true;
        return;
    }
    long npts=ststst->length();
    int res;
    if (ststst->error==true)
    {
        errmsg(tr("Number of points undefined").toLocal8Bit().constData());
        ApplyError=true;
        return;
    }

    char * formula[MAX_SET_COLS];
    char * c_dummy=NULL;
    QString dummy;
    int cols=selType->getColumnCount();
    int type=selType->currentValue();
    bool conv_error=false;//error during conversion?
    grarr *t;
    int setno, gno=get_cg();
    setno=0;
    for (int i=0;i<cols;i++)//load all formulas
    {
        dummy=ledText[i]->text();
        dummy=dummy.trimmed();
        if (dummy.isEmpty())
        {
            conv_error=true;
            formula[i]=new char[2];
        }
        else
        {
            formula[i]=new char[dummy.length()*4+8];
            strcpy(formula[i],ledText[i]->text().toLatin1());
            ReplaceDecimalSeparator(formula[i]);//We assume the user has entered decimal separators as set in the Extra-preference --> replace them with '.'
            setno+=strlen(formula[i]);
        }
    }
    c_dummy=new char[GR_MAXPATHLEN];

    if (conv_error==true)
    {
        errmsg(tr("Formula not recognized!").toLocal8Bit().constData());
        ApplyError=true;
        return;
    }

    t = get_parser_arr_by_name(dollar_t);
    if (t == NULL)
    {
        t = define_parser_arr(dollar_t);
        if (t == NULL)
        {
            errmsg(tr("Internal error").toLocal8Bit().constData());
            ApplyError=true;
            for (int i=0;i<cols;i++)
                delete[] formula[i];
            N_DELETE2(c_dummy);
            return;
        }
    }
    
    if (t->length != 0)
    {
        xfree(t->data);
        t->length = 0;
    }
    t->data = allocate_mesh(start, stop, npts);
    if (t->data == NULL)
    {
        errmsg(tr("Internal error").toLocal8Bit().constData());
        ApplyError=true;
        for (int i=0;i<cols;i++)
            delete[] formula[i];
        N_DELETE2(c_dummy);
        return;
    }
    t->length = npts;
    
    setno = nextset(gno);
    set_dataset_type(gno, setno, type);
    set_set_hidden(gno, setno, FALSE);
    if (setlength(gno, setno, npts) != RETURN_SUCCESS)
    {
        killset(gno, setno);
        XCFREE(t->data);
        t->length = 0;
        errmsg(tr("Internal error").toLocal8Bit().constData());
        ApplyError=true;
        for (int i=0;i<cols;i++)
            delete[] formula[i];
        N_DELETE2(c_dummy);
        return;
    }
    
    set_parser_setno(gno, setno);

    strcpy(c_dummy,"");
    for (int i = 0; i < cols; i++)
    {
        char buf[32], *expr;
        /* preparing the expression */
        sprintf(buf, "GRAPH[%d].SET[%d].%s = ", gno, setno, dataset_colname(i));
        expr = copy_string(NULL, buf);
        expr = concat_strings(expr, formula[i]);
        strcat(c_dummy,dataset_colname(i));
        strcat(c_dummy,"=");
        strcat(c_dummy,formula[i]);
        if (i<cols-1) strcat(c_dummy,";");

        /* evaluate the expression */

        res = scanner(expr);

        xfree(expr);
        
        if (res != RETURN_SUCCESS) {
            killset(gno, setno);
            XCFREE(t->data);
            t->length = 0;
            errmsg(tr("Internal error").toLocal8Bit().constData());
            ApplyError=true;
            for (int i=0;i<cols;i++)
                delete[] formula[i];
            delete[] c_dummy;
            return;
        }
    }
    //copy legend (just in case there had been a legend before - after kill data)
    strcpy(g[gno].p[setno].orig_lstr,g[gno].p[setno].lstr);
    update_grace_string_from_UTF8_static(g[gno].p[setno].lstr);
    //set formula comment
    setcomment(gno,setno,c_dummy);
    N_DELETE2(c_dummy);

    XCFREE(t->data);
    t->length = 0;

    //Undo-Stuff
    int gnos[2]={gno,gno};
    int snos[2]={setno,setno};
    SetsCreated(1,gnos,snos,UNDO_COMPLETE);
    QString str;
    for (int i=0;i<cols;i++)
    {
        str+=QString(dataset_colname(i))+QString("=")+QString(formula[i]);
        if (i<cols-1)
            str+=QString("; ");
    }
    addAditionalDescriptionToLastNode(-1,QString(),str);
    mainWin->mainArea->completeRedraw();
    for (int i=0;i<cols;i++)
        delete[] formula[i];
    if (parentList!=NULL)
    {
    parentList->set_new_selection(1,snos);
    emit(parentList->new_selection());
    }

}

void frmLoadEval::doClose(void)
{
//qDebug() << "Close";
    hide();
}

grpSelect::grpSelect(QString title,QWidget *parent):QGroupBox( parent )
{
//setFont(*stdFont);
int minheight=10;
    titleString=title;
    setTitle(title);

    lblGraph=new QLabel(tr("Graph:"),this);
    minheight=minheight>lblGraph->height()?minheight:lblGraph->height();
    listGraph=new uniList(GRAPHLIST,this);
    connect(listGraph,SIGNAL(itemSelectionChanged()),listGraph,SLOT(new_selection()));

    lblSet=new QLabel(tr("Set:"),this);
    listSet=new uniList(SETLIST,this);
    connect(listGraph,SIGNAL(new_selection(int)),this,SLOT(set_graph_nr(int)));
    listSet->partner=listGraph;
    listGraph->partner=listSet;

    chkSyncSelection=new QCheckBox(tr("Sync. selection"),this);
    chkSyncSelection->setToolTip(tr("Always make Source=Destination"));
    minheight=minheight>chkSyncSelection->height()?minheight:chkSyncSelection->height();
    syncSource=NULL;
    chkSyncSelection->setVisible(false);
    connect(chkSyncSelection,SIGNAL(toggled(bool)),SLOT(syncToggled(bool)));

    layout=new QGridLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->addWidget(lblGraph,0,0);
    layout->addWidget(chkSyncSelection,0,1);
    layout->addWidget(listGraph,1,0,1,2);
    layout->addWidget(lblSet,2,0,1,2);
    layout->addWidget(listSet,3,0,3,2);
    layout->setRowMinimumHeight(0,minheight);
    layout->setRowStretch(1,1);
    layout->setRowStretch(3,5);
    setLayout(layout);

    listGraph->set_graph_number(get_cg(),false);
    listSet->set_graph_number(get_cg(),false);
    listGraph->item(get_cg())->setSelected(TRUE);
}

void grpSelect::set_graph_nr(int gno)
{
    if (gno<0)//no selction
    {
    listSet->clear();
    }
    else
    {
    listSet->set_graph_number(gno,true);
    }
    source_got_new_selection(0);
}

void grpSelect::enable_sync(uniList * sync_partner)
{
chkSyncSelection->setVisible(true);
syncSource=sync_partner;
connect(syncSource,SIGNAL(new_selection(int)),SLOT(source_got_new_selection(int)));
}

void grpSelect::syncToggled(bool s)
{
    (void)s;
if (chkSyncSelection->isVisible()==false) return;
    if (chkSyncSelection->isChecked()==true)
    {
        listGraph->setEnabled(false);
        listSet->setEnabled(false);
        source_got_new_selection(0);
    }
    else
    {
        listGraph->setEnabled(true);
        listSet->setEnabled(true);
    }
}

void grpSelect::source_got_new_selection(int a)
{
static bool sync_running=false;
    (void)a;
if (chkSyncSelection->isVisible()==false || syncSource==NULL || chkSyncSelection->isChecked()==false || sync_running==true) return;
    sync_running=true;
int gno=syncSource->gr_no;
int nsets,*setnos=new int[2];
syncSource->get_selection(&nsets,&setnos);
mark_multiple_sets(gno,nsets,setnos);
if (setnos) delete[] setnos;
    sync_running=false;
}

void grpSelect::update_number_of_entries(void)
{
    int nr,*sel=new int[2];
    listSet->get_selection(&nr,&sel);
    listGraph->update_number_of_entries_preserve_selection();
    listSet->update_number_of_entries();
    listSet->set_new_selection(nr,sel);
    if (sel) delete[] sel;
}

void grpSelect::mark_single_set(int gno,int setno)
{
    int dummy=gno;
    listGraph->update_number_of_entries();
    listGraph->set_new_selection(1,&dummy);
    dummy=setno;
    listSet->gr_no=gno;
    listSet->update_number_of_entries();
    listSet->set_new_selection(1,&setno);
}

void grpSelect::mark_multiple_sets(int gno,int nsets,int * setnos)
{
    int dummy=gno;
    update_number_of_entries();
    listGraph->set_new_selection(1,&dummy);
    listSet->set_graph_number(gno,false);
    listSet->set_new_selection(nsets,setnos);
}

frmEvalExpr::frmEvalExpr(MainWindow * parWind,QWidget *parent):QDialog( parent )
{
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));
    parentWindow=parWind;
    setWindowTitle(tr("QtGrace: Evaluate expression"));

    grpSource=new grpSelect(tr("Source"),this);
    grpDestination=new grpSelect(tr("Destination"),this);
    grpDestination->enable_sync(grpSource->listSet);

    lblFormula=new QLabel(tr("Formula:"),this);
    ledFormula=new QTextEdit("",this);

    fraSourceDatFilt=new QGroupBox(tr("Source data filtering"),this);
    fraSourceDatFilt->setGeometry(ledFormula->x(),ledFormula->y()+ledFormula->height(),width(),64);

    int number=7;
    QString entr[7];
    entr[0]=tr("None");
    entr[1]=tr("Region 0");
    entr[2]=tr("Region 1");
    entr[3]=tr("Region 2");
    entr[4]=tr("Region 3");
    entr[5]=tr("Region 4");
    entr[6]=tr("Inside graph");
    selRestriction=new StdSelector(fraSourceDatFilt,tr("Restriction:"),number,entr);
    selRestriction->setToolTip(tr("If a region is selected then the formula is only evaluated with the data inside the region.\nIf 'negated' is selected then 'inside' the region becomes 'outside'.\nData not part of the region is usually lost."));

    chkNeg=new QCheckBox(tr("Negated"),fraSourceDatFilt);
    chkNeg->setChecked(false);
    chkNeg->setEnabled(false);
    chkApplyAndKeep=new QCheckBox(tr("Apply formula to restriction, keep the rest unchanged"),fraSourceDatFilt);
    chkApplyAndKeep->setToolTip(tr("If activated that part of a set that falls inside the restriction is\naltered by the formula and the other part of the set is kept as it is.\nIf deactivated the restriction will mean that the set is restricted\nand the formula is applied (i.e. only the part of the set that matches the region remains)."));
    chkApplyAndKeep->setChecked(false);
    chkApplyAndKeep->setEnabled(false);

    layout0=new QGridLayout;
    //layout0->setMargin(STD_MARGIN);
    layout0->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout0->setSpacing(STD_SPACING);
    layout0->addWidget(selRestriction,0,0,1,1);
    layout0->addWidget(chkNeg,0,1,1,1);
    layout0->addWidget(chkApplyAndKeep,1,0,1,2);
    fraSourceDatFilt->setLayout(layout0);

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(selRestriction,SIGNAL(currentIndexChanged(int)),this,SLOT(restrictionChanged(int)));

    /*connect(grpSource->listSet,SIGNAL(syncSelection()),SLOT(takeSourceToDest()));
    connect(grpDestination->listSet,SIGNAL(syncSelection()),SLOT(takeDestToSource()));*/

    layout=new QGridLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    layout->addWidget(grpSource,0,0);
    layout->addWidget(grpDestination,0,1);
    layout->addWidget(lblFormula,1,0,1,2);
    layout->addWidget(ledFormula,2,0,1,2);
    layout->addWidget(fraSourceDatFilt,3,0,1,2);
    layout->addWidget(buttonGroup,4,0,1,2);
    layout->setAlignment(lblFormula,Qt::AlignHCenter);
    setLayout(layout);
    resize(LastSize_FormEvalExpr);
}

frmEvalExpr::~frmEvalExpr()
{
    LastSize_FormEvalExpr=this->size();
}

void frmEvalExpr::doApply(void)
{
    compute_aac();
}

void frmEvalExpr::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmEvalExpr::doClose(void)
{
    hide();
}

void frmEvalExpr::update(void)
{
    grpSource->listGraph->update_number_of_entries();
    grpSource->listSet->update_number_of_entries();
    grpDestination->listGraph->update_number_of_entries();
    grpDestination->listSet->update_number_of_entries();
}

void frmEvalExpr::init(void)
{
    update();
    int nr=1;
    int n_gr[2]={cg,cg};
    grpSource->set_graph_nr(cg);
    grpSource->listGraph->set_new_selection(nr,n_gr);
    grpDestination->set_graph_nr(cg);
    grpDestination->listGraph->set_new_selection(nr,n_gr);
        //grpSource->listGraph->setCurrentItem(grpSource->listGraph->item(0));
        //grpDestination->listGraph->setCurrentRow(0);
    //grpSource->listGraph->setCurrentIndex(0);
}

void frmEvalExpr::takeSourceToDest(void)
{
//qDebug() << "Source To Destination";
int nr_of_sel_sets;
int current_graph;
int * sel_sets=new int[2];
    grpSource->listSet->get_selection(&nr_of_sel_sets,&sel_sets);
    current_graph=grpSource->listSet->gr_no;
grpDestination->set_graph_nr(current_graph);
grpDestination->listSet->blockSignals(true);
grpDestination->listSet->set_new_selection(nr_of_sel_sets,sel_sets);
grpDestination->listSet->blockSignals(false);
if (sel_sets!=NULL) delete[] sel_sets;
}

void frmEvalExpr::takeDestToSource(void)
{
//qDebug() << "Destination To Source";
int nr_of_sel_sets;
int current_graph;
int * sel_sets=new int[2];
    grpDestination->listSet->get_selection(&nr_of_sel_sets,&sel_sets);
    current_graph=grpDestination->listSet->gr_no;
grpSource->set_graph_nr(current_graph);
grpSource->listSet->blockSignals(true);
grpSource->listSet->set_new_selection(nr_of_sel_sets,sel_sets);
grpSource->listSet->blockSignals(false);
if (sel_sets!=NULL) delete[] sel_sets;
}

void frmEvalExpr::restrictionChanged(int i)
{
    if (i==0)//no restriction
    {
    chkNeg->setEnabled(false);
    chkApplyAndKeep->setEnabled(false);
    }
    else//some restriction
    {
    chkNeg->setEnabled(true);
    chkApplyAndKeep->setEnabled(true);
    }
}

/*
 * evaluate a formula
 */
void frmEvalExpr::compute_aac(void)
{
    int error, resno;
    int i, g1_ok, g2_ok, ns1, ns2, *svalues1=new int[2], *svalues2=new int[2],gno1, gno2, setno1, setno2;
    char fstr[512];
    char fstr2[512];
    int restr_type, restr_negate;
    char *rarray;
    int * sel_graphs=new int[2];
    char dummy[128];
    double * savedSet[MAX_SET_COLS];
    char ** savedStrings=NULL;
    char ** savedOrigStrings=NULL;
    int setlen,counter;
    for (int i=0;i<MAX_SET_COLS;i++) savedSet[i]=NULL;
    set_wait_cursor();
    ApplyError=false;
    switch (selRestriction->currentIndex())
    {
    case 0:
    default:
        restr_type=RESTRICT_NONE;
        break;
    case 1:
        restr_type=RESTRICT_REG0;
        break;
    case 2:
        restr_type=RESTRICT_REG1;
        break;
    case 3:
        restr_type=RESTRICT_REG2;
        break;
    case 4:
        restr_type=RESTRICT_REG3;
        break;
    case 5:
        restr_type=RESTRICT_REG4;
        break;
    case 6:
        restr_type=RESTRICT_WORLD;
        break;
    }
    restr_negate = chkNeg->isChecked()==true?1:0;
    //get the source and destiantion graphs
    grpSource->listGraph->get_selection(&g1_ok,&sel_graphs);
    gno1=gno2=0;
    if (g1_ok==1)
    {
        gno1=sel_graphs[0];
        g1_ok=RETURN_SUCCESS;
    }
    else
        g1_ok=RETURN_FAILURE;
    grpDestination->listGraph->get_selection(&g2_ok,&sel_graphs);
    if (g2_ok==1)
    {
        gno2=sel_graphs[0];
        g2_ok=RETURN_SUCCESS;
    }
    else
        g2_ok=RETURN_FAILURE;
    //get the source and destiantion sets
    grpSource->listSet->get_selection(&ns1,&svalues1);
    grpDestination->listSet->get_selection(&ns2,&svalues2);
    error = FALSE;
    if (g1_ok == RETURN_FAILURE || g2_ok == RETURN_FAILURE) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("Please select single source and destination graphs").toLocal8Bit().constData());
    } else if (ns1 == 0) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("No source sets selected").toLocal8Bit().constData());
    } else if (ns1 != ns2 && ns2 != 0) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("Different number of source and destination sets").toLocal8Bit().constData());
    } else {
        ///Undo-Stuff: only save destination sets, because only they are modified!
        int * gnos=new int[ns2>0?ns2:ns1];
        if (ns2==0)
        {
            delete[] svalues2;
            svalues2=new int[ns1];
        }
        for (i=0;i<ns1;i++)//ns1==ns2 || ns2==0
        {
            gnos[i]=grpDestination->listSet->gr_no;
        }
        SaveSetStatesPrevious(ns2,gnos,svalues2,UNDO_DATA);//it is possible that there are no sets to be saved here!

        QString tmp_formula=ledFormula->toPlainText();
        tmp_formula.replace("\n",";");
        strcpy(fstr, tmp_formula.toLatin1());

        PrepareFormula(fstr);
        /*
        remove_whitespaces(last_formula,fstr);
        strcpy(fstr,last_formula);
        */
        remove_beginning_whitespaces2(fstr);
        strcpy(last_formula,fstr);
        //cout << "Evaluate Expression: Last Formula=" << last_formula << endl;
        clear_new_set_ids();//prepare for the generation of new set-ids
        ListOfChanges.clear();
        ListOfOldStates.clear();
        for (i = 0; i < ns1; i++)//go through all source-sets
        {
            setno1 = svalues1[i];
            if (ns2 != 0) {//ns2==ns1
                setno2 = svalues2[i];
            } else {
                setno2 = nextset(gno2);
                //new set --> copy command needed for commands-window
                sprintf(fstr2,"COPY G%d.S%d TO G%d.S%d",gno1, setno1, gno2, setno2);
                ListOfChanges << QString(fstr2);
                set_set_hidden(gno2, setno2, FALSE);
                svalues2[i]=setno2;//because I need this for Undo-function!
            }
            resno = get_restriction_array(gno1, setno1,restr_type, restr_negate, &rarray);
            if (resno != RETURN_SUCCESS) {
                errmsg(tr("Error in evaluation restriction").toLocal8Bit().constData());
                ApplyError=true;
                break;
            }
            strcpy(fstr2,fstr);
            //the replacing will now be done in do_compute
            /*
qDebug() << "Orig Formula=" << fstr2;
            prependSetID(fstr2,setno2,gno2,setno1,gno1);//modify formula for use with commands-window
qDebug() << "Mod. Formula=" << fstr2;
            */
            current_target_graph=gno2;
            current_target_set=setno2;
            current_origin_graph=gno1;
            current_origin_set=setno1;
            /// set_parser_setno(gno1,setno1);
            //qDebug() << "converted formula:" << fstr2;

            if (restr_type!=RESTRICT_NONE && chkApplyAndKeep->isChecked()==true)//we want to keep the rest --> save it before it is destroyed
            {
                setlen=getsetlength(gno1, setno1);
                for (int l=0;l<dataset_cols(gno1, setno1);l++)//save data
                {
                savedSet[l]=new double[setlen];
                memcpy(savedSet[l],g[gno1].p[setno1].data.ex[l],setlen*sizeof(double));
                }
                if (g[gno1].p[setno1].data.s != NULL)//save string-column
                {
                savedStrings=new char*[setlen];
                savedOrigStrings=new char*[setlen];
                    for (int l = 0; l < setlen; l++)
                    {
                    savedStrings[l]=copy_string(NULL, g[gno1].p[setno1].data.s[l]);
                    savedOrigStrings[l]=copy_string(NULL, g[gno1].p[setno1].data.orig_s[l]);
                    }
                }
                //qDebug() << "Original setlength=" << setlen;
            }
//QTime evaltim;
//evaltim.start();
            resno = do_compute(gno1, setno1, gno2, setno2, rarray, fstr2);//fstr replaced by fstr2
//qDebug() << "computation takes=" << evaltim.restart() << "ms";
            if (restr_type!=RESTRICT_NONE && chkApplyAndKeep->isChecked()==true)
            {
//qDebug() << "New setlength=" << getsetlength(gno2, setno2) << "Orig-set-length=" << getsetlength(gno1,setno1);
            //insert the altered data into the saved set
                counter=0;
                for (int m=0;m<setlen;m++)
                {
                    if (rarray[m])//it is a new point (i.e. it is in the restriction)
                    {
                        for (int l=0;l<dataset_cols(gno1, setno1);l++)
                        {
                        savedSet[l][m]=g[gno2].p[setno2].data.ex[l][counter];//overwrite old point with new point from target-set
                        }
                    counter++;
                    }
                }
//qDebug() << "counter at the end=" << counter << "setlen=" << setlen;
                //copy saved set (with included alterations) into target set
                setlength(gno2,setno2,setlen);
                for (int l=0;l<dataset_cols(gno1, setno1);l++)//copy saved data back
                {
                memcpy(g[gno2].p[setno2].data.ex[l],savedSet[l],setlen*sizeof(double));
                //delete memory
                N_DELETE2(savedSet[l]);
                }
                if (savedStrings != NULL)//copy saved string-column back
                {
                    for (int l = 0; l < setlen; l++)
                    {
                    g[gno2].p[setno2].data.s[l]=copy_string(g[gno2].p[setno2].data.s[l],savedStrings[l]);
                    g[gno2].p[setno2].data.orig_s[l]=copy_string(g[gno2].p[setno2].data.orig_s[l],savedStrings[l]);
                    savedStrings[l]=copy_string(savedStrings[l],NULL);
                    savedOrigStrings[l]=copy_string(savedOrigStrings[l],NULL);
                    }
                N_DELETE2(savedStrings);
                N_DELETE2(savedOrigStrings);
                }
            }
            XCFREE(rarray);
            if (resno != RETURN_SUCCESS) {
                errwin(tr("Error in do_compute(), check formula").toLocal8Bit().constData());
                ApplyError=true;
                break;
            }
            ListOfChanges << QString(fstr2);
        }
        if (ApplyError==false)
        {
            SetsModified(ns1,gnos,svalues2,UNDO_DATA);//the new sets
            if (ns1==1)
            {
                sprintf(dummy,"[G%d.S%d]",gnos[0],svalues2[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_SET_MODIFIED,tr("Evaluate expression")+QString(dummy),QString(fstr),0);//usefull for adding a formula
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_SET_MODIFIED,tr("Evaluate expression"),QString(fstr),-1);//usefull for adding a formula
            }
            CheckActive();
        }
        delete[] gnos;
    }
    
    if (error == FALSE)
    {
        if (gno1 != gno2)
        {
            update_set_lists(gno1);
            update_set_lists(gno2);
        } else {
            update_set_lists(gno1);
        }
        mainWin->mainArea->completeRedraw();
        //grpSource->mark_multiple_sets(gno1,ns1,svalues1);//selection of source-sets should not be changed!
        //cout << "select new sets: " << gno2 << " ns1=" << ns1 << endl;
        ///Deactivated the autoselection for v0.2.6
        ///grpDestination->mark_multiple_sets(gno2,ns1,svalues2);//I changed this to ns1, because svalues2 now contains the new set-ids
    }
    unset_wait_cursor();
    if (FormReportFitParameters!=NULL)
    {
    FormReportFitParameters->init();
    }
    delete[] sel_graphs;
    delete[] svalues1;
    delete[] svalues2;
}

nlcfTabMain::nlcfTabMain(QWidget * parent):QWidget(parent)
{
    int number;
    char dummy[MAXPARM+2];
    QString entr[MAXPARM+2];
    ledFormula=new stdLineEdit(this,tr("Formula:"));
    ledFormula->lenText->setText(QString("y = "));
    ledTolerance=new stdLineEdit(this,tr("Tolerance:"));

    if (DecimalPointToUse==',')
        ledTolerance->lenText->setText(QString("0,01"));
    else
        ledTolerance->lenText->setText(QString("0.01"));

    number=MAXPARM+1;
    for (int i=0;i<number;i++)
    {
        sprintf(dummy,"%d",i);
        entr[i]=QString(dummy);
    }
    selParameters=new StdSelector(this,tr("Parameters:"),number,entr);
    connect(selParameters->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(paraNumberChanged(int)));
    selIterations=new stdIntSelector(this,tr("Iterations:"),0,500);
    selIterations->spnInt->setSingleStep(5);
    selIterations->setValue(5);
    scroll=new QScrollArea;
    spreadParameters=new spreadSheet(scroll,1,1,3);
    scroll->setWidget(spreadParameters);

    layout=new QGridLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->addWidget(ledFormula,0,0,1,3);
    layout->addWidget(selParameters,1,0);
    layout->addWidget(ledTolerance,1,1);
    layout->addWidget(selIterations,1,2);
    layout->addWidget(scroll,2,0,3,3);
    setLayout(layout);
    paraNumberChanged(0);
}

void nlcfTabMain::paraNumberChanged(int i)
{
    spreadParameters->setGeometry(0,0,width()-10,30*i);
    spreadParameters->resize(i,3);
}

nlcfTabAdvanced::nlcfTabAdvanced(QWidget * parent):QWidget(parent)
{
    int number;
    QString entr[10];

    grpSourceDataFilter=new QGroupBox(tr("Source data filtering"),this);
    number=7;
    entr[0]=tr("None");
    entr[1]=tr("Region 0");
    entr[2]=tr("Region 1");
    entr[3]=tr("Region 2");
    entr[4]=tr("Region 3");
    entr[5]=tr("Region 4");
    entr[6]=tr("Inside graph");
    selRestrictions=new StdSelector(this,tr("Restriction:"),number,entr);
    chkNegated=new QCheckBox(tr("Negated"),this);
    layout0=new QHBoxLayout;
    //layout0->setMargin(STD_MARGIN);
    layout0->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout0->addWidget(selRestrictions);
    layout0->addWidget(chkNegated);
    grpSourceDataFilter->setLayout(layout0);

    grpWeighting=new QGroupBox(tr("Weighting"),this);
    number=5;
    entr[0]=tr("None");
    entr[1]=tr("1/Y");
    entr[2]=tr("1/Y^2");
    entr[3]=tr("1/dY^2");
    entr[4]=tr("Custom");
    selWeights=new StdSelector(grpWeighting,tr("Weights:"),number,entr);
    connect(selWeights->cmbSelect, SIGNAL(currentIndexChanged(int)), this, SLOT(weights_changed(int)));
    ledFunction=new stdLineEdit(grpWeighting,tr("Function:"));
    ledFunction->setText(QString(""));
    layout1=new QHBoxLayout;
    //layout1->setMargin(STD_MARGIN);
    layout1->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout1->addWidget(selWeights);
    layout1->addWidget(ledFunction);
    grpWeighting->setLayout(layout1);

    grpLoadOptions=new QGroupBox(tr("Load options"),this);
    number=3;
    entr[0]=tr("Fitted values");
    entr[1]=tr("Residuals");
    entr[2]=tr("Function");
    selLoad=new StdSelector(grpLoadOptions,tr("Load:"),number,entr);
    connect(selLoad->cmbSelect, SIGNAL(currentIndexChanged(int)), this, SLOT(load_changed(int)));
    ledStartLoadAt=new stdLineEdit(grpLoadOptions,tr("Start $t at:"));
    ledStopLoadAt=new stdLineEdit(grpLoadOptions,tr("Stop $t at:"));
    ledNumberOfPoints=new stdLineEdit(grpLoadOptions,tr("# of points:"));
    ledXFunction=new stdLineEdit(grpLoadOptions,tr("Load x as "));
    ledXFunction->setText(QString("$t"));
    layout2=new QGridLayout;
    //layout2->setMargin(STD_MARGIN);
    layout2->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout2->addWidget(selLoad,0,0);
    layout2->addWidget(ledXFunction,0,1,1,2);
    layout2->addWidget(ledStartLoadAt,1,0);
    layout2->addWidget(ledStopLoadAt,1,1);
    layout2->addWidget(ledNumberOfPoints,1,2);
    grpLoadOptions->setLayout(layout2);

    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->addWidget(grpSourceDataFilter);
    layout->addWidget(grpWeighting);
    layout->addWidget(grpLoadOptions);
    setLayout(layout);
    load_changed(0);
}

void nlcfTabAdvanced::weights_changed(int i)
{
    if (i==WEIGHT_CUSTOM)
    {
        ledFunction->setEnabled(true);
    }
    else
    {
        ledFunction->setEnabled(false);
    }
}

void nlcfTabAdvanced::load_changed(int i)
{
    if (i==LOAD_FUNCTION)
    {
        ledStartLoadAt->setEnabled(true);
        ledStopLoadAt->setEnabled(true);
        ledNumberOfPoints->setEnabled(true);
        ledXFunction->setEnabled(true);
    }
    else
    {
        ledStartLoadAt->setEnabled(false);
        ledStopLoadAt->setEnabled(false);
        ledNumberOfPoints->setEnabled(false);
        ledXFunction->setEnabled(false);
    }
}

frmNonlinCurveFit::frmNonlinCurveFit(QWidget * parent):QDialog(parent)
{
    frmOpenFitPara=NULL;
    frmSaveFitPara=NULL;
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Non-linear curve fitting"));
    setWindowIcon(QIcon(*GraceIcon));

    CreateActions();

    menuBar=new QMenuBar(this);
    mnuFile=new QMenu(tr("&File"));
    mnuFile->setTearOffEnabled(TRUE);
    mnuFile->addAction(actOpen);
    mnuFile->addAction(actSave);
    mnuFile->addSeparator();
    mnuFile->addAction(actClose);
    mnuEdit=new QMenu(tr("&Edit"));
    mnuEdit->setTearOffEnabled(TRUE);
    mnuEdit->addAction(actResetFit);
    mnuEdit->addSeparator();
    mnuEdit->addAction(actLoadFit);
    mnuView=new QMenu(tr("&View"));
    mnuView->setTearOffEnabled(TRUE);
    mnuView->addAction(actAutoLoad);
    mnuView->addSeparator();
    mnuView->addAction(actUpdate);
    mnuHelp=new QMenu(tr("&Help"));
    mnuHelp->setTearOffEnabled(TRUE);
    mnuHelp->addAction(actHelpOnContext);
    mnuHelp->addSeparator();
    mnuHelp->addAction(actHelpOnFit);

    menuBar->addMenu(mnuFile);
    menuBar->addMenu(mnuEdit);
    menuBar->addMenu(mnuView);
    menuBar->addSeparator();
    menuBar->addMenu(mnuHelp);

    empty=new QWidget(this);
    grpSource=new grpSelect(tr("Source"),empty);
    grpDestination=new grpSelect(tr("Destination"),empty);

    lblAFit=new QLineEdit(tr("A fit"),this);
    QPalette pal=lblAFit->palette();
    pal.setColor(QPalette::Base,mainWin->palette().window().color());
    pal.setColor(QPalette::Window,mainWin->palette().window().color());
    lblAFit->setPalette(pal);
    //lblAFit->setFrameStyle(QFrame::Box | QFrame::Raised);
    tabs=new QTabWidget(this);
    tabMain=new nlcfTabMain(tabs);
    tabAdvanced=new nlcfTabAdvanced(tabs);
    tabs->addTab(tabMain,tr("Main"));
    tabs->addTab(tabAdvanced,tr("Advanced"));

    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));

    layout0=new QHBoxLayout;
    //layout0->setMargin(0);
    layout0->setContentsMargins(0,0,0,0);
    layout0->addWidget(grpSource);
    layout0->addWidget(grpDestination);
    empty->setLayout(layout0);
    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    /*
layout->addWidget(menuBar,0,0,1,2);
layout->addWidget(grpSource,1,0);
layout->addWidget(grpDestination,1,1);
layout->addWidget(lblAFit,2,0,1,2);
layout->setAlignment(lblAFit,Qt::AlignHCenter);
layout->addWidget(tabs,3,0,1,2);
layout->addWidget(buttonGroup,4,0,1,2);
*/
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar);
#endif
    layout->addWidget(empty);
    layout->addWidget(lblAFit);
    lblAFit->setAlignment(Qt::AlignHCenter);
    ///layout->setAlignment(lblAFit,Qt::AlignHCenter);
    layout->addWidget(tabs);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    //initialize_nonl();//not needed --> is done in the replacement-main-function
    resize(LastSize_FormNonlinCurveFit);
}

frmNonlinCurveFit::~frmNonlinCurveFit()
{
    LastSize_FormNonlinCurveFit=this->size();
}

void frmNonlinCurveFit::CreateActions(void)
{
    actClose = new QAction(tr("&Close"), this);
    //actClose->setShortcut(tr("Esc"));
    actClose->setStatusTip(tr("Close this Window"));
    connect(actClose, SIGNAL(triggered()), this, SLOT(doClose()));
    actOpen= new QAction(tr("&Open..."), this);
    actOpen->setShortcut(tr("Ctrl+O"));
    connect(actOpen, SIGNAL(triggered()), this, SLOT(doOpen()));
    actSave= new QAction(tr("&Save..."), this);
    actSave->setShortcut(tr("Ctrl+S"));
    connect(actSave, SIGNAL(triggered()), this, SLOT(doSave()));
    actResetFit= new QAction(tr("&Reset fit parameters"), this);
    connect(actResetFit, SIGNAL(triggered()), this, SLOT(doResetFit()));
    actLoadFit= new QAction(tr("&Load current fit"), this);
    connect(actLoadFit, SIGNAL(triggered()), this, SLOT(doLoadFit()));
    actAutoLoad= new QAction(tr("&Autoload"), this);
    actAutoLoad->setCheckable(TRUE);
    actAutoLoad->setChecked(TRUE);
    connect(actAutoLoad, SIGNAL(triggered()), this, SLOT(doAutoLoad()));
    actUpdate= new QAction(tr("&Update"), this);
    connect(actUpdate, SIGNAL(triggered()), this, SLOT(doUpdate()));
    actHelpOnContext= new QAction(tr("&On context"), this);
    actHelpOnContext->setShortcut(tr("Shift+F1"));
    connect(actHelpOnContext, SIGNAL(triggered()), this, SLOT(doHelpContext()));
    actHelpOnFit = new QAction(tr("&On fit"), this);
    connect(actHelpOnFit, SIGNAL(triggered()), this, SLOT(doHelpFit()));
}

void frmNonlinCurveFit::update_nonl_frame(void)
{
    int i;
    //XmString str = XmStringCreateLocalized(nonl_opts.title);
    //XtVaSetValues(nonl_title_item, XmNlabelString, str, NULL);
    lblAFit->setText(QString(nonl_opts.title));
    /*
 * If I define only XmALIGNMENT_CENTER (default!) then it's ignored - bug in Motif???
 */
    //XtVaSetValues(nonl_title_item, XmNalignment, XmALIGNMENT_BEGINNING, NULL);
    //XtVaSetValues(nonl_title_item, XmNalignment, XmALIGNMENT_CENTER, NULL);
    //XmStringFree(str);

    strcpy(buf,nonl_opts.formula);
    SetDecimalSeparatorToUserValue(buf);
    SetTextString(tabMain->ledFormula, buf);
    sprintf(buf, "%g", nonl_opts.tolerance);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(tabMain->ledTolerance, buf);
    SetOptionChoice(tabMain->selParameters, nonl_opts.parnum);
    tabMain->paraNumberChanged(nonl_opts.parnum);//to rescale the parameter-entries
    for (i = 0; i < MAXPARM; i++)
    {
        sprintf(buf, "%g", nonl_parms[i].value);
        SetDecimalSeparatorToUserValue(buf);
        //tabMain->spreadParameters->fitlines[i]->ledValue
        xv_setstr(tabMain->spreadParameters->fitlines[i]->ledValue, buf);
        SetToggleButtonState(tabMain->spreadParameters->fitlines[i]->chkBonds, nonl_parms[i].constr);
        sprintf(buf, "%g", nonl_parms[i].min);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(tabMain->spreadParameters->fitlines[i]->ledLowerBound, buf);
        SetSensitive(tabMain->spreadParameters->fitlines[i]->ledLowerBound, nonl_parms[i].constr);
        sprintf(buf, "%g", nonl_parms[i].max);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(tabMain->spreadParameters->fitlines[i]->ledHighterBound, buf);
        SetSensitive(tabMain->spreadParameters->fitlines[i]->ledHighterBound, nonl_parms[i].constr);
        /*if (i < nonl_opts.parnum) {
                if (!XtIsManaged (nonl_parm_item[i])) {
                    ManageChild(nonl_parm_item[i]);
                }
            } else {
                if (XtIsManaged (nonl_parm_item[i])) {
                    UnmanageChild(nonl_parm_item[i]);
                }
            }*/
    }

    actAutoLoad->setChecked(nonl_prefs.autoload);
    SetOptionChoice(tabAdvanced->selLoad, nonl_prefs.load);

    if (nonl_prefs.load == LOAD_FUNCTION) {
        SetSensitive(tabAdvanced->ledStartLoadAt, true);
        SetSensitive(tabAdvanced->ledStopLoadAt, true);
        SetSensitive(tabAdvanced->ledNumberOfPoints, true);
    } else {
        SetSensitive(tabAdvanced->ledStartLoadAt, false);
        SetSensitive(tabAdvanced->ledStopLoadAt, false);
        SetSensitive(tabAdvanced->ledNumberOfPoints, false);
    }

    if (GetOptionChoice(tabAdvanced->selWeights) == WEIGHT_CUSTOM) {
        SetSensitive(tabAdvanced->ledFunction, true);
    } else {
        SetSensitive(tabAdvanced->ledFunction, false);
    }

    sprintf(buf, "%g", nonl_prefs.start);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(tabAdvanced->ledStartLoadAt, buf);
    sprintf(buf, "%g", nonl_prefs.stop);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(tabAdvanced->ledStopLoadAt, buf);
    sprintf(buf, "%d", nonl_prefs.npoints);
    xv_setstr(tabAdvanced->ledNumberOfPoints, buf);

    grpSource->update_number_of_entries();
    grpDestination->update_number_of_entries();
}

void frmNonlinCurveFit::init(void)
{
    update_nonl_frame();
    int nr=1,sel=get_cg();
    grpSource->listGraph->set_new_selection(nr,&sel);
    grpSource->listSet->set_graph_number(sel,false);
    grpDestination->listGraph->set_new_selection(nr,&sel);
    grpDestination->listSet->set_graph_number(sel,false);
}

bool frmNonlinCurveFit::read_fit_options(void)
{
bool erro=false;
    reset_nonl();
    nonl_opts.formula = copy_string(nonl_opts.formula,tabMain->ledFormula->text().toLatin1());// GetTextString(nonl_formula_item));
    ReplaceDecimalSeparator(nonl_opts.formula);
    nonl_opts.nsteps = (int) GetSpinChoice(tabMain->selIterations);//nonl_nsteps_item);
    if (xv_evalexpr(tabMain->ledTolerance,&nonl_opts.tolerance)==RETURN_FAILURE)
    {
        stufftext(tr("Invalid tolerance entered; tolerance set to 0.01!").toLocal8Bit().constData());
        nonl_opts.tolerance=0.01;
    }
    //nonl_opts.tolerance = atof(xv_getstr(tabMain->ledTolerance));
    nonl_opts.parnum = GetOptionChoice(tabMain->selParameters);
    for (int i = 0; i < nonl_opts.parnum; i++) {
        strcpy(buf, xv_getstr(tabMain->spreadParameters->fitlines[i]->ledValue));// nonl_value_item[i]));
        ReplaceDecimalSeparator(buf);
        if (sscanf(buf, "%lf", &nonl_parms[i].value) != 1) {
            errmsg(tr("Invalid input in parameter field").toLocal8Bit().constData());
            erro=true;
        }
        nonl_parms[i].constr = GetToggleButtonState(tabMain->spreadParameters->fitlines[i]->chkBonds);// nonl_constr_item[i]);
        if (nonl_parms[i].constr) {
            strcpy(buf, xv_getstr(tabMain->spreadParameters->fitlines[i]->ledLowerBound));// nonl_lowb_item[i]));
            ReplaceDecimalSeparator(buf);
            if (sscanf(buf, "%lf", &nonl_parms[i].min) != 1) {
                errmsg(tr("Invalid input in low-bound field").toLocal8Bit().constData());
                erro=true;
            }
            strcpy(buf, xv_getstr(tabMain->spreadParameters->fitlines[i]->ledHighterBound));// nonl_uppb_item[i]));
            ReplaceDecimalSeparator(buf);
            if (sscanf(buf, "%lf", &nonl_parms[i].max) != 1) {
                errmsg(tr("Invalid input in upper-bound field").toLocal8Bit().constData());
                erro=true;
            }
            if ((nonl_parms[i].value < nonl_parms[i].min) || (nonl_parms[i].value > nonl_parms[i].max)) {
                errmsg(tr("Initial values must be within bounds").toLocal8Bit().constData());
                erro=true;
            }
        }
    }//end i-loop (load all parameters)
return erro;
}

void frmNonlinCurveFit::doApply(void)
{
static int ApplyRunning=false;
if (ApplyRunning==true) return;
ApplyRunning=true;
silent_nonl_fit=false;
    int i,itmp;
    int src_gno,dest_gno, src_setno;
    int resno,newset;
    char *fstr;
    int nlen, wlen;
    int weight_method;
    double *ytmp, *warray;
    int restr_type, restr_negate;
    char *rarray=NULL;
    int ns1,*svalues1=new int[2];
    int ns2,*svalues2=new int[2];
    QString save_formula;
    svalues1[0]=svalues2[0]=svalues1[1]=svalues2[1]=-1;
    ApplyError=false;
    if (GetSingleListChoice(grpSource->listGraph, &src_gno) != RETURN_SUCCESS)
    {
        errmsg(tr("No source graph selected").toLocal8Bit().constData());
        ApplyError=true;
        ApplyRunning=false;
        return;
    }
    grpSource->listSet->get_selection(&ns1,&svalues1);
    //if (GetSingleListChoice(grpSource->listSet, &src_setno) != RETURN_SUCCESS)
    if (ns1<1)
    {
        errmsg(tr("No source set selected").toLocal8Bit().constData());
        ApplyError=true;
        ApplyRunning=false;
        return;
    }
    newset=-1;
    GetSingleListChoice(grpDestination->listGraph, &dest_gno);
    grpDestination->listSet->get_selection(&ns2,&svalues2);
    if (ns1>1)//nr of source sets > 1 --> combine to one new temporary set
    {
        resno=0;
        ApplyError=false;
        nonl_opts.nsteps=dataset_cols(src_gno,svalues1[0]);
        for (int i=0;i<ns1;i++)
        {
            resno+=getsetlength(src_gno,svalues1[i]);
            if (nonl_opts.nsteps!=dataset_cols(src_gno,svalues1[i])) ApplyError=true;
        }
        if (ApplyError==true)
        {
            errmsg(tr("Please select source sets with the same column-count.").toLocal8Bit().constData());
            ApplyRunning=false;
            return;
        }
        ApplyError=false;
        newset=nextset(src_gno);
        copyset(src_gno,svalues1[0],src_gno,newset);
        setlength(src_gno,newset,resno);
//cout << "new combined temporary set generated=" << src_gno << "." << newset << endl;
        if (inhibit_set_legend==0)
        set_legend_string(src_gno,newset,"");
        resno=0;
        for (int i=0;i<ns1;i++)//go through all selected sets
        {
            for (int j=0;j<nonl_opts.nsteps;j++)//go through all columns
            {
                memcpy(g[src_gno].p[newset].data.ex[j]+resno,g[src_gno].p[svalues1[i]].data.ex[j],getsetlength(src_gno,svalues1[i])*sizeof(double));
            }
            resno+=getsetlength(src_gno,svalues1[i]);
        }
        sortset(src_gno,newset,DATA_X,dataset_type(src_gno,newset));
        src_setno=newset;
    }
    else
        src_setno=svalues1[0];

    ApplyError=read_fit_options();//the formula is read here!

    if (ApplyError==true)
    {
        ApplyRunning=false;
        return;
    }

    //save_formula=QString(nonl_opts.formula);
    save_formula=tabMain->ledFormula->text();
//qDebug() << "A Save_Formula=" << save_formula;
    ///Undo-Stuff
    SaveFitSettings();
    ListOfOldStates.clear();
    ListOfChanges.clear();

    //save_formula=save_formula.toUpper();
//qDebug() << "B Save_Formula=" << save_formula;
    if (nonl_opts.nsteps)
    {
        /* apply weigh function */
        nlen = getsetlength(src_gno, src_setno);
        weight_method = GetOptionChoice(tabAdvanced->selWeights);// nonl_weigh_item);
        switch (weight_method) {
        case WEIGHT_Y:
        case WEIGHT_Y2:
            ytmp = getcol(src_gno, src_setno, DATA_Y);
            for (i = 0; i < nlen; i++) {
                if (ytmp[i] == 0.0) {
                    errmsg(tr("Divide by zero while calculating weights").toLocal8Bit().constData());
                    ApplyError=true;
                    ApplyRunning=false;
                    return;// RETURN_FAILURE;
                }
            }
            warray = (double*) xmalloc(nlen*sizeof(double));//SIZEOF_DOUBLE);
            if (warray == NULL) {
                errmsg(tr("xmalloc failed in do_nonl_proc()").toLocal8Bit().constData());
                ApplyError=true;
                ApplyRunning=false;
                return;// RETURN_FAILURE;
            }
            for (i = 0; i < nlen; i++) {
                if (weight_method == WEIGHT_Y) {
                    warray[i] = 1.0/ytmp[i];
                } else {
                    warray[i] = 1.0/(ytmp[i]*ytmp[i]);
                }
            }
            break;
        case WEIGHT_DY:
            ytmp = getcol(src_gno, src_setno, DATA_Y1);
            if (ytmp == NULL) {
                errmsg(tr("The set doesn't have dY data column").toLocal8Bit().constData());
                ApplyError=true;
                ApplyRunning=false;
                return;// RETURN_FAILURE;
            }
            for (i = 0; i < nlen; i++) {
                if (ytmp[i] == 0.0) {
                    errmsg(tr("Divide by zero while calculating weights").toLocal8Bit().constData());
                    ApplyError=true;
                    ApplyRunning=false;
                    return;// RETURN_FAILURE;
                }
            }
            warray = (double*)xmalloc(nlen*sizeof(double));//SIZEOF_DOUBLE);
            if (warray == NULL) {
                errmsg(tr("xmalloc failed in do_nonl_proc()").toLocal8Bit().constData());
                ApplyError=true;
                ApplyRunning=false;
                return;
            }
            for (i = 0; i < nlen; i++) {
                warray[i] = 1/(ytmp[i]*ytmp[i]);
            }
            break;
        case WEIGHT_CUSTOM:
            if (set_parser_setno(src_gno, src_setno) != RETURN_SUCCESS) {
                errmsg(tr("Bad set").toLocal8Bit().constData());
                ApplyError=true;
                ApplyRunning=false;
                return;// RETURN_FAILURE;
            }
            fstr = xv_getstr(tabAdvanced->ledFunction);// nonl_wfunc_item);
            ReplaceDecimalSeparator(fstr);
            if (v_scanner(fstr, &wlen, &warray) != RETURN_SUCCESS) {
                errmsg(tr("Error evaluating expression for weights").toLocal8Bit().constData());
                ApplyError=true;
                ApplyRunning=false;
                return;// RETURN_FAILURE;
            }
            if (wlen != nlen) {
                errmsg(tr("The array of weights has different length").toLocal8Bit().constData());
                xfree(warray);
                ApplyError=true;
                ApplyRunning=false;
                return;// RETURN_FAILURE;
            }
            break;
        default:
            warray = NULL;
            break;
        }
        /* apply restriction */
        //restr_type = GetOptionChoice(tabAdvanced->selRestrictions);//restr_item->r_sel);
        switch (tabAdvanced->selRestrictions->currentIndex())//special type for restrictions
        {
        case 0:
        default:
            restr_type=RESTRICT_NONE;
            break;
        case 1:
            restr_type=RESTRICT_REG0;
            break;
        case 2:
            restr_type=RESTRICT_REG1;
            break;
        case 3:
            restr_type=RESTRICT_REG2;
            break;
        case 4:
            restr_type=RESTRICT_REG3;
            break;
        case 5:
            restr_type=RESTRICT_REG4;
            break;
        case 6:
            restr_type=RESTRICT_WORLD;
            break;
        }
        restr_negate = GetToggleButtonState(tabAdvanced->chkNegated);// restr_item->negate);
        resno = get_restriction_array(src_gno, src_setno,restr_type, restr_negate, &rarray);
        if (resno != RETURN_SUCCESS) {
            errmsg(tr("Error in restriction evaluation").toLocal8Bit().constData());
            xfree(warray);
            ApplyError=true;
            ApplyRunning=false;
            return;// RETURN_FAILURE;
        }
        sprintf(dummy,"with G%d",src_gno);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"fit formula \"%s\"",nonl_opts.formula);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"fit with %d parameters",nonl_opts.parnum);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"fit prec %f",nonl_opts.tolerance);
        ListOfChanges << QString(dummy);
        for (i=0;i<nonl_opts.parnum;i++)
        {
            sprintf(dummy,"a%d = %f",i,nonl_parms[i].value);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"a%d constraints %s",i,nonl_parms[i].constr==true?"on":"off");
            ListOfChanges << QString(dummy);
            sprintf(dummy,"a%dmin = %f",i,nonl_parms[i].min);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"a%dmax = %f",i,nonl_parms[i].max);
            ListOfChanges << QString(dummy);
        }
        sprintf(dummy,"nonlfit (s%d, %d)",src_setno,nonl_opts.nsteps);
        ListOfChanges << QString(dummy);

        /* The fit itself! */
        resno = do_nonlfit(src_gno, src_setno, warray, rarray, nonl_opts.nsteps);

        nonl_opts.formula = copy_string(nonl_opts.formula,save_formula.toLatin1());// GetTextString(nonl_formula_item));
        ReplaceDecimalSeparator(nonl_opts.formula);
        //nonl_opts.formula = copy_string(nonl_opts.formula,tabMain->ledFormula->text().toLatin1());
        xfree(warray);
        xfree(rarray);

        if (resno != RETURN_SUCCESS) {
            errmsg(tr("Fatal error in do_nonlfit()").toLocal8Bit().constData());
            ApplyError=true;
            ApplyRunning=false;
            return;// RETURN_FAILURE;
        }

        for (i = 0; i < nonl_opts.parnum; i++)
        {
            sprintf(buf, "%g", nonl_parms[i].value);
            SetDecimalSeparatorToUserValue(buf);
            xv_setstr(tabMain->spreadParameters->fitlines[i]->ledValue, buf);
        }
    }

    /*//deleted, because the formula is saved automatically in "do_nonlfit()" - in this way it will also work scripts
    for (i = 0; i < nonl_opts.parnum; i++)
    {
        sprintf(buf,"A%d",i);
        a1=QString(buf);
        sprintf(buf, "%g", nonl_parms[i].value);
        v1=QString(buf);
        save_formula.replace(a1,v1);
    }

strcpy(last_formula,save_formula.toLatin1().constData());
for (i=0;i<nonl_opts.parnum;i++)
last_fit_falues[i]=nonl_parms[i].value;*/

/*
 * Select & activate a set to load results to
 */

    load_nonl_fit(src_gno, src_setno, FALSE);

    nonl_opts.formula = copy_string(nonl_opts.formula,save_formula.toLatin1());
    ReplaceDecimalSeparator(nonl_opts.formula);

    /*if (GetSingleListChoice(grpDestination->listSet, &dest_setno) != RETURN_SUCCESS))
    {

    }*/

    //cout << "newset=" << newset << " last formula=#" << last_formula << "#" << endl;
    GetSingleListChoice(grpDestination->listGraph, &itmp);
    if (newset!=-1)//we have created a new set for the fit --> delete it
    {
        /*cout << "originally selected:" << endl;
        for (int i=0;i<ns1;i++)
        {
        cout << "G" << src_gno << ".S" << svalues1[i] << endl;
        }
    */

        GetSingleListChoice(grpDestination->listSet,&resno);

        //cout << "src: G" << src_gno << ".S" << src_setno << ", newset=" << newset << endl;
        //cout << "Destination: G" << nsteps << ".S" << resno << " oder doch " << svalues2[0] << endl;
        //cout << "dest_graph=" << fit_destination_graph << " dest_set=" << fit_destination_set << endl;

        //grpSource->listSet->set_new_selection(ns1,svalues1);
        ns2=1;
        if (itmp==src_gno && src_setno<resno)
        {
            do_swapset(src_gno,src_setno,itmp,resno);
            killsetdata(itmp,resno);
            svalues2[0]=src_setno;
            //cout << "musste tauschen: G" << src_gno << ".S" << src_setno << " <-> G" << nsteps << ".S" << resno << endl;
        }
        else
        {
            killsetdata(src_gno,src_setno);
            svalues2[0]=resno;
        }
        //cout << "Killed G" << nsteps << ".S" << resno << endl;
        //cout << "Marking G" << nsteps << ".S" << svalues2[0] << endl;
        fit_destination_graph=itmp;
        fit_destination_set=svalues2[0];
        grpDestination->mark_single_set(itmp,svalues2[0]);
        grpSource->update_number_of_entries();

        //grpDestination->listSet->set_new_selection(ns1,svalues1);
        //update_set_lists(src_gno);
        //if (src_gno!=nsteps) update_set_lists(nsteps);
        //y = a0*exp(-((x-a1)/a2)^2)+a3*exp(-((x-a4)/a5)^2)
    }

    tabMain->ledFormula->setText(save_formula);
    mainWin->mainArea->completeRedraw();

    update_set_lists(src_gno);//necessary to show sets that have just been generated (or have changed setlengths)
    if (src_gno!=itmp) update_set_lists(itmp);//necessary to show sets that have just been generated (or have changed setlengths)
    grpSource->listSet->set_new_selection(ns1,svalues1);
    grpDestination->set_graph_nr(dest_gno);
    //cout << "ns2=" << ns2 << endl;

    if (fit_destination_set!=-1)
    {
        ns2=1;
        svalues2[0]=fit_destination_set;
    }

    grpDestination->listSet->set_new_selection(ns2,svalues2);
    ///Undo-Stuff
    SaveFitAfter();
    ApplyRunning=false;
    if (FormReportFitParameters!=NULL)
    {
    FormReportFitParameters->init();
    }
    return;// RETURN_SUCCESS;
}

void frmNonlinCurveFit::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmNonlinCurveFit::doClose(void)
{
    hide();
}

void frmNonlinCurveFit::doOpen(void)
{
QString openfilename;
    if (auto_set_cwd==TRUE)
    {
    openfilename=QString::fromLocal8Bit(get_workingdir());
    }
    else
    {
    openfilename=Last_Dialog_Path[READ_FIT_PARAM];
    }
//qDebug() << "openfilename=" << openfilename;
if (should_open_grace_file_dialog())
{
    if (frmOpenFitPara==NULL)
    {
        frmOpenFitPara=new frmIOForm(READ_FIT_PARAM,this);
        connect(frmOpenFitPara,SIGNAL(newFileSelectedForIO(int,QString,bool,bool,bool)),SLOT(IOrequested(int,QString,bool,bool,bool)));
    }
//qDebug() << "A stdExtension=" << frmOpenFitPara->stdExtension << "FilterExtension=" << frmOpenFitPara->selector->filterExtension;
    frmOpenFitPara->init(openfilename.toLocal8Bit().data());
//qDebug() << "B stdExtension=" << frmOpenFitPara->stdExtension << "FilterExtension=" << frmOpenFitPara->selector->filterExtension;
    frmOpenFitPara->selector->newFilterEntered();
    frmOpenFitPara->show();
    frmOpenFitPara->raise();
}
else
{
mainWin->UseOperatingSystemFileDialog(READ_FIT_PARAM,tr("QtGrace: Open fit parameter file"),openfilename,tr("Fit parameters (*.fit);;All files (*)"));
}
}

void frmNonlinCurveFit::doSave(void)
{
QString openfilename;
    if (auto_set_cwd==TRUE)
    {
    openfilename=QString::fromLocal8Bit(get_workingdir());
    }
    else
    {
    openfilename=Last_Dialog_Path[WRITE_FIT_PARAM];
    }
//qDebug() << "openfilename=" << openfilename;
if (should_open_grace_file_dialog())
{
    if (frmSaveFitPara==NULL)
    {
        frmSaveFitPara=new frmIOForm(WRITE_FIT_PARAM,this);
        connect(frmSaveFitPara,SIGNAL(newFileSelectedForIO(int,QString,bool,bool,bool)),SLOT(IOrequested(int,QString,bool,bool,bool)));
    }
    frmSaveFitPara->init(openfilename.toLocal8Bit().data());
    frmSaveFitPara->selector->newFilterEntered();
    frmSaveFitPara->show();
    frmSaveFitPara->raise();
}
else
{
mainWin->UseOperatingSystemFileDialog(WRITE_FIT_PARAM,tr("QtGrace: Save fit parameter file"),openfilename,tr("Fit parameters (*.fit);;All files (*)"));
}
}

void frmNonlinCurveFit::doResetFit(void)
{
    reset_nonl();
    update_nonl_frame();
}

void frmNonlinCurveFit::doLoadFit(void)
{
    int src_gno, src_setno;
    if (GetSingleListChoice(grpSource->listGraph, &src_gno) !=
            RETURN_SUCCESS) {
        errmsg(tr("No source graph selected").toLocal8Bit().constData());
        return;
    }
    if (GetSingleListChoice(grpSource->listSet, &src_setno) !=
            RETURN_SUCCESS) {
        errmsg(tr("No source set selected").toLocal8Bit().constData());
        return;
    }
    load_nonl_fit(src_gno, src_setno, TRUE);
}

void frmNonlinCurveFit::doAutoLoad(void)
{}

void frmNonlinCurveFit::doUpdate(void)
{
    update_nonl_frame();
}

void frmNonlinCurveFit::doHelpContext(void)
{
    setCursor(QCursor(Qt::WhatsThisCursor));
}

void frmNonlinCurveFit::doHelpFit(void)
{
    HelpCB("doc/UsersGuide.html#non-linear-fit");
}

void frmNonlinCurveFit::load_nonl_fit(int src_gno, int src_setno, int force)
{
    int dest_gno, dest_setno;
    int i, npts = 0;
    double delx, *xfit, *y, *yfit;
    fit_destination_graph=-1;
    fit_destination_set=-1;
    if (GetSingleListChoice(grpDestination->listGraph, &dest_gno) != RETURN_SUCCESS)
    {
        errmsg(tr("No destination graph selected").toLocal8Bit().constData());
        return;// RETURN_FAILURE;
    }
    if (GetSingleListChoice(grpDestination->listSet, &dest_setno) != RETURN_SUCCESS)
    {
        /* no dest sel selected; allocate new one */
        dest_setno = nextset(dest_gno);
        //newset=dest_setno;
        if (dest_setno == -1)
        {
            return;// RETURN_FAILURE;
        }
        else
        {
            activateset(dest_gno, dest_setno);
        }
    }

    nonl_prefs.autoload = actAutoLoad->isChecked()==true?1:0;
    nonl_prefs.load = GetOptionChoice(tabAdvanced->selLoad);

    if (nonl_prefs.load == LOAD_FUNCTION)
    {
        if (xv_evalexpr(tabAdvanced->ledStartLoadAt, &nonl_prefs.start) != RETURN_SUCCESS) {
            errmsg(tr("Invalid input in start field").toLocal8Bit().constData());
            return;// RETURN_FAILURE;
        }
        if (xv_evalexpr(tabAdvanced->ledStopLoadAt, &nonl_prefs.stop) != RETURN_SUCCESS) {
            errmsg(tr("Invalid input in start field").toLocal8Bit().constData());
            return;// RETURN_FAILURE;
        }
        if (xv_evalexpri(tabAdvanced->ledNumberOfPoints, &nonl_prefs.npoints) != RETURN_SUCCESS) {
            errmsg(tr("Invalid input in start field").toLocal8Bit().constData());
            return;// RETURN_FAILURE;
        }
        if (nonl_prefs.npoints <= 1) {
            errmsg(tr("Number of points must be > 1").toLocal8Bit().constData());
            return;// RETURN_FAILURE;
        }
    }

    if (force || nonl_prefs.autoload)
    {
        switch (nonl_prefs.load) {
        case LOAD_VALUES:
        case LOAD_RESIDUALS:
            npts = getsetlength(src_gno, src_setno);
            setlength(dest_gno, dest_setno, npts);
            copycol2(src_gno, src_setno, dest_gno, dest_setno, DATA_X);
            break;
        case LOAD_FUNCTION:
            npts  = nonl_prefs.npoints;

            setlength(dest_gno, dest_setno, npts);

            delx = (nonl_prefs.stop - nonl_prefs.start)/(npts - 1);
            xfit = getx(dest_gno, dest_setno);
            for (i = 0; i < npts; i++) {
                xfit[i] = nonl_prefs.start + i * delx;
            }
            sprintf(dummy,"%s",tabAdvanced->ledXFunction->text().toLatin1().constData());
            if (dummy[0]=='$' && dummy[1]=='t' && dummy[2]=='\0') break;//nothing more to do here
            sprintf(dummy,"X=%s",tabAdvanced->ledXFunction->text().toLatin1().constData());//we have to calculate the real x-values using the $t-parameter
            QString f1(dummy);
            f1.replace("$t","X");//replace $t by X, because we loaded the $t-values into the X-column
            strcpy(dummy,f1.toLatin1().constData());
            (void)do_compute(dest_gno, dest_setno, dest_gno, dest_setno, NULL, dummy);//transform X-values
            break;
        }

        setcomment(dest_gno, dest_setno, nonl_opts.formula);
        char * tmp_formula=new char[strlen(nonl_opts.formula)*8+8];
        strcpy(tmp_formula,nonl_opts.formula);
        if (do_compute(dest_gno, dest_setno, dest_gno, dest_setno, NULL, tmp_formula)!=RETURN_SUCCESS)//evaluate formula for y-values
        killset(dest_gno, dest_setno);
        nonl_opts.formula=copy_string(nonl_opts.formula,tmp_formula);
        delete[] tmp_formula;

        if (nonl_prefs.load == LOAD_RESIDUALS)
        { /* load residuals */
            y = gety(src_gno, src_setno);
            yfit = gety(dest_gno, dest_setno);
            for (i = 0; i < npts; i++)
            {
                yfit[i] -= y[i];
            }
        }
        /// mainWin->mainArea->completeRedraw();
        grpSource->mark_single_set(src_gno, src_setno);
        grpDestination->mark_single_set(dest_gno,dest_setno);

        //update_set_lists(dest_gno);
        //cout << "destination= G" << dest_gno << ".S" << dest_setno << endl;
        fit_destination_graph=dest_gno;
        fit_destination_set=dest_setno;
    }
    return;// RETURN_SUCCESS;
}

void frmNonlinCurveFit::IOrequested(int type,QString file,bool exists,bool writeable,bool readable)
{
    char filename[1024];
//int res;
    FILE *pp;
    (void)exists;
    (void)writeable;
    (void)readable;
    strcpy(filename,file.toLocal8Bit());
    /*//for testing -- maybe tests needed (file readable ...)
    cout << "file=" << buf << endl;
    cout << "type=" << type << endl;
    cout << "exists=" << exists << endl;
    cout << "writeable=" << writeable << endl;
    cout << "readable=" << readable << endl;*/
    if (type==WRITE_FIT_PARAM)
    {
        if (frmSaveFitPara)
        frmSaveFitPara->hide();
        ApplyError=read_fit_options();
            if (ApplyError==true)
            {
            errmsg(tr("Saving of fit parameters aborted").toLocal8Bit().constData());
            return;
            }
        pp = grace_openw(filename);
        if (pp != NULL)
        {
            if (frmSaveFitPara)
            nonl_opts.title = copy_string(nonl_opts.title, xv_getstr(frmSaveFitPara->ledTitle));
            else
            nonl_opts.title = copy_string(nonl_opts.title, xv_getstr(lblAFit));
            put_fitparms(pp, 0);
            grace_close(pp);
        }
    }
    else//read fit parameters
    {
        if (frmOpenFitPara)
        frmOpenFitPara->hide();
        reset_nonl();
        //res = getparms(filename);
        (void)getparms(filename);
        update_nonl_frame();
    }
}

void frmNonlinCurveFit::adjustToFontSize(void)
{
    tabMain->spreadParameters->adjustToFontSize();
}

void frmNonlinCurveFit::showEvent(QShowEvent * event)
{
QDialog::showEvent(event);
tabMain->paraNumberChanged(tabMain->selParameters->currentValue());
}

frm2DFit::frm2DFit(QWidget * parent):QDialog(parent)
{
    setWindowTitle(tr("QtGrace: 2D-fitting"));
    setWindowIcon(QIcon(*GraceIcon));
int nr=2;
QString entr[8];
block_guessing=false;
grpSource=new grpSelect(tr("Fit-source"),this);
grpSource->listSet->setBehavior(true,false,false);
nr=7;
entr[0]=tr("None");
entr[1]=tr("Region 0");
entr[2]=tr("Region 1");
entr[3]=tr("Region 2");
entr[4]=tr("Region 3");
entr[5]=tr("Region 4");
entr[6]=tr("Inside graph");
selRestrictions=new StdSelector(this,tr("Restriction:"),nr,entr);
chkNegated=new QCheckBox(tr("Negated"),this);
chkGuessStartingValues=new QCheckBox(tr("Guess starting values"),this);
chkGuessStartingValues->setToolTip(tr("If checked the start-parameters for the fit are guessed.\nThe guessed values replace the settings below."));
chkGuessStartingValues->setChecked(true);
chkShowResult=new QCheckBox(tr("Show fit result"),this);
chkShowResult->setToolTip(tr("If checked a new set will be generated to show the fit-result.\nThe parameter is the angle phi (usually 0-2*PI).\nIf not checked only the results will be shown in the console."));
chkShowResult->setChecked(true);
nr=2;
entr[0]=tr("Circle");
entr[1]=tr("Ellipse");
selObject=new StdSelector(this,tr("Object to fit:"),nr,entr);
selNrOfPoints=new stdIntSelector(this,tr("Length:"),1,1e6);
selNrOfPoints->setValue(200);
    for (int i=0;i<8;i++)
    {
    selParameter[i]=new stdLineEdit(this,QString(""));
    }
selParameter[0]->lblText->setText(tr("x0="));
selParameter[1]->lblText->setText(tr("y0="));
selParameter[2]->lblText->setText(tr("a="));
selParameter[3]->lblText->setText(tr("b="));
selParameter[4]->lblText->setText(tr("r="));
selParameter[5]->lblText->setText(tr("alpha="));
selParameter[6]->lblText->setText(tr("phi-start="));
selParameter[7]->lblText->setText(tr("phi-stop="));
selParameter[6]->setText(QString("0"));
selParameter[7]->setText(QString("2*PI"));

lblResults=new QLabel(QString(""),this);//to show some results for ellipses (for circles everything is shown already)

cmdFit=new QPushButton(tr("Fit"),this);
cmdExit=new QPushButton(tr("Close"),this);

layout=new QGridLayout(this);
layout->setSpacing(STD_SPACING);
//layout->setMargin(STD_MARGIN);
layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);

layout->addWidget(grpSource,0,0,1,2);
layout->addWidget(selRestrictions,1,0,1,1);
layout->addWidget(chkNegated,1,1,1,1);
layout->addWidget(selObject,2,0,1,2);
layout->addWidget(chkGuessStartingValues,3,0,1,2);
layout->addWidget(selParameter[0],4,0,1,1);
layout->addWidget(selParameter[1],4,1,1,1);
layout->addWidget(selParameter[2],5,0,1,1);
layout->addWidget(selParameter[3],5,1,1,1);
layout->addWidget(selParameter[4],6,0,1,1);
layout->addWidget(selParameter[5],6,0,1,1);
layout->addWidget(lblResults,7,0,1,2);
layout->addWidget(chkShowResult,8,0,1,1);
layout->addWidget(selNrOfPoints,8,1,1,1);
layout->addWidget(selParameter[6],9,0,1,1);
layout->addWidget(selParameter[7],9,1,1,1);
layout->addWidget(cmdFit,10,0,1,1);
layout->addWidget(cmdExit,10,1,1,1);

setLayout(layout);

connect(cmdFit,SIGNAL(clicked()),SLOT(doFit()));
connect(cmdExit,SIGNAL(clicked()),SLOT(doClose()));
connect(chkShowResult,SIGNAL(toggled(bool)),SLOT(showToggled(bool)));
connect(chkGuessStartingValues,SIGNAL(toggled(bool)),SLOT(guessToggled(bool)));
connect(selObject,SIGNAL(currentIndexChanged(int)),SLOT(objectSelectionChanged(int)));
connect(grpSource->listSet,SIGNAL(new_selection(int)),SLOT(newSetSelected(int)));
connect(selRestrictions,SIGNAL(currentIndexChanged(int)),SLOT(newSetSelected(int)));
connect(chkNegated,SIGNAL(toggled(bool)),SLOT(guessToggled(bool)));
objectSelectionChanged(0);
showToggled(true);
resize(LastSize_Form2DFit);
}

frm2DFit::~frm2DFit()
{
    LastSize_Form2DFit=this->size();
}

void frm2DFit::init(void)
{

}

void frm2DFit::readInputs(void)
{
nr_of_points=selNrOfPoints->value();
x0=selParameter[0]->getDoubleValue();
y0=selParameter[1]->getDoubleValue();
a=selParameter[2]->getDoubleValue();
b=selParameter[3]->getDoubleValue();
if (b>a)//a>b is important --> switch a and b
{
r=a;
a=b;
b=r;
}
r=selParameter[4]->getDoubleValue();
alpha=selParameter[5]->getDoubleValue();
phi0=selParameter[6]->getDoubleValue();
phi1=selParameter[7]->getDoubleValue();
nr_of_points=selNrOfPoints->value();
switch (selRestrictions->currentIndex())
{
case 0:
default:
    restr_type=RESTRICT_NONE;
    break;
case 1:
    restr_type=RESTRICT_REG0;
    break;
case 2:
    restr_type=RESTRICT_REG1;
    break;
case 3:
    restr_type=RESTRICT_REG2;
    break;
case 4:
    restr_type=RESTRICT_REG3;
    break;
case 5:
    restr_type=RESTRICT_REG4;
    break;
case 6:
    restr_type=RESTRICT_WORLD;
    break;
}
restr_negate=(int)chkNegated->isChecked();
int nr;
int * sel=new int[2];
grpSource->listGraph->get_selection(&nr,&sel);
if (nr<1 || nr>1)
{
    sel_gno=sel_sno=-1;
    goto endReadInputs;
}
else
{
    sel_gno=sel[0];
}
grpSource->listSet->get_selection(&nr,&sel);
if (nr<1 || nr>1)
{
    sel_sno=-1;
    goto endReadInputs;
}
else
{
    sel_sno=sel[0];
}
endReadInputs:
delete[] sel;
}

void frm2DFit::reDisplayContents(void)
{
    for (int i=0;i<8;i++)
    {
    selParameter[i]->ReplaceNumberContents();
    }
}

void frm2DFit::objectSelectionChanged(int i)
{
    (void)i;
    if (selObject->currentIndex()==0)//circle
    {
        lblResults->setVisible(false);
        selParameter[2]->setVisible(false);
        selParameter[3]->setVisible(false);
        selParameter[4]->setVisible(true);
        selParameter[5]->setVisible(false);
    }
    else
    {
        lblResults->setVisible(true);
        selParameter[2]->setVisible(true);
        selParameter[3]->setVisible(true);
        selParameter[4]->setVisible(false);
        selParameter[5]->setVisible(true);
    }
    guessToggled(true);
}

void frm2DFit::showToggled(bool c)
{
    (void)c;
    if (chkShowResult->isChecked()==true)
    {
        selNrOfPoints->setVisible(true);
        selParameter[6]->setVisible(true);
        selParameter[7]->setVisible(true);
    }
    else
    {
        selNrOfPoints->setVisible(false);
        selParameter[6]->setVisible(false);
        selParameter[7]->setVisible(false);
    }
}

void frm2DFit::guessToggled(bool c)
{
    (void)c;
    if (block_guessing==true) return;
    readInputs();
    if (chkGuessStartingValues->isChecked()==true)
    {
        if (is_valid_setno(sel_gno,sel_sno))
        {
            if (selObject->currentIndex()==0)
            guess_circle(sel_gno,sel_sno,&x0,&y0,&r,restr_type,restr_negate);
            else
            guess_ellipse(sel_gno,sel_sno,&x0,&y0,&a,&b,&alpha,restr_type,restr_negate);
        selParameter[0]->setDoubleValue("%g",x0); //x0
        selParameter[1]->setDoubleValue("%g",y0); //y0
        selParameter[2]->setDoubleValue("%g",a); //a
        selParameter[3]->setDoubleValue("%g",b); //b
        selParameter[4]->setDoubleValue("%g",r); //r
        selParameter[5]->setDoubleValue("%g",alpha); //alpha
        }
    }
}

void frm2DFit::newSetSelected(int s)
{
    (void)s;
    guessToggled(true);
}

void frm2DFit::doFit(void)
{
int n_sno;
QString text,Restriction;
char buffer[1024];
double * yp,* y_saved;
double cor,chisq,theil,rms_pe;
bool rms_ok;
nonlparms sav_nonl_parms[MAXPARM];
nonlopts sav_nonl_opts;
ListOfChanges.clear();
ListOfOldStates.clear();
sav_nonl_opts.title=sav_nonl_opts.formula=NULL;
copy_nonl(nonl_parms,sav_nonl_parms,&nonl_opts,&sav_nonl_opts);
block_guessing=true;
    readInputs();
    silent_nonl_fit=true;
    if (selObject->currentIndex()==0)
    {
    //text=QString("#QTGRACE_SPECIAL FIT2D 0;");
    fit_circle(sel_gno,sel_sno,&n_sno,&x0,&y0,&r,restr_type,restr_negate);
    text=WriteFit2DString(selObject->currentIndex(),sel_gno,sel_sno,n_sno,x0,y0,r,r,alpha,phi0,phi1,nr_of_points,restr_type,restr_negate);
    //text+=QString::number(sel_gno)+QString(";")+QString::number(sel_sno)+QString(";")+QString::number(n_sno)+QString(";")+QString::number(x0)+QString(";")+QString::number(y0)+QString(";")+QString::number(r)+QString(";")+QString::number(restr_type)+QString(";")+QString::number(restr_negate);
    ListOfChanges << text;
    }
    else
    {
    //text=QString("#QTGRACE_SPECIAL FIT2D 1;");
    fit_ellipse(sel_gno,sel_sno,&n_sno,&x0,&y0,&a,&b,&alpha,restr_type,restr_negate);
    text=WriteFit2DString(selObject->currentIndex(),sel_gno,sel_sno,n_sno,x0,y0,a,b,alpha,phi0,phi1,nr_of_points,restr_type,restr_negate);
    //text+=QString::number(sel_gno)+QString(";")+QString::number(sel_sno)+QString(";")+QString::number(n_sno)+QString(";")+QString::number(x0)+QString(";")+QString::number(y0)+QString(";")+QString::number(a)+QString(";")+QString::number(b)+QString(";")+QString::number(alpha)+QString(";")+QString::number(restr_type)+QString(";")+QString::number(restr_negate);
    ListOfChanges << text;
    }
    y_saved=gety(sel_gno,sel_sno);//original
    yp=gety(sel_gno,n_sno);//fit-result
    calculate_fit_accuracy(yp,y_saved,getsetlength(sel_gno,sel_sno),&cor,&chisq,&theil,&rms_ok,&rms_pe);
    silent_nonl_fit=false;
//update the parameters
    selParameter[0]->setDoubleValue(sformat,x0); //x0
    selParameter[1]->setDoubleValue(sformat,y0); //y0
    selParameter[2]->setDoubleValue(sformat,a); //a
    selParameter[3]->setDoubleValue(sformat,b); //b
    selParameter[4]->setDoubleValue(sformat,r); //r
    selParameter[5]->setDoubleValue(sformat,alpha); //alpha
    Restriction.clear();
    if (restr_type!=RESTRICT_NONE)
    {
    Restriction=tr("Using restriction: ");
    switch (restr_type)
    {
    case RESTRICT_NONE:
    default:
        Restriction+=tr("No restriction");
        break;
    case RESTRICT_REG0:
    case RESTRICT_REG1:
    case RESTRICT_REG2:
    case RESTRICT_REG3:
    case RESTRICT_REG4:
        Restriction+=tr("Region ")+QString::number(restr_type);
        break;
    case RESTRICT_WORLD:
        Restriction+=tr("Inside graph");
        break;
    }
    if (restr_negate) Restriction+=tr(" (negated)");
    }
double s;
double delta=(phi1-phi0)/(nr_of_points-1);
double phi;
setlength(sel_gno,n_sno,nr_of_points);
    if (selObject->currentIndex()==0)//circle
    {
        if (chkShowResult->isChecked()==true)
        {
            for (int i=0;i<nr_of_points;i++)
            {
            phi=phi0+i*delta;
            g[sel_gno].p[n_sno].data.ex[DATA_X][i]=x0+r*cos(phi);
            g[sel_gno].p[n_sno].data.ex[DATA_Y][i]=y0+r*sin(phi);
            }
        }
        sprintf(buffer,"G%d.S%d",sel_gno,sel_sno);
        text=tr("Fit of circle onto set ")+QString(buffer);
            if (restr_type!=RESTRICT_NONE)
            text+=QString(", ")+Restriction;
        text+=tr("; Center = ( ");
        sprintf(buffer,sformat,x0);
        text+=QString(buffer)+tr(" | ");
        sprintf(buffer,sformat,y0);
        text+=QString(buffer)+tr(" ); Radius=");
        sprintf(buffer,sformat,r);
        text+=QString(buffer);
        setcomment(sel_gno,n_sno,text.toLocal8Bit().constData());
        if (inhibit_set_legend==0)
        set_legend_string(sel_gno,n_sno,text.toLocal8Bit().constData());

        sprintf(buffer,"G%d.S%d",sel_gno,sel_sno);
        text=tr("Fit of circle onto set ")+QString(buffer);
        stufftext(text.toLocal8Bit().constData());
            if (restr_type!=RESTRICT_NONE)
            stufftext(Restriction.toLocal8Bit().constData());
        text=tr("\nResults:");
        stufftext(text.toLocal8Bit().constData());
        text=tr("Center ( x0 | y0 ) = ( ");
        sprintf(buffer,sformat,x0);
        text+=QString(buffer)+tr(" | ");
        sprintf(buffer,sformat,y0);
        text+=QString(buffer)+tr(" )");
        stufftext(text.toLocal8Bit().constData());
        sprintf(buffer,sformat,r);
        text=tr("Radius r = ")+QString(buffer)+QString("\n");
        stufftext(text.toLocal8Bit().constData());
    }
    else//ellipse
    {
        if (chkShowResult->isChecked()==true)
        {
            for (int i=0;i<nr_of_points;i++)
            {
            phi=phi0+i*delta;
            g[sel_gno].p[n_sno].data.ex[DATA_X][i]=x0+a*cos(phi)*cos(alpha)-b*sin(phi)*sin(alpha);
            g[sel_gno].p[n_sno].data.ex[DATA_Y][i]=y0+a*cos(phi)*sin(alpha)+b*sin(phi)*cos(alpha);
            }
        }
        sprintf(buffer,"G%d.S%d",sel_gno,sel_sno);
        text=tr("Fit of ellipse onto set ")+QString(buffer);
            if (restr_type!=RESTRICT_NONE)
            text+=QString(", ")+Restriction;
        text+=tr("; Center = ( ");
        sprintf(buffer,sformat,x0);
        text+=QString(buffer)+QString(" | ");
        sprintf(buffer,sformat,y0);
        text+=QString(buffer)+QString(" ); a=");
        sprintf(buffer,sformat,a);
        text+=QString(buffer)+tr("; b=");
        sprintf(buffer,sformat,b);
        text+=QString(buffer)+tr("; alpha=");
        sprintf(buffer,sformat,alpha);
        text+=QString(buffer);
        setcomment(sel_gno,n_sno,text.toLocal8Bit().constData());
        if (inhibit_set_legend==0)
        set_legend_string(sel_gno,n_sno,text.toLocal8Bit().constData());

        sprintf(buffer,"G%d.S%d",sel_gno,sel_sno);
        text=tr("Fit of ellipse onto set ")+QString(buffer);
        stufftext(text.toLocal8Bit().constData());
            if (restr_type!=RESTRICT_NONE)
            stufftext(Restriction.toLocal8Bit().constData());
        text=tr("\nResults:");
        stufftext(text.toLocal8Bit().constData());
        text=QString("( x0 | y0 ) = ( ");
        sprintf(buffer,sformat,x0);
        text+=QString(buffer)+QString(" | ");
        sprintf(buffer,sformat,y0);
        text+=QString(buffer);
        text=tr("Center ")+text+QString(" )");
        stufftext(text.toLocal8Bit().constData());
        sprintf(buffer,sformat,a);
        text=tr("Semi-major axis a = ")+QString(buffer);
        stufftext(text.toLocal8Bit().constData());
        sprintf(buffer,sformat,b);
        text=tr("Semi-minor axis b = ")+QString(buffer);
        stufftext(text.toLocal8Bit().constData());
        sprintf(buffer,sformat,alpha);
        text=tr("Angle of rotation alpha = ")+QString(buffer)+QString("\n");
        s=sqrt(a*a-b*b);
        text+=tr("Focus points: ( ");
        sprintf(buffer,sformat,x0-s*cos(alpha));
        text+=QString(buffer)+QString(" | ");
        sprintf(buffer,sformat,y0-s*sin(alpha));
        text+=QString(buffer)+QString(" ); ( ");
        sprintf(buffer,sformat,x0+s*cos(alpha));
        text+=QString(buffer)+QString(" | ");
        sprintf(buffer,sformat,y0+s*sin(alpha));
        text+=QString(buffer)+tr(" )\nEccentricity: ");
        sprintf(buffer,sformat,sqrt(1.0-b*b/(a*a)));
        text+=QString(buffer)+QString("\n");
        stufftext(text.toLocal8Bit().constData());
    }
    text=tr("Fit accurracy:");
    stufftext(text.toLocal8Bit().constData());
    sprintf(buffer,": %g",cor);
    text=tr("Correlation coefficient")+QString(buffer);
    stufftext(text.toLocal8Bit().constData());
    sprintf(buffer,": %g",chisq);
    text=tr("Chi-square")+QString(buffer);
    stufftext(text.toLocal8Bit().constData());
    sprintf(buffer,": %g",theil);
    text=tr("Theil U coefficent")+QString(buffer);
    stufftext(text.toLocal8Bit().constData());
    if (rms_ok)
    {
    sprintf(buffer,": %g",rms_pe);
    text=tr("RMS per cent error")+QString(buffer);
    stufftext(text.toLocal8Bit().constData());
    }
    stufftext("\n");

if (chkShowResult->isChecked()==true)
{
SetsCreated(1,&sel_gno,&n_sno,UNDO_COMPLETE);
    if (selObject->currentIndex()==0)
    addAditionalDescriptionToLastNode(-1,QString(),QString("Circle fit to set ")+QString("G")+QString::number(sel_gno)+QString(".S")+QString::number(sel_sno),0);
    else
    addAditionalDescriptionToLastNode(-1,QString(),QString("Ellipse fit to set ")+QString("G")+QString::number(sel_gno)+QString(".S")+QString::number(sel_sno),0);
mainWin->mainArea->completeRedraw();
}

if (chkShowResult->isChecked()==false)
{
killset(sel_gno,n_sno);
}

copy_nonl(sav_nonl_parms,nonl_parms,&sav_nonl_opts,&nonl_opts);//resore old settings of nonlinear fit
block_guessing=false;
}

void frm2DFit::doClose(void)
{
    this->hide();
}

frmInterpolation::frmInterpolation(int type,QWidget * parent):QDialog(parent)
{
    int number;
    char dummy[128];
    WindowType=type;
    QString * entr=new QString[maxgraph>5?maxgraph+1:8];
    int * entr_vals=new int[maxgraph>5?maxgraph+1:8];
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));
    if (type==INTERPOLATIONWINDOW)
        setWindowTitle(tr("QtGrace: Interpolation"));
    else
        setWindowTitle(tr("QtGrace: Histograms"));

    grpSource=new grpSelect(tr("Source"),this);
    grpDestination=new grpSelect(tr("Destination"),this);
    grpDestination->enable_sync(grpSource->listSet);

    grpSampling=new QGroupBox(QString(""),this);

    sampSet=new uniList(SETLIST,grpSampling);

    chkStrict=new QCheckBox(tr("Strict (within source set bounds)"),grpSampling);
    chkNextPowerOfTwo=new QCheckBox(tr("to next power of 2"),grpSampling);
    chkCumulHist=new QCheckBox(tr("Cumulative histogram"),grpSampling);
    chkNormalize=new QCheckBox(tr("Normalize"),grpSampling);
    chkDensity=new QCheckBox(tr("Density"),grpSampling);

    number=3;
    entr[0]=tr("Linear");
    entr[1]=tr("Cubic spline");
    entr[2]=tr("Akima spline");
    selMethod=new StdSelector(grpSampling,tr("Method:"),number,entr);

    if (type==INTERPOLATIONWINDOW)
    {
    number=6;
    entr[0]=tr("Linear mesh");
    entr[1]=tr("Abscissa of another set");
    entr[2]=tr("Linear in original bounds");//new option added with v0.2.4
    entr[3]=tr("Expand bounds, keep stepping");//new option added with v0.2.4
    entr[4]=tr("Logarithmic mesh");//new option added with v0.2.7
    entr[5]=tr("Parametric");//new option added with v0.2.7
    selSampling=new StdSelector(grpSampling,tr("Sampling:"),number,entr);
    entr_vals[0]=SAMPLING_MESH;
    entr_vals[1]=SAMPLING_SET;
    entr_vals[2]=SAMPLING_INSIDE_BOUNDS;
    entr_vals[3]=SAMPLING_EXPAND_KEEP_STEPPING;
    entr_vals[4]=SAMPLING_LOG_MESH;
    entr_vals[5]=SAMPLING_PARAMETRIC;
    selSampling->setValues(entr_vals);

    chkStrict->setToolTip(tr("A mesh is created, but only the points of the mesh that are\nwithin the min- and max-X-values of the original set are to be used.\nThis means that the number of points (Length) may be\nlower than what has been entered."));
    chkNextPowerOfTwo->setToolTip(tr("The number of points will be the next power of 2 in relation to the current number of points."));
    }
    else//histogramm
    {
    number=3;
    entr[0]=tr("Linear mesh");
    entr[1]=tr("Abscissa of another set");
    //entr[2]=tr("Linear in original bounds");//new option added with v0.2.4
    //entr[3]=tr("Expand bounds, keep stepping");//new option added with v0.2.4
    entr[2]=tr("Logarithmic mesh");//new option added with v0.2.7
    selSampling=new StdSelector(grpSampling,tr("Sampling:"),number,entr);
    entr_vals[0]=SAMPLING_MESH;
    entr_vals[1]=SAMPLING_SET;
    //entr_vals[2]=SAMPLING_INSIDE_BOUNDS;
    //entr_vals[3]=SAMPLING_EXPAND_KEEP_STEPPING;
    entr_vals[2]=SAMPLING_LOG_MESH;
    //entr_vals[5]=SAMPLING_PARAMETRIC;
    selSampling->setValues(entr_vals);

    chkCumulHist->setToolTip(tr("Cumulate the y-values from first to last bin"));
    chkNormalize->setToolTip(tr("Normalize the y-values (i.e. the sum of all y-values shall be 1)"));
    chkDensity->setToolTip(tr("Calculate the y-values as a density (i.e. the y-values are divided by the bin-width)\nThis is useful if the bins have different widths.\nWarning: normalization and cumulation are done after this."));
    }

    connect(selSampling->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(selSamplingChanged(int)));
    number=maxgraph;
    for (int i=0;i<number;i++)
    {
        sprintf(dummy,"G%d",i);
        entr[i]=QString(dummy);
    }
    selSamplingGraph=new StdSelector(grpSampling,tr("Graph:"),number,entr);
    selSamplingGraph->simple_graph_selector=true;
    selSamplingGraph->setEnabled(FALSE);
    connect(selSamplingGraph->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(selSamplGraphChanged(int)));

    lenStart=new stdLineEdit(grpSampling,tr("Start at:"));
    lenStop=new stdLineEdit(grpSampling,tr("Stop at:"));
    lenLength=new stdLineEdit(grpSampling,tr("Length:"));
    lenStart->lenText->setText(QString(""));
    lenStop->lenText->setText(QString(""));
    lenLength->lenText->setText(QString(""));

    lblSamplSet=new QLabel(tr("Sampling set:"),grpSampling);

    sampSet->setEnabled(FALSE);
    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));

    layout1=new QGridLayout;
    //layout1->setMargin(STD_MARGIN);
    layout1->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);

    if (type==INTERPOLATIONWINDOW)
    {
        layout1->addWidget(selMethod,0,0,1,2);
        layout1->addWidget(chkStrict,0,2,1,2);
        layout1->addWidget(chkNextPowerOfTwo,0,4,1,2);
        chkCumulHist->setVisible(FALSE);
        chkNormalize->setVisible(FALSE);
        chkDensity->setVisible(FALSE);
        chkNextPowerOfTwo->setVisible(true);
        connect(chkNextPowerOfTwo,SIGNAL(toggled(bool)),SLOT(toggleNextPowerOfTwo(bool)));
    }
    else//HISTOGRAMSWINDOW
    {
        layout1->addWidget(chkCumulHist,0,0,1,2);
        layout1->addWidget(chkNormalize,0,2,1,2);
        layout1->addWidget(chkDensity,0,4,1,2);
        selMethod->setVisible(FALSE);
        chkStrict->setVisible(FALSE);
        chkNextPowerOfTwo->setVisible(false);
        selSampling->lblText->setText(tr("Bin sampling:"));
        lenLength->lblText->setText(tr("# of bins:"));
    }

    layout1->addWidget(selSampling,1,0,1,3);
    layout1->addWidget(selSamplingGraph,1,3,1,2);
    layout1->addWidget(lenStart,2,0,1,2);
    layout1->addWidget(lenStop,2,2,1,2);
    layout1->addWidget(lenLength,2,4);
    layout1->addWidget(lblSamplSet,3,0);
    layout1->addWidget(sampSet,4,0,3,5);
    grpSampling->setLayout(layout1);

    layout=new QGridLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->addWidget(grpSource,0,0);
    layout->addWidget(grpDestination,0,1);
    layout->addWidget(grpSampling,1,0,1,2);
    layout->addWidget(buttonGroup,2,0,1,2);
    setLayout(layout);
    delete[] entr;
    delete[] entr_vals;
    if (WindowType==INTERPOLATIONWINDOW)
    resize(LastSize_FormInterpolation);
    else
    resize(LastSize_FormHistograms);
}

frmInterpolation::~frmInterpolation()
{
    if (WindowType==INTERPOLATIONWINDOW)
    LastSize_FormInterpolation=this->size();
    else
    LastSize_FormHistograms=this->size();
}

void frmInterpolation::init(void)
{
    int nr=1,sel=get_cg();
    grpSource->listGraph->update_number_of_entries();
    grpSource->listGraph->set_new_selection(nr,&sel);
    grpSource->listSet->set_graph_number(sel,false);
    //grpSource->listSet->update_number_of_entries();
    grpDestination->listGraph->update_number_of_entries();
    grpDestination->listGraph->set_new_selection(nr,&sel);
    grpDestination->listSet->set_graph_number(sel,false);
    //grpDestination->listSet->update_number_of_entries();
    sampSet->update_number_of_entries();
    selSamplingGraph->cmbSelect->clear();
    char dummy[128];
    for (int i=0;i<maxgraph;i++)
    {
        sprintf(dummy,"G%d",i);
        selSamplingGraph->cmbSelect->addItem(QString(dummy));
    }
/*Test*/
    /*char dummy3[128];
    for (int i=0;i<getsetlength(0,0);i++)
    {
        sprintf(dummy,"%.17f",g[0].p[0].data.ex[0][i]);
        sprintf(dummy3,"%.17f",nextafter(g[0].p[0].data.ex[0][i],-1));
        qDebug() << i << ": " << dummy << " " << dummy3;
    }*/
/*Ende Test*/
}

void frmInterpolation::selSamplingChanged(int i)
{
    (void) i;//we do not want the index, we need the value!
    bool poweroftwo=chkNextPowerOfTwo->isChecked();
    int v=selSampling->currentValue();
    if (v==SAMPLING_MESH || v==SAMPLING_LOG_MESH || v==SAMPLING_EXPAND_KEEP_STEPPING)//linear- or log-scale
    {
        sampSet->setEnabled(FALSE);
        selSamplingGraph->setEnabled(FALSE);
        lenStart->setEnabled(TRUE);
        lenStop->setEnabled(TRUE);
        lenLength->setEnabled(!poweroftwo);
    }
    else if (v==SAMPLING_SET)
    {
        sampSet->setEnabled(TRUE);
        selSamplingGraph->setEnabled(TRUE);
        lenStart->setEnabled(FALSE);
        lenStop->setEnabled(FALSE);
        lenLength->setEnabled(FALSE);
    }
    else if (v==SAMPLING_INSIDE_BOUNDS || v==SAMPLING_PARAMETRIC)//keep bounds, just change number of points || expand bounds
    {
        sampSet->setEnabled(FALSE);
        selSamplingGraph->setEnabled(FALSE);
        lenStart->setEnabled(FALSE);
        lenStop->setEnabled(FALSE);
        lenLength->setEnabled(!poweroftwo);
    }
    //setting tool-tip-texts
    switch (v)
    {
    default:
    case SAMPLING_MESH:
    selSampling->setToolTip(tr("Interpolate a set onto X-values that have a monotonic spacing between two limits"));
    break;
    case SAMPLING_SET:
    selSampling->setToolTip(tr("Interpolate a set onto the X-values of a different set."));
    break;
    case SAMPLING_INSIDE_BOUNDS:
    selSampling->setToolTip(tr("Interpolates a set using the existing Min- and Max-Values of the X-values as limits.\nThis just changes the number of points of a set."));
    break;
    case SAMPLING_EXPAND_KEEP_STEPPING:
    selSampling->setToolTip(tr("Interpolates a set with X-values that are monotonically spaced.\nThe X-value-mesh is extended to the new lower and higher X-value-limits using the existing stepping in X-values.\nKeep in mind that the original X-values will be used as a reference, i.e. the new X-values will contain the old ones (if the old ones are inside the new limits).\nThis means that the start- and stop-values are considered limits and not fixed values. The number of points is adjusted if needed.\nYou do not have to enter start, stop AND length; two out of three are enough."));
    break;
    case SAMPLING_LOG_MESH:
    selSampling->setToolTip(tr("Interpolate a set onto X-values that have a monotonic spacing in their logarithmic values between two limits (natural logarithm used).\nE.g. x=[1,100],n=3 generates X={1,10,100}"));
    break;
    case SAMPLING_PARAMETRIC:
    selSampling->setToolTip(tr("Interpolate a set that has non-monotonic X-values (e.g. sets that have been generated parametrically like a circle).\nGenerates new sets internally with X-values just numbers between 0 and number of points and X- and Y-values of the existing sets as Y-values.\nThen these sets are interpolated to the new number of points.\nThe Y-values of the new sets are then rearranged as X- and Y-values of the final set.\nThis lowers or increases the number of points in a set but can not change the limits (since the underlying parameter is not known)."));
    break;
    }
}

void frmInterpolation::selSamplGraphChanged(int i)
{
    sampSet->set_graph_number(i,false);
    //sampSet->update_number_of_entries();
}

void frmInterpolation::toggleNextPowerOfTwo(bool i)
{
    (void)i;
    lenLength->setEnabled(!(chkNextPowerOfTwo->isChecked()));
}

void frmInterpolation::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmInterpolation::doApply(void)
{
    ApplyError=false;
    int error, res;
    int nssrc, nsdest, *svaluessrc=new int[5], *svaluesdest=new int[5], gsrc, gdest;
    int method, sampling, strict;
    int cumulative, normalize, nextPowerOf2;
    int i, meshlen,nbins;
    int l_d_x,r_d_x;
    double start, stop, temp_s, save_start, save_stop, save_len, ymin, ymax, xspace;
    bool readerror=false;
    bool start_set,stop_set,len_set;
    double *bins = NULL;
    double *mesh = NULL;
    int allocate_type_bins=-1;//not allocated, 0=old-style(malloc), 1=new-style(new)
    int allocate_type_mesh=-1;//not allocated, 0=old-style(malloc), 1=new-style(new)
    bool mono;
    int count,*selection=new int[5];
    QString log_error;
    grpSource->listGraph->get_selection(&count,&selection);
    nbins=1;
    normalize=0;
    cumulative=0;
    strict=0;
    method=0;
    if (count!=1)
    {
        errmsg(tr("Please select single source graph").toLocal8Bit().constData());
        ApplyError=true;
        delete[] svaluessrc;
        delete[] svaluesdest;
        delete[] selection;
        return;
    }
    else
    {
        gsrc=selection[0];
    }
    grpDestination->listGraph->get_selection(&count,&selection);
    if (count!=1)
    {
        errmsg(tr("Please select single destination graph").toLocal8Bit().constData());
        ApplyError=true;
        delete[] svaluessrc;
        delete[] svaluesdest;
        delete[] selection;
        return;
    }
    else
    {
        gdest=selection[0];
    }
    grpSource->listSet->get_selection(&nssrc,&svaluessrc);
    if (nssrc<=0)
    {
        errmsg(tr("Please select at least one source set").toLocal8Bit().constData());
        ApplyError=true;
        delete[] svaluessrc;
        delete[] svaluesdest;
        delete[] selection;
        return;
    }
    grpDestination->listSet->get_selection(&nsdest,&svaluesdest);
    delete[] selection;
    if (nssrc!=nsdest && nsdest!=0)
    {
        errmsg(tr("Number of destination sets does not match number of source sets").toLocal8Bit().constData());
        ApplyError=true;
        delete[] svaluessrc;
        delete[] svaluesdest;
        return;
    }

    error = FALSE;
    nextPowerOf2 = FALSE;
    if (WindowType==INTERPOLATIONWINDOW)
    {
        method       = GetOptionChoice(selMethod);
        sampling     = GetOptionChoice(selSampling);
        strict       = GetToggleButtonState(chkStrict);
        nextPowerOf2 = GetToggleButtonState(chkNextPowerOfTwo);
    }
    else//histogram
    {
        cumulative = GetToggleButtonState(chkCumulHist);
        normalize  = GetToggleButtonState(chkNormalize);
        sampling   = GetOptionChoice(selSampling);
        if (chkDensity->isChecked()==true) normalize+=2;
    }

    if (sampling == SAMPLING_SET) {
        int gsampl, setnosampl;
        gsampl = selSamplingGraph->currentIndex();//get_cg();
        res = GetSingleListChoice(sampSet, &setnosampl);
        if (res != RETURN_SUCCESS) {
            errmsg(tr("Please select single sampling set").toLocal8Bit().constData());
            ApplyError=true;
            error = TRUE;
        } else {
            if (WindowType==INTERPOLATIONWINDOW)
            {
                meshlen = getsetlength(gsampl, setnosampl);
                mesh = getcol(gsampl, setnosampl, DATA_X);
            }
            else//histograms
            {
                nbins = getsetlength(gsampl, setnosampl) - 1;
                bins = getcol(gsampl, setnosampl, DATA_X);
            }
        }
    } else {//do not sample on a specific set, but on a predefined range of values
        start_set=stop_set=len_set=true;
        if (nextPowerOf2==false)//we need to read the new number of points
        {
            if (xv_evalexpri(lenLength, &meshlen) != RETURN_SUCCESS)//can not read a value
            {
                len_set=false;
                readerror=true;
            }
        }//if true --> the setlength will not be read!

        if (sampling==SAMPLING_EXPAND_KEEP_STEPPING)
        {
            if (xv_evalexpr(lenStart, &start) != RETURN_SUCCESS) start_set=false;
            if (lenStart->text().isEmpty()==true) start_set=false;
            if (xv_evalexpr(lenStop,  &stop) != RETURN_SUCCESS) stop_set=false;
            if (lenStop->text().isEmpty()==true) stop_set=false;

                if (nextPowerOf2==false)
                {
                    if (xv_evalexpri(lenLength, &meshlen) != RETURN_SUCCESS)
                    len_set=false;
                }
                if (lenLength->text().isEmpty()==true) len_set=false;
            if (meshlen==0) len_set=false;
            readerror=false;
        }
        else if (sampling==SAMPLING_MESH || sampling==SAMPLING_LOG_MESH || WindowType!=INTERPOLATIONWINDOW)//the user entered limits for the interpolation and we have to read them
        {
            if (xv_evalexpr(lenStart, &start) != RETURN_SUCCESS ||
                xv_evalexpr(lenStop,  &stop)  != RETURN_SUCCESS )
                readerror=true;
            if ( sampling==SAMPLING_LOG_MESH && ( (start==0 || stop==0) || (start<=0 && stop>=0) ) )
            {
                if (start==0 || stop==0)
                log_error=tr("Unable to use non-positive values for limits with logarithmic mesh!");
                else
                log_error=tr("Unable to use values for logarithmic mesh that cross zero!");
            errmsg(log_error.toLocal8Bit().constData());
            readerror=true;
            }
        }

        if (readerror==false && start>stop && start_set==true && stop_set==true)
        {
        temp_s=start;
        start=stop;
        stop=temp_s;
        lenStart->setDoubleValue(start);
        lenStop->setDoubleValue(stop);
        }

        /*if (xv_evalexpr(lenStart, &start)     != RETURN_SUCCESS ||
            xv_evalexpr(lenStop,  &stop)      != RETURN_SUCCESS ||
            xv_evalexpri(lenLength, &meshlen) != RETURN_SUCCESS ) {*/
        if (readerror==true)
        {
            errmsg(tr("Can't parse mesh settings!").toLocal8Bit().constData());
            ApplyError=true;
            error = TRUE;
        }
        else
        {
            if (WindowType==INTERPOLATIONWINDOW && nextPowerOf2==false)
            {
            //qDebug() << "Allocated Mesh: " << start << " - " << stop << "meshlen=" << meshlen;
                if (sampling==SAMPLING_MESH)
                {
                mesh = allocate_mesh(start, stop, meshlen);
                }
                else if (sampling==SAMPLING_LOG_MESH)
                {
                mesh = allocate_logarithmic_mesh(start, stop, meshlen);
                }
                allocate_type_mesh=0;
                if (mesh == NULL && (sampling==SAMPLING_MESH || sampling==SAMPLING_LOG_MESH))
                {
                    errmsg(tr("Can't allocate mesh").toLocal8Bit().constData());
                    ApplyError=true;
                    error = TRUE;
                }
            }
            else//histogramm
            {
                nbins=meshlen;
                    if (sampling==SAMPLING_MESH)
                    bins = allocate_mesh(start, stop, nbins + 1);
                    else if (sampling==SAMPLING_LOG_MESH)
                    bins = allocate_logarithmic_mesh(start, stop, nbins + 1);
                allocate_type_bins=0;
                if (bins == NULL)
                {
                    errmsg(tr("Can't allocate mesh").toLocal8Bit().constData());
                    ApplyError=true;
                    error = TRUE;
                }
            }
        }
    }

    if (error)
    {
        delete[] svaluessrc;
        if (nsdest > 0)
        {
            delete[] svaluesdest;
        }
        return;// RETURN_FAILURE;
    }
    this->setCursor(*wait_cursor);
    set_wait_cursor();
    int * gnos=new int[nssrc];//nssrc is either greater than nsdest or equal
    int * snos=new int[nssrc];
    char dummy[256];
    int set_no=0;

    if (nsdest>0)//no new sets will be created --> old sets will be modified
    {
        for (int i=0;i<nsdest;i++)
        {
            gnos[i]=gdest;
            snos[i]=svaluesdest[i];
        }
        SaveSetStatesPrevious(nsdest,gnos,snos,UNDO_DATA);
    }
    if (ApplyError==true)
    {
            errmsg(tr("Error in do_interp()").toLocal8Bit().constData());
            error = TRUE;
    }
    else
    {
        save_start=start;
        save_stop=stop;
        save_len=meshlen;
    for (i = 0; i < nssrc && error==FALSE ; i++)//do interpolation for all selected sets
    {
    int setnosrc, setnodest;
    ApplyError=false;
    start=save_start;
    stop=save_stop;
    meshlen=save_len;
        setnosrc = svaluessrc[i];
        if (nsdest != 0) {
            setnodest = svaluesdest[i];
        } else {
            setnodest = SET_SELECT_NEXT;
        }

        if (WindowType==INTERPOLATIONWINDOW)
        {
            if (nextPowerOf2==true)
            {
                if (allocate_type_mesh==1 && mesh!=NULL) {delete[] mesh;mesh=NULL;}
                if (allocate_type_mesh==0 && mesh!=NULL) {xfree(mesh);mesh=NULL;}
                allocate_type_mesh=-1;
                meshlen=1<<((int)ceil(log((double)getsetlength(gsrc, setnosrc))/log(2.0)));
                len_set=true;
                if (sampling!=SAMPLING_EXPAND_KEEP_STEPPING)//for this we have to reevaluate the start- and stop-values
                {
                if (sampling==SAMPLING_MESH)
                {
                mesh = allocate_mesh(start, stop, meshlen);
                }
                else if (sampling==SAMPLING_LOG_MESH)
                {
                mesh = allocate_logarithmic_mesh(start, stop, meshlen);
                }
                allocate_type_mesh=0;
                if (mesh == NULL && (sampling==SAMPLING_MESH || sampling==SAMPLING_LOG_MESH))
                {
                    errmsg(tr("Can't allocate mesh").toLocal8Bit().constData());
                    ApplyError=true;
                    error = TRUE;
                    continue;
                }
                }
            }

            if (sampling==SAMPLING_EXPAND_KEEP_STEPPING)
            {
                double s_start,s_stop;
                getsetminmax(gsrc, setnosrc,&s_start,&s_stop,&ymin,&ymax, FALSE);
                mono=monospaced_v6(g[gsrc].p[setnosrc].data.ex[0], getsetlength(gsrc, setnosrc), &xspace);
                sprintf(dummy,"%.17f",xspace);
                //qDebug() << "xspace=" << dummy;

                if (mono==false)
                {
                    errmsg(QObject::tr("Error! Set not monospaced in x!").toLocal8Bit().constData());
                    ApplyError=true;
                    error = TRUE;
                    continue;
                }

/*qDebug() << "Sampling Keep Stepping: Original:";
qDebug() << "start=" << start << "stop=" << stop << "meshlen=" << meshlen;
qDebug() << "start_set=" << start_set << "stop_set=" << stop_set << "len_set=" << len_set << "xspace=" << xspace;*/

                    if (start_set==false && stop_set==false && len_set==false)
                    {
                    errmsg(QObject::tr("Error! Unable to create new mesh (specification insufficient)!").toLocal8Bit().constData());
                    ApplyError=true;
                    error = TRUE;
                    continue;
                    }
                    else if (start_set==false && stop_set==false)//just len_set=true--> symmetric expansion/reduction
                    {
                        l_d_x=meshlen-getsetlength(gsrc, setnosrc);//the amount of points to add (or remove)
                        r_d_x=l_d_x/2;
                        l_d_x=(meshlen-getsetlength(gsrc, setnosrc))-r_d_x;
                        if (getsetlength(gsrc, setnosrc)>meshlen)//new mesh shorter than old set
                        {
                        stufftext(QObject::tr("Warning! Interpolation setting just reduces set length (points removed from beginning and end).").toLocal8Bit().constData());
                        }
                        else//new mesh longer than old set
                        {
                        stufftext(QObject::tr("Warning! Interpolation setting just expands set length (points added at beginning and end).").toLocal8Bit().constData());
                        }
                        start=s_start-l_d_x*xspace;
                        stop=s_stop+r_d_x*xspace;
                    }
                    else if (start_set==false)
                    {
                        if (len_set==false && tolerant_lt(stop,s_start))//the whole new set is lower than the old one
                        {
                        errmsg(QObject::tr("Error! Unable to create new mesh (specification insufficient)!").toLocal8Bit().constData());
                        ApplyError=true;
                        error = TRUE;
                        continue;
                        }
                        else if (len_set==true)//no start set, but stop set and length set
                        {
                            if (tolerant_leq(stop,s_stop) && tolerant_geq(stop,s_start))//stop is inside the sets range --> find the highest x-value in the set lower than stop
                            {
                            start=s_start;
                                for (int lkj=0;lkj<getsetlength(gsrc, setnosrc);lkj++)
                                {
                                if (tolerant_leq(g[gsrc].p[setnosrc].data.ex[DATA_X][lkj],stop)) start=g[gsrc].p[setnosrc].data.ex[DATA_X][lkj];
                                }
                            stop=start;
                            start=stop-(meshlen-1)*xspace;
                            }
                            else if (tolerant_lt(stop,s_start))//stop is lower than the set
                            {
                            stop=s_start-round((s_start-stop)/xspace)*xspace;
                                if (tolerant_gt(stop,save_stop))
                                {
                                stop-=xspace;
                                }
                            start=stop-(meshlen-1)*xspace;
                            }
                            else//stop is hight then the set
                            {
                            stop=s_stop+round((stop-s_stop)/xspace)*xspace;
                                if (tolerant_gt(stop,save_stop))
                                {
                                stop-=xspace;
                                }
                            start=stop-(meshlen-1)*xspace;
                            }
                        }
                        else//no start set, but stop set (no length set) --> start=set-min
                        {
                        start=s_start;
                        meshlen=(stop-start)/xspace+1;
                        }
                    }
                    else if (stop_set==false)
                    {
                        if (len_set==false && tolerant_gt(start,s_stop))//the whole new set is higher than the old one
                        {
                        errmsg(QObject::tr("Error! Unable to create new mesh (specification insufficient)!").toLocal8Bit().constData());
                        ApplyError=true;
                        error = TRUE;
                        continue;
                        }
                        else if (len_set==true)//no stop set, but start set and length set
                        {
                            if (tolerant_leq(start,s_stop) && tolerant_geq(start,s_start))//start is inside the sets range --> find the lowest x-value in the set higher than start
                            {
                            stop=s_stop;
                                for (int lkj=0;lkj<getsetlength(gsrc, setnosrc);lkj++)
                                {
                                if (tolerant_geq(g[gsrc].p[setnosrc].data.ex[DATA_X][lkj],start) && tolerant_lt(g[gsrc].p[setnosrc].data.ex[DATA_X][lkj],stop)) stop=g[gsrc].p[setnosrc].data.ex[DATA_X][lkj];
                                }
                            start=stop;
                            stop=start+(meshlen-1)*xspace;
                            }
                            else if (tolerant_lt(start,s_start))//start is lower than the set
                            {
/*
qDebug() << "start set, stop NOT set, start lower";
sprintf(dummy,"%.17f",s_start);
qDebug() << "s_start=" << dummy;
sprintf(dummy,"%.17f",start);
qDebug() << "start=" << dummy;
sprintf(dummy,"%.17f",(s_start-start)/xspace);
qDebug() << "(s_start-start)/xspace=" <<dummy;
sprintf(dummy,"%.17f",round((s_start-start)/xspace));
qDebug() << "round((s_start-start)/xspace)=" <<dummy;
sprintf(dummy,"%.17f",round((s_start-start)/xspace)*xspace);
qDebug() << "round((s_start-start)/xspace)*xspace=" <<dummy;
sprintf(dummy,"%.17f",DBL_EPSILON);
qDebug() << "DBL_EPSILON=" << dummy;
*/
                            start=s_start-round((s_start-start)/xspace)*xspace;
                                if (tolerant_lt(start,save_start))
                                {
                                start+=xspace;
                                }
                            stop=start+(meshlen-1)*xspace;
                            }
                            else//start is hight then the set
                            {
                            start=s_stop+round((start-s_stop)/xspace)*xspace;
                                if (tolerant_lt(start,save_start))
                                {
                                start+=xspace;
                                }
                            stop=start+(meshlen-1)*xspace;
                            }
                        }
                        else//no stop set, but start set (no length set) --> stop=set-max
                        {
                        stop=s_stop;
                        meshlen=(stop-start)/xspace+1;
                        }
                    }
                    else //if (len_set==false)start and stop defined, but no length
                    {
                        //correct start
                        if (tolerant_leq(start,s_stop) && tolerant_geq(start,s_start))//start is inside the sets range --> find the lowest x-value in the set higher than start
                        {
                        temp_s=s_stop;
                            for (int lkj=0;lkj<getsetlength(gsrc, setnosrc);lkj++)
                            {
                                /*sprintf(dummy,"%.15f",g[gsrc].p[setnosrc].data.ex[DATA_X][lkj]);
                                qDebug() << "data=" << dummy;
                                sprintf(dummy,"%.15f",temp_s);
                                qDebug() << "temp_s=" << dummy;
                            if (g[gsrc].p[setnosrc].data.ex[DATA_X][lkj]-start>=-2*DBL_EPSILON && fabs(g[gsrc].p[setnosrc].data.ex[DATA_X][lkj]-temp_s)>2*DBL_EPSILON && g[gsrc].p[setnosrc].data.ex[DATA_X][lkj]<temp_s) temp_s=g[gsrc].p[setnosrc].data.ex[DATA_X][lkj];
                                sprintf(dummy,"%.15f",g[gsrc].p[setnosrc].data.ex[DATA_X][lkj]);
                                qDebug() << "data=" << dummy;
                            if (g[gsrc].p[setnosrc].data.ex[DATA_X][lkj]>=start && g[gsrc].p[setnosrc].data.ex[DATA_X][lkj]<temp_s) temp_s=g[gsrc].p[setnosrc].data.ex[DATA_X][lkj];
                                sprintf(dummy,"%.15f",temp_s);
                                qDebug() << "temp_s=" << dummy;*/
                            if (tolerant_geq(g[gsrc].p[setnosrc].data.ex[DATA_X][lkj],start) && tolerant_lt(g[gsrc].p[setnosrc].data.ex[DATA_X][lkj],temp_s)) temp_s=g[gsrc].p[setnosrc].data.ex[DATA_X][lkj];
                            }
                        start=temp_s;
                        }
                        else if (tolerant_lt(start,s_start))//start is lower than the set
                        {
                        start=s_start-round((s_start-start)/xspace)*xspace;
                        }
                        else//start is hight then the set
                        {
                        start=s_stop+round((start-s_stop)/xspace)*xspace;
                        }

                        if (tolerant_lt(start,save_start))
                        {
                            /*sprintf(dummy,"%.20f",start);
                            qDebug() << "start=     " << dummy;
                            sprintf(dummy,"%.20f",save_start);
                            qDebug() << "save_start=" << dummy;
                            sprintf(dummy,"%.20f",low_tol_val(save_start));
                            qDebug() << "lower=     " << dummy;
                            sprintf(dummy,"%.20f",high_tol_val(save_start));
                            qDebug() << "higher=    " << dummy;
                        qDebug() << "Start Increased!";*/
                        start+=xspace;
                        }
                        //correct stop
                        if (tolerant_leq(stop,s_stop) && tolerant_geq(stop,s_start))//stop is inside the sets range --> find the highest x-value in the set lower than stop
                        {
                        temp_s=s_start;
                            for (int lkj=0;lkj<getsetlength(gsrc, setnosrc);lkj++)
                            {
                                /*sprintf(dummy,"%.17f",g[gsrc].p[setnosrc].data.ex[DATA_X][lkj]);
                                qDebug() << lkj << "data=" << dummy << "temp_s=" << temp_s;
                                sprintf(dummy,"%.17f",DBL_EPSILON);
                                qDebug() << "DBL_EPSILON=" << dummy;*/
                            if (tolerant_leq(g[gsrc].p[setnosrc].data.ex[DATA_X][lkj],stop)) temp_s=g[gsrc].p[setnosrc].data.ex[DATA_X][lkj];
                            }
                        stop=temp_s;
                        }
                        else if (tolerant_lt(stop,s_start))//stop is lower than the set
                        {
                        stop=s_start-round((s_start-stop)/xspace)*xspace;
                        }
                        else//stop is hight then the set
                        {
                        stop=s_stop+round((stop-s_stop)/xspace)*xspace;
                        }
                        if (tolerant_gt(stop,save_stop))
                        {
                        /*sprintf(dummy,"%.15f",stop);
                        qDebug() << "stop=" << dummy;
                        sprintf(dummy,"%.15f",save_stop);
                        qDebug() << "save_stop=" << dummy;*/
                        stop-=xspace;
                        //qDebug() << "stop reduced!";
                        }
                    }
                    //correct new length
                    meshlen=round((stop-start)/xspace)+1;
                    if (ApplyError==false)
                    {
/*
qDebug() << "Sampling Keep Stepping: Corrected:";
sprintf(dummy,"%.17f",start);
qDebug() << "start=" << dummy;
sprintf(dummy,"%.17f",stop);
qDebug() << "stop=" << dummy;
*/
/*qDebug() << "start=" << start << "stop=" << stop << "meshlen=" << meshlen;*/

                        mesh = allocate_mesh(start, stop, meshlen);//always a linear mesh here
                        allocate_type_mesh=0;
                        if (mesh == NULL)
                        {
                        errmsg(tr("Can't allocate mesh").toLocal8Bit().constData());
                        ApplyError=true;
                        error = TRUE;
                        continue;
                        }
                        /*else
                        {
                        qDebug() << "DBL_Mantisse=" << DBL_MANT_DIG;
                        qDebug() << "Mesh:";
                            for (int lkj=0;lkj<meshlen;lkj++)
                            {
                                sprintf(dummy,"%.17f",mesh[lkj]);
                                qDebug() << lkj << ": " << dummy;
                            }
                        }*/
                    }
            //qDebug() << "allocate start=" << start << " stop=" << stop << " len=" << meshlen << "strict=" << strict << "sampling=" << sampling;
            }//end: sampling==SAMPLING_EXPAND_KEEP_STEPPING

            if (sampling==SAMPLING_INSIDE_BOUNDS)
            {//in this case we have to create the mesh now because we changed the limits (and have not created a mesh at the beginning)
                getsetminmax(gsrc, setnosrc,&start,&stop,&ymin,&ymax, FALSE);
                mesh = allocate_mesh(start, stop, meshlen);//always a linear mesh here
                allocate_type_mesh=0;
                if (mesh == NULL)
                {
                    errmsg(tr("Can't allocate mesh").toLocal8Bit().constData());
                    ApplyError=true;
                    error = TRUE;
                    continue;
                }
            }
            if (sampling==SAMPLING_PARAMETRIC)
            {
            strict=SAMPLING_PARAMETRIC;
            //qDebug() << "Parametric";
            }
            res = do_interp(gsrc, setnosrc, gdest, setnodest, mesh, meshlen, method, strict);
        }
        else
        {
            res = do_histo(gsrc, setnosrc, gdest, setnodest, bins, nbins, cumulative, normalize);
        }

        if (ApplyError==true) continue;

        if (new_set_no!=-1)
        {
            gnos[set_no]=gdest;
            snos[set_no]=new_set_no;
            set_no++;
        }

        if (res != RETURN_SUCCESS)
        {
            errmsg(tr("Error in do_interp()").toLocal8Bit().constData());
            error = TRUE;
            ApplyError=true;
            continue;
        }
    }
    }

    if (allocate_type_mesh==1 && mesh!=NULL) {delete[] mesh;mesh=NULL;}
    if (allocate_type_mesh==0 && mesh!=NULL) {xfree(mesh);mesh=NULL;}
    if (allocate_type_bins==1 && bins!=NULL) {delete[] bins;bins=NULL;}
    if (allocate_type_bins==0 && bins!=NULL) {xfree(bins);bins=NULL;}
    /*if (sampling == SAMPLING_MESH)
    {
        if (mesh!=NULL)
            delete[] mesh;
        if (bins!=NULL)
            delete[] bins;
    }*/
    if (set_no>0)
    {
        if (nsdest > 0)//old sets modified
        {
            SetsModified(set_no,gnos,snos,UNDO_DATA);
        }
        else//new sets
        {
            SetsCreated(set_no,gnos,snos,UNDO_COMPLETE);
        }
        if (set_no==1)
        {
            sprintf(dummy," [G%d.S%d]",gsrc, svaluessrc[0]);
            if (WindowType==INTERPOLATIONWINDOW)
                addAditionalDescriptionToLastNode(-1,QObject::tr("Interpolation of")+QString(dummy),QString());
            else
                addAditionalDescriptionToLastNode(-1,QObject::tr("Histogram of")+QString(dummy),QString());
        }
        else
        {
            if (WindowType==INTERPOLATIONWINDOW)
                addAditionalDescriptionToLastNode(-1,QObject::tr("Interpolation"),QString());
            else
                addAditionalDescriptionToLastNode(-1,QObject::tr("Histogram"),QString());
        }
    }
    update_set_lists(gdest);
    grpSource->listSet->update_number_of_entries_preserve_selection();
    //grpDestination->listSet->update_number_of_entries_preserve_selection();
    grpDestination->set_graph_nr(gdest);
    grpDestination->listSet->set_new_selection(set_no,snos);
    mainWin->mainArea->completeRedraw();
    delete[] svaluessrc;
    if (nsdest > 0)
    {
        delete[] svaluesdest;
    }
    delete[] snos;
    delete[] gnos;
    this->unsetCursor();
    unset_wait_cursor();
}

void frmInterpolation::doClose(void)
{
    hide();
}

frmSmallCalc::frmSmallCalc(int type,QWidget * parent):QDialog(parent)
{
    int number,index=0;
    QString entr[15];
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));

    layout=new QGridLayout;
    layout->setSpacing(STD_SPACING);
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);

    WindowType=type;
    lblApplyTo=new QLabel(tr("Apply to set:"),this);
    listSets=new uniList(SETCHOICE,this);
    //listSets->show_all_sets_marker=true;
    lenText=new stdLineEdit(this,QString(""));
    lenText->lenText->setText(QString(""));
    chkInvert=new QCheckBox(tr("Invert region"),this);
    chkInvert->setVisible(FALSE);
    buttonGroup=new stdButtonGroup(this,false,true,false);
    buttonGroup->cmdAccept->setDefault(TRUE);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    StartStop=new stdStartStop(this);
    StartStop->setVisible(FALSE);
    layout->addWidget(lblApplyTo,index++,0,1,2);
    layout->addWidget(listSets,index++,0,1,2);

    switch (type)
    {
    case INTEGRATIONWINDOW:
        setWindowTitle(tr("QtGrace: Integration"));
        number=2;
        entr[0]=tr("Cumulative sum");
        entr[1]=tr("Sum only");
        selector1=new StdSelector(this,tr("Load:"),number,entr);
        layout->addWidget(selector1,index++,0,1,2);
        lenText->lblText->setText(tr("Sum:"));
        layout->addWidget(lenText,index++,0,1,2);
        selector2=new StdSelector(this,QString(""),number,entr);
        selector3=new StdSelector(this,QString(""),number,entr);
        selector2->setVisible(FALSE);
        selector3->setVisible(FALSE);
        break;
    case SEASONALWINDOW:
        setWindowTitle(tr("QtGrace: Seasonal differences"));
        number=1;
        entr[0]=QString("dummy");
        selector1=new StdSelector(this,QString(""),number,entr);
        selector2=new StdSelector(this,QString(""),number,entr);
        selector3=new StdSelector(this,QString(""),number,entr);
        selector1->setVisible(FALSE);
        selector2->setVisible(FALSE);
        selector3->setVisible(FALSE);
        lenText->lblText->setText(tr("Period:"));
        layout->addWidget(lenText,index++,0,1,2);
        break;
    case DIFFERENCESWINDOW:
        setWindowTitle(tr("QtGrace: Differences"));
        number=3;
        entr[0]=tr("Forward difference");
        entr[1]=tr("Backward difference");
        entr[2]=tr("Centered difference");
        selector1=new StdSelector(this,tr("Method:"),number,entr);
        selector2=new StdSelector(this,QString(""),number,entr);
        selector3=new StdSelector(this,QString(""),number,entr);
        selector2->setVisible(FALSE);
        selector3->setVisible(FALSE);
        layout->addWidget(selector1,index++,0,1,2);
        lenText->setVisible(FALSE);
        break;
    case AVERAGESWINDOW:
        setWindowTitle(tr("QtGrace: Running averages"));
        number=5;
        entr[0]=tr("Average");
        entr[1]=tr("Median");
        entr[2]=tr("Minimum");
        entr[3]=tr("Maximum");
        entr[4]=tr("Std. dev.");
        selector1=new StdSelector(this,tr("Running:"),number,entr);
        number=8;
        entr[0]=tr("None");
        entr[1]=tr("Region 0");
        entr[2]=tr("Region 1");
        entr[3]=tr("Region 2");
        entr[4]=tr("Region 3");
        entr[5]=tr("Region 4");
        entr[6]=tr("Inside graph");
        entr[7]=tr("Outside graph");
        selector2=new StdSelector(this,tr("Restrictions:"),number,entr);
        selector3=new StdSelector(this,QString(""),number,entr);
        selector3->setVisible(FALSE);
        chkInvert->setVisible(TRUE);
        lenText->lblText->setText(tr("Length of average:"));
        layout->addWidget(selector1,index++,0,1,2);
        layout->addWidget(lenText,index++,0,1,2);
        layout->addWidget(selector2,index++,0,1,2);
        layout->addWidget(chkInvert,index++,0,1,2);
        break;
    case REGRESSIONWINDOW:
        setWindowTitle(tr("QtGrace: Regression"));
        lenText->lenText->setText(QString("$t"));
        lenText->lblText->setText(tr("Load x as "));
        StartStop->lblStart->setText(tr("Start $t at:"));
        StartStop->lblStop->setText(tr("Stop $t at:"));
        lenText->setVisible(TRUE);
        number=15;
        entr[0]=tr("Linear");
        entr[1]=tr("Quadratic");
        entr[2]=tr("Cubic");
        entr[3]=tr("4th degree");
        entr[4]=tr("5th degree");
        entr[5]=tr("6th degree");
        entr[6]=tr("7th degree");
        entr[7]=tr("8th degree");
        entr[8]=tr("9th degree");
        entr[9]=tr("10th degree");
        entr[10]=tr("1-10");
        entr[11]=tr("Power y=A*x^B");
        entr[12]=tr("Exponential y=A*exp(B*x)");
        entr[13]=tr("Logarithmic y=A+B*ln(x)");
        entr[14]=tr("Inverse y=1/(A+B*x)");
        selector1=new StdSelector(this,tr("Type of fit:"),number,entr);
        number=4;
        entr[0]=tr("Fitted values");
        entr[1]=tr("Residuals");
        entr[2]=tr("Function");
        entr[3]=tr("None");
        selector2=new StdSelector(this,tr("Load:"),number,entr);
        connect(selector2->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(loadChanged(int)));
        number=8;
        entr[0]=tr("None");
        entr[1]=tr("Region 0");
        entr[2]=tr("Region 1");
        entr[3]=tr("Region 2");
        entr[4]=tr("Region 3");
        entr[5]=tr("Region 4");
        entr[6]=tr("Inside graph");
        entr[7]=tr("Outside graph");
        selector3=new StdSelector(this,tr("Restrictions:"),number,entr);
        chkInvert->setVisible(TRUE);
        StartStop->setVisible(TRUE);
        lenText->setEnabled(FALSE);
        StartStop->setEnabled(FALSE);
        layout->addWidget(selector1,index++,0,1,2);
        layout->addWidget(selector2,index++,0,1,2);
        layout->addWidget(selector3,index++,0,1,2);
        layout->addWidget(chkInvert,index,0,1,1);
        layout->addWidget(lenText,index++,1,1,1);
        layout->addWidget(StartStop,index++,0,1,2);
        layout->setColumnMinimumWidth(0,230);
        layout->setColumnMinimumWidth(1,230);
        break;
    }
    layout->addWidget(buttonGroup,index++,0,1,2);
    setLayout(layout);
    switch (WindowType)
    {
    case AVERAGESWINDOW:
    resize(LastSize_FormAverages);
    break;
    case REGRESSIONWINDOW:
    resize(LastSize_FormRegression);
    break;
    case DIFFERENCESWINDOW:
    resize(LastSize_FormDifferences);
    break;
    case SEASONALWINDOW:
    resize(LastSize_FormSeasonDiff);
    break;
    case INTEGRATIONWINDOW:
    resize(LastSize_FormIntegration);
    break;
    }
}

frmSmallCalc::~frmSmallCalc()
{
    switch (WindowType)
    {
    case AVERAGESWINDOW:
    LastSize_FormAverages=this->size();
    break;
    case REGRESSIONWINDOW:
    LastSize_FormRegression=this->size();
    break;
    case DIFFERENCESWINDOW:
    LastSize_FormDifferences=this->size();
    break;
    case SEASONALWINDOW:
    LastSize_FormSeasonDiff=this->size();
    break;
    case INTEGRATIONWINDOW:
    LastSize_FormIntegration=this->size();
    break;
    }
}

void frmSmallCalc::loadChanged(int i)
{
    if (i==2)
    {
        lenText->setEnabled(TRUE);
        StartStop->setEnabled(TRUE);
    }
    else
    {
        lenText->setEnabled(FALSE);
        StartStop->setEnabled(FALSE);
    }
}

void frmSmallCalc::init(void)
{
    listSets->set_graph_number(get_cg(),false);
    listSets->update_number_of_entries();
int *selsets=new int[5];
int cnt;
    listSets->get_all_entries(&cnt,&selsets);
//qDebug() << "cnt=" << cnt << "number_of_entries=" << listSets->number_of_entries << "show_all_sets_marker=" << listSets->show_all_sets_marker;
//for (int i=0;i<cnt;i++) qDebug() << selsets[i];
    if (cnt>0)
    listSets->set_new_selection(1,selsets);
delete[] selsets;
}

void frmSmallCalc::doAccept(void)
{
    int gno = get_cg();
    int *selsets=new int[5];
    int i, cnt,ideg, iresid, j;
    int setno, itype,period;
    int runlen, runtype, rno, invr;
    int nstep = 0, rx, rset = 0;
    double sum;
    double xstart, xstop;//, stepsize = 0.0;
    set_wait_cursor();
    cnt = GetSelectedSets(listSets, &selsets);
    if (cnt == SET_SELECT_ERROR || cnt <=0)
    {
        errwin(tr("No sets selected").toLocal8Bit().constData());
        delete[] selsets;
        return;
    }
    int * gnos=new int[cnt>1?cnt:2];
    int * snos=new int[cnt>1?cnt:2];
    int new_sets=0;
    char dummy[MAX_STRING_LENGTH];
    switch (WindowType)
    {
    case INTEGRATIONWINDOW:
        itype = GetChoice(selector1);
        for (i = 0; i < cnt; i++)
        {
            setno = selsets[i];
            sum = do_int(gno, setno, itype);
            if (new_set_no!=-1)
            {
                gnos[new_sets]=gno;
                snos[new_sets]=new_set_no;
                new_sets++;
            }
            lenText->setDoubleValue(sformat,sum);
        }
        if (new_sets>0)
        {
            SetsCreated(new_sets,gnos,snos,UNDO_COMPLETE);
            if (new_sets==1)
            {
                sprintf(dummy," [G%d.S%d]",gno, selsets[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Integration of")+QString(dummy),QString());
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Integration"),QString());
            }
        }
        break;
    case SEASONALWINDOW:
        if(xv_evalexpri(lenText, &period ) != RETURN_SUCCESS)
        {
            delete[] selsets;
            delete[] snos;
            delete[] gnos;
            return;
        }
        for (i = 0; i < cnt; i++)
        {
            setno = selsets[i];
            do_seasonal_diff(setno, period);
            if (new_set_no!=-1)
            {
                gnos[new_sets]=gno;
                snos[new_sets]=new_set_no;
                new_sets++;
            }
        }
        if (new_sets>0)
        {
            SetsCreated(new_sets,gnos,snos,UNDO_COMPLETE);
            if (new_sets==1)
            {
                sprintf(dummy," [G%d.S%d]",gno, selsets[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Seasonal differences of")+QString(dummy),QString());
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Seasonal differences"),QString());
            }
        }
        break;
    case DIFFERENCESWINDOW:
        itype = (int) GetChoice(selector1);
        for (i = 0; i < cnt; i++)
        {
            setno = selsets[i];
            do_differ(gno, setno, itype);
            if (new_set_no!=-1)
            {
                gnos[new_sets]=gno;
                snos[new_sets]=new_set_no;
                new_sets++;
            }
        }
        if (new_sets>0)
        {
            SetsCreated(new_sets,gnos,snos,UNDO_COMPLETE);
            if (new_sets==1)
            {
                sprintf(dummy," [G%d.S%d]",gno, selsets[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Differences of")+QString(dummy),QString());
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Differences"),QString());
            }
        }
        break;
    case AVERAGESWINDOW:
        if (xv_evalexpri(lenText, &runlen ) != RETURN_SUCCESS)
        {
            delete[] selsets;
            delete[] snos;
            delete[] gnos;
            return;
        }
        runtype = GetChoice(selector1);
        rno = GetChoice(selector2) - 1;
        invr = GetToggleButtonState(chkInvert);
        for (i = 0; i < cnt; i++)
        {
            setno = selsets[i];
            do_runavg(gno, setno, runlen, runtype, rno, invr);
            if (new_set_no!=-1)
            {
                gnos[new_sets]=gno;
                snos[new_sets]=new_set_no;
                new_sets++;
            }
        }
        if (new_sets>0)
        {
            SetsCreated(new_sets,gnos,snos,UNDO_COMPLETE);
            if (new_sets==1)
            {
                sprintf(dummy," [G%d.S%d]",gno, selsets[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Averages of")+QString(dummy),QString());
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Averages"),QString());
            }
        }
        break;
    case REGRESSIONWINDOW:
        rno = GetChoice(selector3);
        switch (rno)
        {
        case 0:
        default:
            rno=RESTRICT_NONE;
            break;
        case 1:
            rno=RESTRICT_REG0;
            break;
        case 2:
            rno=RESTRICT_REG1;
            break;
        case 3:
            rno=RESTRICT_REG2;
            break;
        case 4:
            rno=RESTRICT_REG3;
            break;
        case 5:
            rno=RESTRICT_REG4;
            break;
        case 6:
            rno=MAXREGION;//RESTRICT_WORLD;
            break;
        case 7:
            rno=MAXREGION+1;//RESTRICT_WORLD;
            break;
        }
        //qDebug() << "rno=" << rno;
        if (!isactive_region(rno) && rno!=RESTRICT_NONE && rno!=RESTRICT_WORLD)
        {
            errwin(tr("Selected region is not active").toLocal8Bit().constData());
            delete[] selsets;
            delete[] snos;
            delete[] gnos;
            return;
        }

        invr = GetToggleButtonState(chkInvert);
        ideg = (int) GetChoice(selector1) + 1;

        if (ideg==11)
        {
            delete[] gnos;
            delete[] snos;
            gnos=new int[11*(cnt>0?cnt:2)];
            snos=new int[11*(cnt>0?cnt:2)];
        }
        gnos[0]=gno;
        dummy[0]='\0';
        nstep=0;
        xstart=xstop=0.0;
        switch( rx = GetChoice(selector2) )
        {
        case 3:             /* do not evaluate the function at all - just calculate the formula */
            iresid = 2;
            rset = -1;
            break;
        case 0:				/* evaluate fitted function at original x's */
            iresid = 0;
            rset = -1;
            break;
        case 1:				/* load residue at original x points */
            iresid = 1;
            rset = -1;
            break;
        case 2:		/* evaluate fitted function at new x points */
            iresid = 0;
            if(xv_evalexpri(StartStop->ledLength, &nstep) != RETURN_SUCCESS || nstep < 2 )
            {
                errwin(tr("Number points < 2").toLocal8Bit().constData());
                delete[] selsets;
                delete[] snos;
                delete[] gnos;
                return;
            }
            if(xv_evalexpr(StartStop->ledStart, &xstart ) != RETURN_SUCCESS)
            {
                errwin(tr("Specify starting value").toLocal8Bit().constData());
                delete[] selsets;
                delete[] snos;
                delete[] gnos;
                return;
            }
            if(xv_evalexpr(StartStop->ledStop, &xstop) != RETURN_SUCCESS)
            {
                errwin(tr("Specify stopping value").toLocal8Bit().constData());
                delete[] selsets;
                delete[] snos;
                delete[] gnos;
                return;
            }
            /*else
            {
                stepsize = (xstop - xstart)/(nstep-1);
            }*/
            strcpy(dummy,lenText->text().toLatin1().constData());
            //qDebug() << "conversion-formula=#" << dummy << "#";
            if (strlen(dummy)<1)
            {
                errwin(tr("Specify formula for x-values as a function of $t").toLocal8Bit().constData());
                delete[] selsets;
                delete[] snos;
                delete[] gnos;
                return;
            }
            else
            {
                ReplaceDecimalSeparator(dummy,true);
            }
            //qDebug() << "conversion-formula=#" << dummy << "#";
            break;
        default:
            errwin(tr("Internal error").toLocal8Bit().constData());
            delete[] selsets;
            delete[] snos;
            delete[] gnos;
            return;
            break;
        }
        new_set_no=-1;
        for (i = (ideg==11?1:ideg); i <= (ideg==11?10:ideg); i++)
        {
            for (j = 0; j < cnt; j++)
            {
                setno = selsets[j];
                if( rx == 2 )
                {
                    if( (rset = nextset( gno )) == -1 )
                    {
                        errwin(tr("Not enough sets").toLocal8Bit().constData());
                        delete[] selsets;
                        delete[] snos;
                        delete[] gnos;
                        return;
                    }
                    /*activateset( gno, rset );
                    setlength( gno, rset, nstep);
                    xr = getx( gno, rset );
                    for( k=0; k<nstep; k++ )
                    xr[k] = xstart+k*stepsize;*/
                    if (generate_x_mesh_from_formula(gno,rset,xstart,xstop,nstep,dummy,SET_XY)==RETURN_FAILURE)
                    {
                        errwin(tr("Not enough sets").toLocal8Bit().constData());
                        delete[] selsets;
                        delete[] snos;
                        delete[] gnos;
                        return;
                    }
                }
                //qDebug() << "Regression on G" << gno << ".S" << setno << "restriction" << rno << endl;
            do_regress(gno, setno, i, iresid, rno, invr, rset);
                if (!is_set_active(gno,new_set_no)) new_set_no=-1;
                if (new_set_no!=-1)
                {
                    //qDebug() << "new_set_no=" << new_set_no;
                    gnos[new_sets]=gno;
                    snos[new_sets]=new_set_no;
                    new_sets++;
                }
            }
        }
        if (new_sets>=0)//Warning: '=0' may be problematic
        {
        /*SetsCreated(new_sets,gnos,snos,UNDO_COMPLETE);
        if (new_sets==1)
        {
        sprintf(dummy," [G%d.S%d]",gno, selsets[0]);
        addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Regression of")+QString(dummy),QString());
        }
        else
        {
        addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Regression"),QString());
        }*/
            SetRegression(cnt,gnos,selsets,new_sets,gnos,snos,ideg,iresid,rno,invr,xstart,xstop,nstep,rx,dummy);
        }
        break;
    }
    //update_set_lists(gno);
    //listSets->update_number_of_entries_preserve_selection();
    unset_wait_cursor();
    mainWin->mainArea->completeRedraw();

    listSets->set_graph_number(get_cg(),false);
    listSets->set_new_selection(cnt,selsets);

    delete[] selsets;
    delete[] snos;
    delete[] gnos;
}

void frmSmallCalc::doClose(void)
{
    hide();
}

frmCorrelation::frmCorrelation(int type,QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));

    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    WindowType=type;

    lblSelect1=new QLabel(QString(""),this);
    listSet1=new uniList(SETCHOICE,this);
    listSet1->setBehavior(true,false,false);
    lblSelect2=new QLabel(QString(""),this);
    listSet2=new uniList(SETCHOICE,this);
    listSet2->setBehavior(true,false,false);
    lenLag=new stdLineEdit(this,tr("Maximum lag:"));
    lenLag->lenText->setText(QString(""));
    chkCovariance=new QCheckBox(tr("Calculate covariance"),this);
    buttonGroup=new stdButtonGroup(this,false,true,false);
    buttonGroup->cmdAccept->setDefault(TRUE);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->addWidget(lblSelect1);
    layout->addWidget(listSet1);
    layout->addWidget(lblSelect2);
    layout->addWidget(listSet2);
    switch (type)
    {
    case CORRELATIONWINDOW:
        setWindowTitle(tr("QtGrace: Correlation/Covariance"));
        lblSelect1->setText(tr("Select set:"));
        lblSelect2->setText(tr("Select set:"));
        layout->addWidget(lenLag);
        layout->addWidget(chkCovariance);
        break;
    case CONVOLUTIONWINDOW:
        setWindowTitle(tr("QtGrace: Linear convolution"));
        lblSelect1->setText(tr("Convolve set:"));
        lblSelect2->setText(tr("With set:"));
        chkCovariance->setVisible(FALSE);
        lenLag->setVisible(FALSE);
        break;
    case FILTERWINDOW:
        setWindowTitle(tr("QtGrace: Digital Filter"));
        lblSelect1->setText(tr("Filter set:"));
        lblSelect2->setText(tr("With weights from set:"));
        chkCovariance->setVisible(FALSE);
        lenLag->setVisible(FALSE);
        break;
    }
    layout->addWidget(buttonGroup);
    setLayout(layout);
    switch (WindowType)
    {
    case CORRELATIONWINDOW:
    resize(LastSize_FormCorrelation);
    break;
    case CONVOLUTIONWINDOW:
    resize(LastSize_FormConvolution);
    break;
    case FILTERWINDOW:
    resize(LastSize_FormDigitalFilter);
    break;
    }
}

frmCorrelation::~frmCorrelation()
{
    switch (WindowType)
    {
    case CORRELATIONWINDOW:
    LastSize_FormCorrelation=this->size();
    break;
    case CONVOLUTIONWINDOW:
    LastSize_FormConvolution=this->size();
    break;
    case FILTERWINDOW:
    LastSize_FormDigitalFilter=this->size();
    break;
    }
}

void frmCorrelation::init(void)
{
    listSet1->update_number_of_entries();
    listSet2->update_number_of_entries();
}

void frmCorrelation::doAccept(void)
{
    int set1, set2, maxlag, covar;
    set_wait_cursor();
    set1 = GetSelectedSet(listSet1);
    set2 = GetSelectedSet(listSet2);
    if (set1 == SET_SELECT_ERROR || set2 == SET_SELECT_ERROR) {
        errwin(tr("Select 2 sets").toLocal8Bit().constData());
        unset_wait_cursor();
        return;
    }
    int * gnos=new int[2];
    int * snos=new int[2];
    gnos[0]=gnos[1]=get_cg();
    char dummy[256];
    switch (WindowType)
    {
    case CORRELATIONWINDOW:
        if(xv_evalexpri(lenLag, &maxlag) != RETURN_SUCCESS) {
            unset_wait_cursor();
            delete[] gnos;
            delete[] snos;
            return;
        }
        covar = GetToggleButtonState(chkCovariance);
        do_xcor(get_cg(), set1, get_cg(), set2, maxlag, covar);
        break;
    case CONVOLUTIONWINDOW:
        do_linearc(get_cg(), set1, get_cg(), set2);
        break;
    case FILTERWINDOW:
        do_digfilter(set1, set2);
        break;
    }
    snos[0]=snos[1]=new_set_no;
    if (new_set_no!=-1)
    {
        SetsCreated(1,gnos,snos,UNDO_COMPLETE);
        sprintf(dummy," [G%d S%d<->S%d]",get_cg(),set1,set2);
        addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,this->windowTitle().mid(9,-1)+QString(dummy),QString());
    }
    update_set_lists(get_cg());
    unset_wait_cursor();
    mainWin->mainArea->completeRedraw();
    delete[] gnos;
    delete[] snos;
}

void frmCorrelation::doClose(void)
{
    hide();
}

frmTransform::frmTransform(int type,QWidget * parent):QDialog(parent)
{
    int number;
    QString entr[6];
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));
    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    WindowType=type;
    lblApplyTo=new QLabel(tr("Apply to sets:"),this);
    layout->addWidget(lblApplyTo);
    listSets=new uniList(SETCHOICE,this);
    listSets->setBehavior(false,true,true);
    layout->addWidget(listSets);

    for (int i=0;i<7;i++)
        lenText[i]=new stdLineEdit(this,QString(""));

    switch (type)
    {
    case PRUNEWINDOW:
        setWindowTitle(tr("QtGrace: Prune data"));
        number=4;
        entr[0]=tr("Interpolation");
        entr[1]=tr("Circle");
        entr[2]=tr("Ellipse");
        entr[3]=tr("Rectangle");
        selector[0]=new StdSelector(this,tr("Prune type:"),number,entr);
        connect(selector[0]->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(PruneTypeChanged(int)));
        layout->addWidget(selector[0]);
        lenText[0]->lblText->setText(tr("Delta X:"));
        lenText[0]->lenText->setText(QString(""));
        layout->addWidget(lenText[0]);
        lenText[1]->lblText->setText(tr("Delta Y:"));
        lenText[1]->lenText->setText(QString(""));
        layout->addWidget(lenText[1]);
        for (int i=2;i<7;i++)
            lenText[i]->setVisible(FALSE);
        lenText[0]->setEnabled(FALSE);
        lenText[1]->setEnabled(TRUE);
        number=2;
        entr[0]=tr("Viewport");
        entr[1]=tr("World");
        selector[1]=new StdSelector(this,tr("Type of Delta coordinates:"),number,entr);
        connect(selector[1]->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(CoordsChanged(int)));
        layout->addWidget(selector[1]);
        number=2;
        entr[0]=tr("Linear");
        entr[1]=tr("Logarithmic");
        selector[2]=new StdSelector(this,tr("Scaling of Delta X:"),number,entr);
        selector[3]=new StdSelector(this,tr("Scaling of Delta Y:"),number,entr);
        layout->addWidget(selector[2]);
        layout->addWidget(selector[3]);
        selector[2]->setEnabled(FALSE);
        selector[3]->setEnabled(FALSE);
        break;
    case SAMPLEPOINTSWINDOW:
        setWindowTitle(tr("QtGrace: Sample points"));
        number=2;
        entr[0]=tr("Start/step");
        entr[1]=tr("Expression");
        selector[0]=new StdSelector(this,tr("Sample type:"),number,entr);
        layout->addWidget(selector[0]);
        for (int i=1;i<4;i++)
        {
            selector[i]=new StdSelector(this,QString("dummy"),number,entr);
            selector[i]->setVisible(FALSE);
        }
        lenText[0]->lblText->setText(tr("Start:"));
        lenText[0]->lenText->setText(QString(""));
        layout->addWidget(lenText[0]);
        lenText[1]->lblText->setText(tr("Step:"));
        lenText[1]->lenText->setText(QString(""));
        layout->addWidget(lenText[1]);
        lenText[2]->lblText->setText(tr("Logical expression:"));
        lenText[2]->lenText->setText(QString(""));
        lenText[2]->setEnabled(false);
        layout->addWidget(lenText[2]);
        for (int i=3;i<7;i++)
            lenText[i]->setVisible(FALSE);
        connect(selector[0]->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(selectorChanged(int)));
        break;
    case GEOMETRICWINDOW:
        setWindowTitle(tr("QtGrace: Geometric transformations"));
        lenText[0]->lblText->setText(tr("Rotation (degrees):"));
        lenText[1]->lblText->setText(tr("Rotate about X:"));
        lenText[2]->lblText->setText(tr("Rotate about Y:"));
        lenText[3]->lblText->setText(tr("Scale X:"));
        if (DecimalPointToUse=='.')
            lenText[3]->lenText->setText(QString("1.0"));
        else
            lenText[3]->lenText->setText(QString("1,0"));
        lenText[4]->lblText->setText(tr("Scale Y:"));
        if (DecimalPointToUse=='.')
            lenText[4]->lenText->setText(QString("1.0"));
        else
            lenText[4]->lenText->setText(QString("1,0"));
        lenText[5]->lblText->setText(tr("Translate X:"));
        lenText[6]->lblText->setText(tr("Translate Y:"));
        for (int i=0;i<7;i++)
            layout->addWidget(lenText[i]);
        number=6;
        entr[0]=tr("Rotate, translate, scale");
        entr[1]=tr("Rotate, scale, translate");
        entr[2]=tr("Translate, scale, rotate");
        entr[3]=tr("Translate, rotate, scale");
        entr[4]=tr("Scale, translate, rotate");
        entr[5]=tr("Scale, rotate, translate");
        selector[0]=new StdSelector(this,tr("Apply in order:"),number,entr);
        for (int i=1;i<4;i++)
        {
            selector[i]=new StdSelector(this,QString("dummy"),number,entr);
            selector[i]->setVisible(FALSE);
        }
        layout->addWidget(selector[0]);
        break;
    }
    if (type!=GEOMETRICWINDOW)
    {
        buttonGroup=new stdButtonGroup(this,false,true,false);
        buttonGroup->cmdAccept->setDefault(TRUE);
        connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
        connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    }
    else
    {
        buttonGroup=new stdButtonGroup(this,true,true,false);
        buttonGroup->cmdAccept->setText(tr("Reset"));
        connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doAccept()));
        connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doReset()));
        connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    }
    layout->addWidget(buttonGroup);
    setLayout(layout);
    switch (WindowType)
    {
    case PRUNEWINDOW:
    resize(LastSize_FormPruneData);
    break;
    case GEOMETRICWINDOW:
    resize(LastSize_FormGeometricTransform);
    break;
    case SAMPLEPOINTSWINDOW:
    resize(LastSize_FormSamplePoints);
    break;
    }
}

frmTransform::~frmTransform()
{
    switch (WindowType)
    {
    case PRUNEWINDOW:
    LastSize_FormPruneData=this->size();
    break;
    case GEOMETRICWINDOW:
    LastSize_FormGeometricTransform=this->size();
    break;
    case SAMPLEPOINTSWINDOW:
    LastSize_FormSamplePoints=this->size();
    break;
    }
}

void frmTransform::CoordsChanged(int i)
{
    if (i==0)//Viewport
    {
        selector[2]->setEnabled(FALSE);
        selector[3]->setEnabled(FALSE);
    }
    else//World
    {
        switch (selector[0]->currentIndex())
        {
        case 0:
            selector[2]->setEnabled(FALSE);
            selector[3]->setEnabled(TRUE);
            break;
        case 1:
            selector[2]->setEnabled(TRUE);
            selector[3]->setEnabled(FALSE);
            break;
        case 2:
        case 3:
            selector[2]->setEnabled(TRUE);
            selector[3]->setEnabled(TRUE);
            break;
        }
    }
}

void frmTransform::PruneTypeChanged(int i)
{
    switch (i)
    {
    case 0:
        lenText[0]->setEnabled(FALSE);
        lenText[1]->setEnabled(TRUE);
        break;
    case 1:
        lenText[0]->setEnabled(TRUE);
        lenText[1]->setEnabled(FALSE);
        break;
    case 2:
    case 3:
        lenText[0]->setEnabled(TRUE);
        lenText[1]->setEnabled(TRUE);
        break;
    }
    CoordsChanged(selector[1]->currentIndex());
}

void frmTransform::init(void)
{
    listSets->update_number_of_entries();
}

void frmTransform::doAccept(void)
{
    int i, j, k, cnt, order[3], ord;
    double degrees, sx, sy, rotx, roty, tx, ty, xtmp, ytmp, *x, *y;
    double cosd, sind;
    int *selsets=new int[5];
    int setno, typeno, deltatypeno;
    int dxtype, dytype;
    double deltax, deltay;
    const char *exprstr;
    char * exprstr2;
    int startno, stepno;
    set_wait_cursor();
    cnt = GetSelectedSets(listSets, &selsets);
    if (cnt<=0){// == SET_SELECT_ERROR) {
        errwin(tr("No sets selected").toLocal8Bit().constData());
        unset_wait_cursor();
        return;
    }
    int * gnos=new int[cnt>0?cnt:2];
    int * snos=new int[cnt>0?cnt:2];
    int set_no=0;
    char dummy[256];
    switch (WindowType)
    {
    case PRUNEWINDOW:
        typeno = (int) GetChoice(selector[0]);
        deltatypeno = (int) GetChoice(selector[1]);
        dxtype = (int) GetChoice(selector[2]);
        dytype = (int) GetChoice(selector[3]);
        if(lenText[0]->isEnabled() == true )
        {
            if(xv_evalexpr(lenText[0], &deltax) != RETURN_SUCCESS)
            {
                errmsg(tr("Invalid Delta X!").toLocal8Bit().constData());
                unset_wait_cursor();
                return;
            }
        }
        else
            deltax = 0;

        if( lenText[1]->isEnabled() == true )
        {
            if(xv_evalexpr(lenText[1], &deltay) != RETURN_SUCCESS )
            {
                errmsg(tr("Invalid Delta Y!").toLocal8Bit().constData());
                unset_wait_cursor();
                return;
            }
        }
        else
            deltay = 0;

        for (i = 0; i < cnt; i++)
        {
            setno = selsets[i];
            do_prune(setno, typeno, deltatypeno, deltax, deltay, dxtype, dytype);
            if (new_set_no!=-1)
            {
                gnos[set_no]=get_cg();
                snos[set_no]=new_set_no;
                set_no++;
            }
        }
        update_set_lists(get_cg());
        if (set_no>0)
        {
            SetsCreated(set_no,gnos,snos,UNDO_COMPLETE);
            if (set_no==1)
            {
                sprintf(dummy," [G%d.S%d]",get_cg(), selsets[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Prune data")+QString(dummy),QString());
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Prune data"),QString());
            }
        }
        break;
    case SAMPLEPOINTSWINDOW:
        typeno = GetChoice(selector[0]);
        if (typeno == 0) {
            exprstr =  "";
            if (xv_evalexpri(lenText[0], &startno) != RETURN_SUCCESS ||
                    xv_evalexpri(lenText[1], &stepno)   != RETURN_SUCCESS) {
                errmsg(tr("Please select start and step values").toLocal8Bit().constData());
                unset_wait_cursor();
                return;
            }
        } else {
            exprstr = xv_getstr(lenText[2]);
            startno = stepno = 1;
        }
        exprstr2=new char[strlen(exprstr)+2];
        strcpy(exprstr2,exprstr);
        for (i = 0; i < cnt; i++)
        {
            setno = selsets[i];
            do_sample(setno, typeno, exprstr2, startno, stepno);
            if (new_set_no!=-1 && is_set_active(get_cg(),new_set_no))
            {
                gnos[set_no]=get_cg();
                snos[set_no]=new_set_no;
                set_no++;
            }
        }
        delete[] exprstr2;
        update_set_lists(get_cg());
        if (set_no>0)
        {
            SetsCreated(set_no,gnos,snos,UNDO_COMPLETE);
            if (set_no==1)
            {
                sprintf(dummy," [G%d.S%d]",get_cg(), selsets[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Sample points")+QString(dummy),QString());
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Sample points"),QString());
            }
        }
        break;
    case GEOMETRICWINDOW:
        ord = (int) GetChoice(selector[0]);
        switch (ord)
        {
        case 0:
            order[0] = 0;		/* rotate */
            order[1] = 1;		/* translate */
            order[2] = 2;		/* scale */
            break;
        case 1:
            order[0] = 0;
            order[1] = 2;
            order[2] = 1;
            break;
        case 2:
            order[0] = 1;
            order[1] = 2;
            order[2] = 0;
            break;
        case 3:
            order[0] = 1;
            order[1] = 0;
            order[2] = 2;
            break;
        case 4:
            order[0] = 2;
            order[1] = 1;
            order[2] = 0;
            break;
        case 5:
            order[0] = 2;
            order[1] = 0;
            order[2] = 1;
            break;
        }
        /* check input fields */
        if (xv_evalexpr(lenText[0], &degrees) != RETURN_SUCCESS ||
                xv_evalexpr(lenText[1], &rotx)    != RETURN_SUCCESS ||
                xv_evalexpr(lenText[2], &roty)    != RETURN_SUCCESS ||
                xv_evalexpr(lenText[5], &tx)      != RETURN_SUCCESS ||
                xv_evalexpr(lenText[6], &ty)      != RETURN_SUCCESS ||
                xv_evalexpr(lenText[3], &sx)      != RETURN_SUCCESS ||
                xv_evalexpr(lenText[4], &sy)      != RETURN_SUCCESS )
            return;
        degrees = M_PI / 180.0 * degrees;
        cosd = cos(degrees);
        sind = sin(degrees);

        for (i=0;i<cnt;i++)
            gnos[i]=get_cg();

        SaveSetStatesPrevious(cnt,gnos,selsets,UNDO_DATA);
        for (k = 0; k < cnt; k++) {
            setno = selsets[k];
            if (is_set_active(get_cg(), setno)) {
                x = getx(get_cg(), setno);
                y = gety(get_cg(), setno);
                for (j = 0; j < 3; j++) {
                    switch (order[j]) {
                    case 0:			/* rotate */
                        if (degrees == 0.0) {
                            break;
                        }
                        for (i = 0; i < getsetlength(get_cg(), setno); i++) {
                            xtmp = x[i] - rotx;
                            ytmp = y[i] - roty;
                            x[i] = rotx + cosd * xtmp - sind * ytmp;
                            y[i] = roty + sind * xtmp + cosd * ytmp;
                        }
                        break;
                    case 1:			/* translate */
                        for (i = 0; i < getsetlength(get_cg(), setno); i++) {
                            x[i] += tx;
                            y[i] += ty;
                        }
                        break;
                    case 2:					/* scale */
                        for (i = 0; i < getsetlength(get_cg(), setno); i++) {
                            x[i] *= sx;
                            y[i] *= sy;
                        }
                        break;
                    }		/* end case */
                }			/* end for j */
                update_set_lists(get_cg());
            }			/* end if */
        }				/* end for k */
        if (cnt>0)
        {
            SetsModified(cnt,gnos,selsets,UNDO_DATA);
            if (cnt==1)
            {
                sprintf(dummy," [G%d.S%d]",get_cg(), selsets[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Geometric transformation of")+QString(dummy),QString());
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Geometric transformation"),QString());
            }
        }
        set_dirtystate();
        break;
    }
    delete[] selsets;
    listSets->update_number_of_entries_preserve_selection();
    unset_wait_cursor();
    mainWin->mainArea->completeRedraw();
    delete[] gnos;
    delete[] snos;
}

void frmTransform::doReset(void)
{
    if (DecimalPointToUse=='.')
    {
        xv_setstr(lenText[0], "0.0");
        xv_setstr(lenText[1], "0.0");
        xv_setstr(lenText[2], "0.0");
        xv_setstr(lenText[3], "1.0");
        xv_setstr(lenText[4], "1.0");
        xv_setstr(lenText[5], "0.0");
        xv_setstr(lenText[6], "0.0");
    }
    else
    {
        xv_setstr(lenText[0], "0,0");
        xv_setstr(lenText[1], "0,0");
        xv_setstr(lenText[2], "0,0");
        xv_setstr(lenText[3], "1,0");
        xv_setstr(lenText[4], "1,0");
        xv_setstr(lenText[5], "0,0");
        xv_setstr(lenText[6], "0,0");
    }
}

void frmTransform::doClose(void)
{
    hide();
}

void frmTransform::selectorChanged(int i)
{
    if (WindowType==SAMPLEPOINTSWINDOW)
    {
        if (i==0)//start/stop
        {
            lenText[0]->setEnabled(true);
            lenText[1]->setEnabled(true);
            lenText[2]->setEnabled(false);
        }
        else//expression
        {
            lenText[0]->setEnabled(false);
            lenText[1]->setEnabled(false);
            lenText[2]->setEnabled(true);
        }
    }
}

void createSymbolIcons(QIcon ** symb_icons)
{
QPixmap map1(12*toolBarSizeFactor,12*toolBarSizeFactor);//(12,12)
QPainter paint1(&map1);
    paint1.setBrush(Qt::white);
    paint1.setPen(Qt::white);
    paint1.drawRect(0,0,13*toolBarSizeFactor,13*toolBarSizeFactor);//(0,0,13,13)
    paint1.setPen(Qt::black);
    paint1.setBrush(Qt::black);
    QFont dFont=getFontFromDatabase(0);
    dFont.setPixelSize(10*1.4*toolBarSizeFactor);//(10*1.8)
    paint1.setFont(dFont);
    paint1.end();
    (*symb_icons)[0]=QIcon(map1);
        for (int i=1;i<12;i++)
        {
        paint1.begin(&map1);
        paint1.setBrush(Qt::white);
        paint1.setPen(Qt::white);
        paint1.drawRect(0,0,13*toolBarSizeFactor,13*toolBarSizeFactor);//(0,0,13,13)
        paint1.setPen(Qt::black);
        paint1.setBrush(Qt::black);
        paint1.setFont(dFont);
            if (i==11)//this prints a character - in this case ASCII(65)='A'
            drawSimpleSymbol(paint1,3*sqrt(toolBarSizeFactor),11*toolBarSizeFactor,10*toolBarSizeFactor,i,65);//(paint1,12,2,10,i,65)
            else
            drawSimpleSymbol(paint1,6*toolBarSizeFactor,6*toolBarSizeFactor,10*toolBarSizeFactor,i,65);//(paint1,6,6,10,i,65)
        paint1.end();
        (*symb_icons)[i]=QIcon(map1);
        }
//qDebug() << "IconSize=" << map1.size();
}


frmNetCDF::frmNetCDF(QWidget * parent):QDialog(parent)
{
    cmdQuery=new QPushButton(tr("Close"),this);
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: netCDF"));
    setWindowIcon(QIcon(*GraceIcon));
    lblSelX=new QLabel(tr("Select set X:"));
    lblSelY=new QLabel(tr("Select set Y:"));
    netcdf_listx_item=new uniList(TEXTLIST,this);
    netcdf_listy_item=new uniList(TEXTLIST,this);
    netcdf_listx_item->setBehavior(true,false,false);
    netcdf_listy_item->setBehavior(true,false,false);
    netcdf_file_item=new stdLineEdit(this,tr("netCDF file:"));
    netcdf_file_item->lenText->setText(QString(""));
    buttonGroup=new stdButtonGroup(this,true,true,true);
    buttonGroup->layout->addWidget(cmdQuery);
    buttonGroup->cmdApply->setText(tr("Accept"));
    buttonGroup->cmdAccept->setText(tr("Files..."));
    buttonGroup->cmdClose->setText(tr("Update"));
    buttonGroup->cmdHelp->setText(tr("Query"));
    cmdQuery->setDefault(false);
    buttonGroup->cmdApply->setDefault(true);

    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doFiles()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(update_netcdfs()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(do_netcdf_proc()));
    connect(buttonGroup->cmdHelp,SIGNAL(clicked()),this,SLOT(do_netcdfquery_proc()));
    connect(cmdQuery,SIGNAL(clicked()),this,SLOT(doClose()));

    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->addWidget(lblSelX);
    layout->addWidget(netcdf_listx_item);
    layout->addWidget(lblSelY);
    layout->addWidget(netcdf_listy_item);
    layout->addWidget(netcdf_file_item);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    resize(LastSize_FormNetCDF);
}

frmNetCDF::~frmNetCDF()
{
    LastSize_FormNetCDF=this->size();
}

void frmNetCDF::init(void)
{
    update_netcdfs();
}

void frmNetCDF::doFiles(void)
{
QString openfilename;
    if (auto_set_cwd==TRUE)
    {
    openfilename=QString::fromLocal8Bit(get_workingdir());
    }
    else
    {
    openfilename=Last_Dialog_Path[READ_NETCDF_FORM];
    }
//qDebug() << "openfilename=" << openfilename;
if (should_open_grace_file_dialog())
{
    if (FormReadNetCDF==NULL)
    {
        FormReadNetCDF=new frmIOForm(READ_NETCDF_FORM,this);
        connect(FormReadNetCDF,SIGNAL(newFileSelectedForIO(int,QString,bool,bool,bool)),SLOT(IOrequested(int,QString,bool,bool,bool)));
    }
    FormReadNetCDF->init(openfilename.toLocal8Bit().data());
    FormReadNetCDF->show();
    FormReadNetCDF->raise();
    FormReadNetCDF->activateWindow();
}
else
{
mainWin->UseOperatingSystemFileDialog(READ_NETCDF_FORM,tr("QtGrace: Select netCDF file"),openfilename,tr("Netcdf files (*.nc);;All files (*)"));
}
}

void frmNetCDF::IOrequested(int type,QString file,bool exists,bool writeable,bool readable)
{
    (void)type;
    (void)writeable;
    char * filename=new char[file.length()+5];
    strcpy(filename,file.toLocal8Bit());
    char * dummy=new char[strlen(filename)+30];
    sprintf(dummy,"%s%s.",tr("Can't open file ").toLocal8Bit().constData(),filename);
    if (exists==true && readable==true)
    {
        xv_setstr(netcdf_file_item, filename);
        update_netcdfs();
        if (FormReadNetCDF)
        FormReadNetCDF->hide();
    }
    else
    {
        errwin(dummy);
    }
    delete[] dummy;
    delete[] filename;
}

void frmNetCDF::doClose(void)
{
    hide();
}

void frmNetCDF::update_netcdfs(void)
{
    int i;
    char buf[256], fname[512];
    QString xms;
    //int cdfid;			/* netCDF id */
    int ndims=0, nvars=0;//, ngatts, recdim;
    //int var_id;
    char varname[256];
    /*nc_type datatype = 0;
    int dim[100], natts;
    long dimlen[100];
    long len;*/

    set_wait_cursor();

    ncopts = 0;			/* no crash on error */

    //if (netcdf_frame != NULL) {
    strcpy(fname, xv_getstr(netcdf_file_item));
    set_wait_cursor();
    netcdf_listx_item->clear();
    //XmListDeleteAllItems(netcdf_listx_item);
    netcdf_listy_item->clear();
    //XmListDeleteAllItems(netcdf_listy_item);
    xms = tr("INDEX");
    netcdf_listx_item->add_Item(xms);
    //XmListAddItemUnselected(netcdf_listx_item, xms, 0);
    //XmStringFree(xms);

    if (strlen(fname) < 2) {
        unset_wait_cursor();
        return;
    }
#ifdef HAVE_NETCDF
    if ((cdfid = ncopen(fname, NC_NOWRITE)) == -1) {
        errmsg(tr("Can't open file.").toLocal8Bit().constData());
        unset_wait_cursor();
        return;
    }

    ncinquire(cdfid, &ndims, &nvars, &ngatts, &recdim);
    for (i = 0; i < ndims; i++) {
        ncdiminq(cdfid, i, NULL, &dimlen[i]);
    }
#endif
    for (i = 0; i < nvars; i++) {
#ifdef HAVE_NETCDF
        ncvarinq(cdfid, i, varname, &datatype, &ndims, dim, &natts);

        if ((var_id = ncvarid(cdfid, varname)) == -1) {
            char ebuf[256];
            sprintf(ebuf, "update_netcdfs(): %s %s",tr("No such variable").toLocal8Bit().constData(), varname);
            errmsg(ebuf);
            continue;
        }
#endif
        if (ndims != 1) {
            continue;
        }
#ifdef HAVE_NETCDF
        ncdiminq(cdfid, dim[0], (char *) NULL, &len);
#endif
        sprintf(buf, "%s", varname);
        xms = QString(buf);
        netcdf_listx_item->addItem(xms);
        //XmListAddItemUnselected(netcdf_listx_item, xms, 0);
        netcdf_listy_item->addItem(xms);
        //XmListAddItemUnselected(netcdf_listy_item, xms, 0);
        //XmStringFree(xms);
    }
#ifdef HAVE_NETCDF
    ncclose(cdfid);
#endif
    unset_wait_cursor();
    //}
}

void frmNetCDF::do_netcdf_proc(void)
{
    #ifdef HAVE_NETCDF
    int setno;
    #endif
    char xvar[256], yvar[256];
    QString *s=new QString(), cs;
    int *pos_list=new int[5];
    int pos_cnt, retval=RETURN_FAILURE;//j,cnt
    char cstr[256];
    set_wait_cursor();
/*
 * setno == -1, then next set
 */
    #ifdef HAVE_NETCDF
    setno = -1;
    #endif
    netcdf_listx_item->get_selection(&pos_cnt,&pos_list);
    if (pos_cnt) {//XmListGetSelectedPos(netcdf_listx_item, &pos_list, &pos_cnt)) {
        /*XtVaGetValues(netcdf_listx_item,
                      XmNselectedItemCount, &cnt,
                      XmNselectedItems, &s,
                      NULL);*/
        //cnt=pos_cnt;
        sprintf(cstr,"%d",pos_list[0]);
        *s=QString(cstr);
        cs = *s;//XmStringCopy(*s);
        strcpy(cstr,cs.toLocal8Bit());
        //if ((cstr = GetStringSimple(cs))) {
        if (strlen(cstr)) {
            strcpy(xvar, cstr);
            //XtFree(cstr);
        }
        //XmStringFree(cs);
    } else {
        errmsg(tr("Need to select X, either variable name or INDEX").toLocal8Bit().constData());
        unset_wait_cursor();
        return;
    }
    netcdf_listy_item->get_selection(&pos_cnt,&pos_list);
    if (pos_cnt) {//XmListGetSelectedPos(netcdf_listy_item, &pos_list, &pos_cnt)) {
        //j = pos_list[0];
        /*XtVaGetValues(netcdf_listy_item,
                      XmNselectedItemCount, &cnt,
                      XmNselectedItems, &s,
                      NULL);*/
        //cnt=pos_cnt;
        sprintf(cstr,"%d",pos_list[0]);
        *s=QString(cstr);
        cs = *s;//XmStringCopy(*s);
        strcpy(cstr,cs.toLocal8Bit());
        //if ((cstr = GetStringSimple(cs))) {
        if (strlen(cstr)) {
            strcpy(yvar, cstr);
            //XtFree(cstr);
        }
        //XmStringFree(cs);
    } else {
        errmsg(tr("Need to select Y").toLocal8Bit().constData());
        unset_wait_cursor();
        return;
    }
    if (strcmp(xvar, "INDEX") == 0) {
#ifdef HAVE_NETCDF
        retval = readnetcdf(get_cg(), setno, fname, NULL, yvar, -1, -1, 1);
#endif
    } else {
#ifdef HAVE_NETCDF
        retval = readnetcdf(get_cg(), setno, fname, xvar, yvar, -1, -1, 1);
#endif
    }
    if (retval) {
        mainWin->mainArea->completeRedraw();//xdrawgraph();
    }
    delete[] pos_list;
    delete s;

    unset_wait_cursor();
}

const char * frmNetCDF::getcdf_type(nc_type datatype)
{
    switch (datatype) {
    case NC_SHORT:
        return "NC_SHORT";
        break;
    case NC_LONG:
        return "NC_LONG";
        break;
    case NC_FLOAT:
        return "NC_FLOAT";
        break;
    case NC_DOUBLE:
        return "NC_DOUBLE";
        break;
    default:
        return "UNKNOWN (can't read this)";
        break;
    }
}

void frmNetCDF::do_netcdfquery_proc(void)
{
    char xvar[256], yvar[256];
    char buf[256], fname[512];
    int s, cs;
    int *pos_list=new int[5];
    int i=0, pos_cnt=0;//, cnt;
    char cstr[256];
//int cdfid;			/* netCDF id */
    nc_type datatype = 0;
    float f=0.0;
    double d=0.0;
//int x_id, y_id;
    nc_type xdatatype = 0;
    nc_type ydatatype = 0;
    int xnatts=0, ynatts=0;
    /*int xndims, xdim[10];
    int yndims, ydim[10];*/
    long nx=0, ny=0;

    int atlen=0;
    char attname[256];
    char atcharval[256];

    ncopts = 0;			/* no crash on error */

    set_wait_cursor();

    strcpy(fname, xv_getstr(netcdf_file_item));
#ifdef HAVE_NETCDF
    if ((cdfid = ncopen(fname, NC_NOWRITE)) == -1) {
        errmsg(tr("Can't open file.").toLocal8Bit().constData());
        unset_wait_cursor();
        return;
    }
#endif
    netcdf_listx_item->get_selection(&pos_cnt,&pos_list);
    if (pos_cnt) {//XmListGetSelectedPos(netcdf_listx_item, &pos_list, &pos_cnt)) {
        /*XtVaGetValues(netcdf_listx_item,
                      XmNselectedItemCount, &cnt,
                      XmNselectedItems, &s,
                      NULL);*/
        //cnt=pos_cnt;
        s=pos_list[0];
        cs = s;//XmStringCopy(*s);
        strcpy(cstr,netcdf_listx_item->text_entries[cs].toLocal8Bit().constData());
        if (strlen(cstr)) {//(cstr = GetStringSimple(cs))) {
            strcpy(xvar, cstr);
            //XtFree(cstr);
        }
        //XmStringFree(cs);
    } else {
        errmsg(tr("Need to select X, either variable name or INDEX").toLocal8Bit().constData());
        goto out1;
    }
    netcdf_listy_item->get_selection(&pos_cnt,&pos_list);
    if (pos_cnt) {//XmListGetSelectedPos(netcdf_listy_item, &pos_list, &pos_cnt)) {
        /*XtVaGetValues(netcdf_listy_item,
                      XmNselectedItemCount, &cnt,
                      XmNselectedItems, &s,
                      NULL);*/
        //cnt=pos_cnt;
        s=pos_list[0];
        cs = s;//XmStringCopy(*s);
        strcpy(cstr,netcdf_listy_item->text_entries[cs].toLocal8Bit());
        if (strlen(cstr)) {//(cstr = GetStringSimple(cs))) {
            strcpy(xvar, cstr);
            //XtFree(cstr);
        }
        //XmStringFree(cs);
    } else {
        errmsg(tr("Need to select Y").toLocal8Bit().constData());
        goto out1;
    }
    if (strcmp(xvar, "INDEX") == 0) {
        stufftext("X is the index of the Y variable\n");
    } else {
#ifdef HAVE_NETCDF
        if ((x_id = ncvarid(cdfid, xvar)) == -1) {
            char ebuf[256];
            sprintf(ebuf, "do_query(): %s %s%s",tr("No such variable").toLocal8Bit().constData(),xvar,tr(" for X").toLocal8Bit().constData());
            errmsg(ebuf);
            goto out1;
        }
        ncvarinq(cdfid, x_id, NULL, &xdatatype, &xndims, xdim, &xnatts);
        ncdiminq(cdfid, xdim[0], NULL, &nx);
#endif
        sprintf(buf, "X is %s, data type %s \t length [%ld]\n", xvar, getcdf_type(xdatatype), nx);
        stufftext(buf);
        sprintf(buf, "\t%d Attributes:\n", xnatts);
        stufftext(buf);
        for (i = 0; i < xnatts; i++) {
            atcharval[0] = 0;
#ifdef HAVE_NETCDF
            ncattname(cdfid, x_id, i, attname);
            ncattinq(cdfid, x_id, attname, &datatype, &atlen);
#endif
            switch (datatype) {
            case NC_CHAR:
#ifdef HAVE_NETCDF
                ncattget(cdfid, x_id, attname, (void *) atcharval);
#endif
                atcharval[atlen] = 0;
                sprintf(buf, "\t\t%s: %s\n", attname, atcharval);
                stufftext(buf);
                break;
            case NC_FLOAT:
#ifdef HAVE_NETCDF
                ncattget(cdfid, x_id, attname, (void *) &f);
#endif
                sprintf(buf, "\t\t%s: %f\n", attname, f);
                stufftext(buf);
                break;
            case NC_DOUBLE:
#ifdef HAVE_NETCDF
                ncattget(cdfid, x_id, attname, (void *) &d);
#endif
                sprintf(buf, "\t\t%s: %f\n", attname, d);
                stufftext(buf);
                break;
            default:
                break;
            }
        }
    }
#ifdef HAVE_NETCDF
    if ((y_id = ncvarid(cdfid, yvar)) == -1) {
        char ebuf[256];
        sprintf(ebuf, "do_query(): %s %s%s",tr("No such variable").toLocal8Bit().constData(),yvar,tr(" for Y").toLocal8Bit().constData());
        errmsg(ebuf);
        goto out1;
    }
    ncvarinq(cdfid, y_id, NULL, &ydatatype, &yndims, ydim, &ynatts);
    ncdiminq(cdfid, ydim[0], NULL, &ny);
#endif
    sprintf(buf, "Y is %s, data type %s \t length [%ld]\n", yvar, getcdf_type(ydatatype), ny);
    stufftext(buf);
    sprintf(buf, "\t%d Attributes:\n", ynatts);
    stufftext(buf);
    for (i = 0; i < ynatts; i++) {
        atcharval[0] = 0;
#ifdef HAVE_NETCDF
        ncattname(cdfid, y_id, i, attname);
        ncattinq(cdfid, y_id, attname, &datatype, &atlen);
#endif
        switch (datatype) {
        case NC_CHAR:
#ifdef HAVE_NETCDF
            ncattget(cdfid, y_id, attname, (void *) atcharval);
#endif
            atcharval[atlen] = 0;
            sprintf(buf, "\t\t%s: %s\n", attname, atcharval);
            stufftext(buf);
            break;
        case NC_FLOAT:
#ifdef HAVE_NETCDF
            ncattget(cdfid, y_id, attname, (void *) &f);
#endif
            sprintf(buf, "\t\t%s: %f\n", attname, f);
            stufftext(buf);
            break;
        case NC_DOUBLE:
#ifdef HAVE_NETCDF
            ncattget(cdfid, y_id, attname, (void *) &d);
#endif
            sprintf(buf, "\t\t%s: %f\n", attname, d);
            stufftext(buf);
            break;
        default:
            break;
        }
    }

out1:;
#ifdef HAVE_NETCDF
    ncclose(cdfid);
#endif
    stufftext("\n");
    delete[] pos_list;
    //delete s;
    unset_wait_cursor();
}

/*binary format input*/
inputLine::inputLine(int t,QWidget * parent):QWidget(parent)
{
    char dummy[256];
    type=t;//type of input line: input from header(0) or input from data(1)
    if (type)
    {
    layout=new QHBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    }
    lblOffset=new QLabel(QString("0:"),this);
    cmdNew=new QPushButton(QString("-"),this);
    cmdNew->setToolTip(tr("Remove this import token."));
        if (type)
        {
        //lblOffset->setVisible(false);
        cmdNew->setVisible(false);
        }
    spnSize=new QSpinBox(this);
    spnSize->setMinimum(0);
    spnSize->setMaximum(10000);
    cmbFormat=new QComboBox(this);
    //Fill in formats
    for (int i=0;i<NUMBER_OF_COLUMN_FORMATS;i++)
    {
        if (i==0 || i==COLUMN_STRING)
            sprintf(dummy,"%s",binaryImportFormatName[i]);
        else
            sprintf(dummy,"%s (%d)",binaryImportFormatName[i],binaryImportFormat[i].size);
        cmbFormat->addItem(QString(dummy));
    }
    connect(cmbFormat,SIGNAL(currentIndexChanged(int)),SLOT(formatChanged(int)));
    cmbImportAs=new QComboBox(this);
    //Fill in targets
    int index=0;
    for (int i=0;i<NUMBER_OF_IMPORT_DESTINATIONS;i++)
    {
        if (ImportDestinationType[i]&(type+1))
        {
            cmbImportAs->addItem(QString(ImportDestinationName[i]));
            datas[index++]=i;
        }
    }
    if (type)
    {
    layout->addWidget(lblOffset);
    layout->addWidget(cmbFormat);
    layout->addWidget(spnSize);
    layout->addWidget(cmbImportAs);
    layout->addWidget(cmdNew);
    setLayout(layout);
    }
    spnSize->setEnabled(false);
    cmbFormat->setCurrentIndex(10);//set Standard-Format to double
}

inputLine::~inputLine()
{
    if (type)
    delete layout;
    delete lblOffset;
    delete cmdNew;
    delete spnSize;
    delete cmbFormat;
    delete cmbImportAs;
}

int inputLine::getSize(void)
{
    if (cmbFormat->currentIndex()==0 || cmbFormat->currentIndex()==COLUMN_STRING)
        return spnSize->value();
    else
        return binaryImportFormat[cmbFormat->currentIndex()].size;
}

int inputLine::getType(void)
{
    return cmbFormat->currentIndex();
}

int inputLine::getTarget(void)
{
    return datas[cmbImportAs->currentIndex()];
}

void inputLine::setSize(int s)
{
spnSize->setValue(s);
}

void inputLine::setType(int t)
{
cmbFormat->setCurrentIndex(t);
}

void inputLine::setTarget(int t)
{
int ret=-1;
for (int i=0;i<NUMBER_OF_IMPORT_DESTINATIONS;i++)
{
    if (datas[i]==t)
    {
    ret=i;
    break;
    }
}
if (ret>=0) cmbImportAs->setCurrentIndex(ret);
}

void inputLine::formatChanged(int i)
{
    spnSize->setEnabled(!((bool)i));
    if (i==COLUMN_STRING) spnSize->setEnabled(true);
    cmbImportAs->setEnabled((bool)i);
/*if (i==0)
{
}
else
{
}
*/
}

manualHeaderData::manualHeaderData(QWidget * parent):QWidget(parent)
{
    layout=new QGridLayout();
    layout->setSpacing(STD_SPACING);
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    selNrOfEntries=new stdIntSelector(this,tr("Number of Tokens:"),0,64);
    selNrOfEntries->setValue(0);
    connect(selNrOfEntries,SIGNAL(currentValueChanged(int)),SLOT(changeNumberOfEntries(int)));
    /*
    selTokenType=new StdSelector(this,tr("Token:"),);
    ledTokenValue=new stdLineEdit(this,tr("Value="));
    */
    layout->addWidget(selNrOfEntries,0,0,1,3);
    selTokenType=NULL;
    ledTokenValue=NULL;
    selTargetChannel=NULL;
    tokens=0;
    setLayout(layout);
    setMinimumSize(500,30*(1+tokens));
}

void manualHeaderData::changeNumberOfEntries(int nr)
{
StdSelector ** n_selTokenType=NULL;
stdLineEdit ** n_ledTokenValue=NULL;
StdSelector ** n_selTargetChannel=NULL;
//qDebug() << "changeNumberOfEntries: nr=" << nr << "tokens=" << tokens;
    if (nr<tokens)//remove something
    {
        if (nr>0)
        {
        n_selTokenType=new StdSelector*[nr];
        n_ledTokenValue=new stdLineEdit*[nr];
        n_selTargetChannel=new StdSelector*[nr];
            for (int i=0;i<nr;i++)
            {
            n_selTokenType[i]=selTokenType[i];
            n_ledTokenValue[i]=ledTokenValue[i];
            n_selTargetChannel[i]=selTargetChannel[i];
            }
        }
        for (int i=nr;i<tokens;i++)
        {
        layout->removeWidget(selTokenType[i]);
        layout->removeWidget(ledTokenValue[i]);
        layout->removeWidget(selTargetChannel[i]);
        delete selTokenType[i];
        delete ledTokenValue[i];
        delete selTargetChannel[i];
        }
        delete[] selTokenType;
        selTokenType=n_selTokenType;
        delete[] ledTokenValue;
        ledTokenValue=n_ledTokenValue;
        delete[] selTargetChannel;
        selTargetChannel=n_selTargetChannel;
        tokens=nr;
    }
    else//add tokens
    {
        n_selTokenType=new StdSelector*[nr];
        n_ledTokenValue=new stdLineEdit*[nr];
        n_selTargetChannel=new StdSelector*[nr];
        for (int i=0;i<tokens;i++)
        {
        n_selTokenType[i]=selTokenType[i];
        n_ledTokenValue[i]=ledTokenValue[i];
        n_selTargetChannel[i]=selTargetChannel[i];
        }
        delete[] selTokenType;
        selTokenType=n_selTokenType;
        delete[] ledTokenValue;
        ledTokenValue=n_ledTokenValue;
        delete[] selTargetChannel;
        selTargetChannel=n_selTargetChannel;
        QString * impdest=new QString[NUMBER_OF_IMPORT_DESTINATIONS];
        int * datas=new int[NUMBER_OF_IMPORT_DESTINATIONS];
        int nr_impdest=0;
        int * channel_nrs=new int[MAX_BIN_IMPORT_CHANNELS+1];
        QString * impchannels=new QString[MAX_BIN_IMPORT_CHANNELS+1];
        impchannels[0]=tr("All");
        channel_nrs[0]=-1;
        for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
        {
        channel_nrs[i+1]=i;
        impchannels[i+1]=QString::number(i);
        }
        for (int i=0;i<NUMBER_OF_IMPORT_DESTINATIONS;i++)
        {
        if (ImportDestination[i]==IMPORT_TO_NUMBER_OF_DATA || ImportDestination[i]==IMPORT_TO_NUMBER_OF_CHANNELS || ImportDestination[i]==IMPORT_TO_DATA_SIZE || ImportDestination[i]==IMPORT_TO_DATA_SIZE_BIT || ImportDestination[i]==IMPORT_TO_WHOLE_DATA_BLOCK_SIZE || ImportDestination[i]==IMPORT_TO_SINGLE_DATA_BLOCK_SIZE) continue;
            if (ImportDestinationType[i]&(1))
            {
            impdest[nr_impdest]=ImportDestinationName[i];
            datas[nr_impdest++]=ImportDestination[i];
            }
        }
        for (int i=tokens;i<nr;i++)
        {
        selTokenType[i]=new StdSelector(this,tr("Token:"),nr_impdest,impdest);
        selTokenType[i]->setValues(datas);
        ledTokenValue[i]=new stdLineEdit(this,tr("Value="));
        selTargetChannel[i]=new StdSelector(this,tr("Channel:"),MAX_BIN_IMPORT_CHANNELS+1,impchannels);
        selTargetChannel[i]->setValues(channel_nrs);
        layout->addWidget(selTokenType[i],i+1,0);
        layout->addWidget(ledTokenValue[i],i+1,1);
        layout->addWidget(selTargetChannel[i],i+1,2);
        }
        delete[] impdest;
        delete[] datas;
        delete[] channel_nrs;
        delete[] impchannels;
        tokens=nr;
    }
    setMinimumSize(500,30*(1+tokens));
}

void manualHeaderData::readDataToScheme(struct importSettings & imp_schema)
{
int cur_type,channel_target;
double cur_val;
QString cur_text;

imp_schema.nr_of_header_values=0;
prepare_imp_settings_for_header_import(imp_schema);
imp_schema.valid_status=1;
imp_schema.contains_trigger=false;

    for (int i=0;i<tokens;i++)
    {
    cur_type=selTokenType[i]->currentValue();
        if (cur_type==IMPORT_TO_NONE) continue;
    channel_target=selTargetChannel[i]->currentValue();
    cur_val=ledTokenValue[i]->getDoubleValue();
    cur_text=ledTokenValue[i]->text();
        switch (cur_type)
        {
        case IMPORT_TO_X0:
            imp_schema.x0set=true;
            imp_schema.x0=cur_val;
        break;
        case IMPORT_TO_DELTAX:
            imp_schema.deltaxset=true;
            imp_schema.deltax=cur_val;
        break;
        case IMPORT_TO_DATA_SAMPLING_RATE:
            imp_schema.fset=true;
            imp_schema.f=cur_val;
        break;
        case IMPORT_TO_TITLE:
            if (imp_schema.title!=NULL) delete[] imp_schema.title;
            imp_schema.title=new char[2+cur_text.toLocal8Bit().length()];
            strcpy(imp_schema.title,cur_text.toLocal8Bit().constData());
        break;
        case IMPORT_TO_SUBTITLE:
            if (imp_schema.subtitle!=NULL) delete[] imp_schema.subtitle;
            imp_schema.subtitle=new char[2+cur_text.toLocal8Bit().length()];
            strcpy(imp_schema.subtitle,cur_text.toLocal8Bit().constData());
        break;
        case IMPORT_TO_XTITLE:
            if (imp_schema.x_title!=NULL) delete[] imp_schema.x_title;
            imp_schema.x_title=new char[2+cur_text.toLocal8Bit().length()];
            strcpy(imp_schema.x_title,cur_text.toLocal8Bit().constData());
        break;
        case IMPORT_TO_YTITLE:
            if (imp_schema.y_title!=NULL) delete[] imp_schema.y_title;
            imp_schema.y_title=new char[2+cur_text.toLocal8Bit().length()];
            strcpy(imp_schema.y_title,cur_text.toLocal8Bit().constData());
        break;
        case IMPORT_TO_SET_LEGEND:
            if (channel_target==-1)//All
            {
                for (int j=0;j<MAX_BIN_IMPORT_CHANNELS;j++)
                {
                if (imp_schema.set_title[j]!=NULL) delete[] imp_schema.set_title[j];
                imp_schema.set_title[j]=new char[2+cur_text.toLocal8Bit().length()];
                strcpy(imp_schema.set_title[j],cur_text.toLocal8Bit().constData());
                }
            }
            else
            {
                if (imp_schema.set_title[channel_target]!=NULL) delete[] imp_schema.set_title[channel_target];
                imp_schema.set_title[channel_target]=new char[2+cur_text.toLocal8Bit().length()];
                strcpy(imp_schema.set_title[channel_target],cur_text.toLocal8Bit().constData());
            }
        break;
        case IMPORT_TO_DATA_START_OFFSET:
            imp_schema.whole_size=int(cur_val);
        break;
        case IMPORT_TO_XFACTOR:
        case IMPORT_TO_YFACTOR:
        case IMPORT_TO_Y1FACTOR:
        case IMPORT_TO_Y2FACTOR:
        case IMPORT_TO_Y3FACTOR:
        case IMPORT_TO_Y4FACTOR:
            if (channel_target==-1)//all --> use the general factors
            imp_schema.factors[cur_type-IMPORT_TO_XFACTOR]*=cur_val;
            else//just one channel
            imp_schema.channel_factors[channel_target]*=cur_val;
        break;
        case IMPORT_TO_X_OFFSET:
        case IMPORT_TO_Y_OFFSET:
        case IMPORT_TO_Y1_OFFSET:
        case IMPORT_TO_Y2_OFFSET:
        case IMPORT_TO_Y3_OFFSET:
        case IMPORT_TO_Y4_OFFSET:
            if (channel_target==-1)//all --> use the general offsets
            imp_schema.offsets[cur_type-IMPORT_TO_X_OFFSET]+=cur_val;
            else//just one channel
            imp_schema.channel_offsets[channel_target]+=cur_val;
        break;

        }
    }
}

void manualHeaderData::displayDataFromScheme(struct importSettings imp_schema)
{
int counter=0;

if (imp_schema.x0set==true) counter++;
if (imp_schema.deltaxset==true) counter++;
if (imp_schema.fset==true) counter++;
if (imp_schema.whole_size>0) counter++;
if (imp_schema.title!=NULL) counter++;
if (imp_schema.subtitle!=NULL) counter++;
if (imp_schema.x_title!=NULL) counter++;
if (imp_schema.y_title!=NULL) counter++;
for (int i=0;i<7;i++)
{
    if (imp_schema.factors[i]!=1.0) counter++;
    if (imp_schema.offsets[i]!=0.0) counter++;
}
for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
{
    if (imp_schema.channel_factors[i]!=1.0) counter++;
    if (imp_schema.channel_offsets[i]!=0.0) counter++;
    if (imp_schema.set_title[i]!=NULL) counter++;
}

selNrOfEntries->setValue(counter);
qApp->processEvents();

counter=0;

if (imp_schema.x0set==true)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_X0);
ledTokenValue[counter]->setDoubleValue(imp_schema.x0);
selTargetChannel[counter++]->setCurrentValue(-1);
}
if (imp_schema.deltaxset==true)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_DELTAX);
ledTokenValue[counter]->setDoubleValue(imp_schema.deltax);
selTargetChannel[counter++]->setCurrentValue(-1);
}
if (imp_schema.fset==true)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_DATA_SAMPLING_RATE);
ledTokenValue[counter]->setDoubleValue(imp_schema.f);
selTargetChannel[counter++]->setCurrentValue(-1);
}
if (imp_schema.whole_size>0)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_DATA_START_OFFSET);
ledTokenValue[counter]->setDoubleValue(imp_schema.whole_size);
selTargetChannel[counter++]->setCurrentValue(-1);
}
if (imp_schema.title!=NULL)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_TITLE);
ledTokenValue[counter]->setText(imp_schema.title);
selTargetChannel[counter++]->setCurrentValue(-1);
}
if (imp_schema.subtitle!=NULL)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_SUBTITLE);
ledTokenValue[counter]->setText(imp_schema.subtitle);
selTargetChannel[counter++]->setCurrentValue(-1);
}
if (imp_schema.x_title!=NULL)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_XTITLE);
ledTokenValue[counter]->setText(imp_schema.x_title);
selTargetChannel[counter++]->setCurrentValue(-1);
}
if (imp_schema.y_title!=NULL)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_YTITLE);
ledTokenValue[counter]->setText(imp_schema.y_title);
selTargetChannel[counter++]->setCurrentValue(-1);
}
for (int i=0;i<7;i++)
{
    if (imp_schema.offsets[i]!=0.0)
    {
    selTokenType[counter]->setCurrentValue(i+IMPORT_TO_XFACTOR);
    ledTokenValue[counter]->setDoubleValue(imp_schema.offsets[i]);
    selTargetChannel[counter++]->setCurrentValue(-1);
    }
    if (imp_schema.factors[i]!=1.0)
    {
    selTokenType[counter]->setCurrentValue(i+IMPORT_TO_X_OFFSET);
    ledTokenValue[counter]->setDoubleValue(imp_schema.factors[i]);
    selTargetChannel[counter++]->setCurrentValue(-1);
    }
}
for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
{
    if (imp_schema.channel_offsets[i]!=0.0)
    {
    selTokenType[counter]->setCurrentValue(IMPORT_TO_Y_OFFSET);
    ledTokenValue[counter]->setDoubleValue(imp_schema.channel_offsets[i]);
    selTargetChannel[counter++]->setCurrentValue(i);
    }
    if (imp_schema.channel_factors[i]!=1.0)
    {
    selTokenType[counter]->setCurrentValue(IMPORT_TO_YFACTOR);
    ledTokenValue[counter]->setDoubleValue(imp_schema.channel_factors[i]);
    selTargetChannel[counter++]->setCurrentValue(i);
    }
    if (imp_schema.set_title[i]!=NULL)
    {
    selTokenType[counter]->setCurrentValue(IMPORT_TO_SET_LEGEND);
    ledTokenValue[counter]->setText(imp_schema.set_title[i]);
    selTargetChannel[counter++]->setCurrentValue(i);
    }
}

}

inputIniData::inputIniData(QWidget * parent):QWidget(parent)
{
layout=new QGridLayout();
//layout->setMargin(STD_MARGIN*2);
layout->setContentsMargins(2*STD_MARGIN,2*STD_MARGIN,2*STD_MARGIN,2*STD_MARGIN);
layout->setSpacing(STD_SPACING*2);
titles=new QLabel*[4];
titles[0]=new QLabel(tr("Import key"));
titles[1]=new QLabel(tr("Value"));
titles[2]=new QLabel(tr("Channel"));
titles[3]=new QLabel(tr("Import as"));
QFont stfont=titles[0]->font();
stfont.setBold(true);
        for (int i=0;i<4;i++)
        {
        titles[i]->setFont(stfont);
        layout->addWidget(titles[i],0,i);
        }
    lbl_imp_key=NULL;
    lbl_imp_value=NULL;
    cmbChannel=NULL;
    cmbImportTo=NULL;
    lines=0;
    multCounters=new multiIniCountPreproc(this,0);
    multCounters->setVisible(false);
    multPreprocessors=new multiIniCountPreproc(this,1);
    multPreprocessors->setVisible(false);
    //connect(multCounters,SIGNAL(nrOfCountersChanged(void)),this,SLOT(redisplay(void)));
    //connect(multPreprocessors,SIGNAL(nrOfCountersChanged(void)),this,SLOT(redisplay(void)));
setLayout(layout);
}

void inputIniData::clearData(void)
{
    for (int i=0;i<lines;i++)
    {
    delete lbl_imp_key[i];
    delete lbl_imp_value[i];
    delete cmbChannel[i];
    delete cmbImportTo[i];
    }
    if (lbl_imp_key!=NULL) delete[] lbl_imp_key;
    if (lbl_imp_value!=NULL) delete[] lbl_imp_value;
    if (cmbChannel!=NULL) delete[] cmbChannel;
    if (cmbImportTo!=NULL)delete[] cmbImportTo;
    lbl_imp_key=NULL;
    lbl_imp_value=NULL;
    cmbChannel=NULL;
    cmbImportTo=NULL;
    lines=0;
    layout->removeWidget(multCounters);
    layout->removeWidget(multPreprocessors);
    //multCounters->clearCounters();
}

void inputIniData::initData(importSettings & imp_set)
{
clearData();
lines=imp_set.keys.length();
multPreprocessors->setImportSetting(&imp_set);
multCounters->setImportSetting(&imp_set);

if (lines>0)
{
lbl_imp_key=new QLabel*[lines];
lbl_imp_value=new QLabel*[lines];
cmbChannel=new QComboBox*[lines];
cmbImportTo=new QComboBox*[lines];
    for (int i=0;i<lines;i++)
    {
    lbl_imp_key[i]=new QLabel(imp_set.keys.at(i),this);
    lbl_imp_value[i]=new QLabel(imp_set.vals.at(i),this);
    cmbChannel[i]=new QComboBox(this);
    cmbImportTo[i]=new QComboBox(this);
    layout->addWidget(lbl_imp_key[i],1+i,0);
    layout->addWidget(lbl_imp_value[i],1+i,1);
    layout->addWidget(cmbChannel[i],1+i,2);
    cmbChannel[i]->addItem(tr("All"));
        for (int j=0;j<MAX_BIN_IMPORT_CHANNELS;j++)
        {
        cmbChannel[i]->addItem(QString::number(j));
        }
    layout->addWidget(cmbImportTo[i],1+i,3);
    }
//qDebug() << "import-rows=" << layout->rowCount() << "lines=" << lines;
    int hi=multCounters->nr_of_lines();
//qDebug() << "adding multCounter at " << lines+1 << "|" << 0;
multCounters->setVisible(true);
layout->addWidget(multCounters,lines+1,0,hi,4);
//qDebug() << "indexOfMultCounter=" << layout->indexOf(multCounters);
int hi2=multPreprocessors->nr_of_lines();
/*qDebug() << "hi=" << hi << "hi2=" << hi2;
qDebug() << "rows+multCounter=" << layout->rowCount();
qDebug() << "adding multPreprocessors at " << lines+1+hi << "|" << 0;*/
multPreprocessors->setVisible(true);
//layout->addWidget(multPreprocessors,lines+1+hi,0,hi2,4);
//qDebug() << "indexOfMultPreprocessors=" << layout->indexOf(multPreprocessors) << "multPreprocessors=" << multPreprocessors;
//qDebug() << "rows=" << layout->rowCount();
datas.clear();
for (int i=0;i<NUMBER_OF_IMPORT_DESTINATIONS;i++)
{
    if (ImportDestinationType[i]&(1))
    {
        for (int j=0;j<lines;j++)
        cmbImportTo[j]->addItem(QString(ImportDestinationName[i]));
        datas << ImportDestination[i];
        //datas[index++]=i;
    }
}
QList<int> index_values,sav_targets;
index_values.clear();
for (int i=0;i<imp_set.counterTargets.length();i++)
{
index_values << datas.indexOf(imp_set.counterTargets.at(i));
}
//qDebug() << "A indexOfMultPreprocessors=" << layout->indexOf(multPreprocessors) << "multPreprocessors=" << multPreprocessors;

sav_targets=imp_set.counterTargets;
imp_set.counterTargets=index_values;
//qDebug() << "B indexOfMultPreprocessors=" << layout->indexOf(multPreprocessors) << "multPreprocessors=" << multPreprocessors;

multCounters->setAllCounters(imp_set);
//qDebug() << "C indexOfMultPreprocessors=" << layout->indexOf(multPreprocessors) << "multPreprocessors=" << multPreprocessors;
//qDebug() << "rows=" << layout->rowCount();
multPreprocessors->setAllPreprocessors(imp_set);
layout->addWidget(multPreprocessors,lines+1+hi,0,hi2,4);
//qDebug() << "D indexOfMultPreprocessors=" << layout->indexOf(multPreprocessors) << "multPreprocessors=" << multPreprocessors;

/*qDebug() << "Counter-lines=" << multCounters->nr_of_lines();
qDebug() << "Preprocessor-lines=" << multPreprocessors->nr_of_lines();
qDebug() << "rows=" << layout->rowCount();*/

//int countIndex=layout->indexOf(multCounters),prepIndex=layout->indexOf(multPreprocessors);

//qDebug() << "countIndex=" << countIndex << "prepIndex=" << prepIndex;
//qDebug() << "E indexOfMultPreprocessors=" << layout->indexOf(multPreprocessors) << "multPreprocessors=" << multPreprocessors;
//int countR,countC,countRS,countCS;
//layout->getItemPosition(countIndex,&countR,&countC,&countRS,&countCS);
//qDebug() << "counter at:" << countR << "|" << countC;
//countR=countC=countRS=countCS=-1;
//layout->getItemPosition(prepIndex,&countR,&countC,&countRS,&countCS);
//qDebug() << "preproc at:" << countR << "|" << countC;

imp_set.counterTargets=sav_targets;
//set the values
int index;
for (int i=0;i<lines;i++)
{
cmbChannel[i]->setCurrentIndex(1+imp_set.import_channel_dest.at(i));
index=datas.indexOf(imp_set.import_dest.at(i));
//cout << "imp_set.import_dest.at(i)=" << imp_set.import_dest.at(i) << " --> Position=" << index << endl;
if (index>=0)
cmbImportTo[i]->setCurrentIndex(index);
else
cmbImportTo[i]->setCurrentIndex(0);
}

}//lines > 0
else//without lines everything makes no sense here
{
multCounters->setVisible(false);
multPreprocessors->setVisible(false);
}
redisplay();
}

void inputIniData::redisplay(void)
{
//qDebug() << "redisplay";
this->layout->update();
this->adjustSize();
}

void inputIniData::setData(struct importSettings & imp_set)
{
//read settings and save them into imp_set
    imp_set.import_channel_dest.clear();
    imp_set.import_dest.clear();
    imp_set.keys.clear();
    imp_set.vals.clear();
//qDebug() << "Ini-SetData: lines=" << lines << endl;
        for (int i=0;i<lines;i++)
        {
        imp_set.import_channel_dest << cmbChannel[i]->currentIndex()-1;
        //cout << "channel_dest=" << imp_set.import_channel_dest.at(i) << endl;
        imp_set.import_dest << datas.at(cmbImportTo[i]->currentIndex());
        imp_set.keys << lbl_imp_key[i]->text();
        imp_set.vals << cmbImportTo[i]->currentText();
        }
    if (imp_set.token_target!=NULL) delete[] imp_set.token_target;
    imp_set.token_target=new int[imp_set.import_dest.length()];
        for (int i=0;i<imp_set.import_dest.length();i++)
        {
        imp_set.token_target[i]=imp_set.import_dest.at(i);
        //cout << i << ": token target=" << imp_set.token_target[i] << endl;
        }
    /*for (int i=0;i<imp_set.keys.length();i++)
    {
    cout << i << ": key=" << imp_set.keys.at(i).toLocal8Bit().constData() << endl;
    }*/

    /*for (int i=0;i<imp_set.keys.length();i++)
    {
    imp_set.import_channel_dest.at(i)
    imp_set.keys.at(i).toLocal8Bit().constData()
    ImportDestinationName[imp_set.token_target[i]]
    }*/
    setCounterData(imp_set);
}

void inputIniData::setCounterData(struct importSettings & imp_set)
{
//qDebug() << "Counters:" << multCounters->nr_of_counters;
    multCounters->get_all_counter_settings(imp_set);
//qDebug() << "Preprocessors:" << multPreprocessors->nr_of_counters;
    multPreprocessors->get_all_preprocessor_settings(imp_set);
    for (int i=0;i<imp_set.counterTargets.length();i++)
    {
    //qDebug() << "a) counter" << i << "target=" << imp_set.counterTargets.at(i);
    imp_set.counterTargets.replace(i,datas.at(imp_set.counterTargets.at(i)));
    //qDebug() << "b) counter" << i << "target=" << imp_set.counterTargets.at(i);
    }
    /*for (int i=0;i<imp_set.preprocessingTarget.length();i++)
    {
    qDebug() << "a) preprocessor" << i << "target=" << imp_set.preprocessingTarget.at(i);
    imp_set.preprocessingTarget.replace(i,datas.at(imp_set.preprocessingTarget.at(i)));
    qDebug() << "b) preprocessor" << i << "target=" << imp_set.preprocessingTarget.at(i);
    }*/
/*
qDebug() << "Read Counter-Values:" << imp_set.nr_of_counters;
for (int i=0;i<imp_set.nr_of_counters;i++)
{
qDebug() << i << "Counter";
qDebug() << "Type=" << imp_set.counterTypes.at(i);
qDebug() << "Target=" << imp_set.counterTargets.at(i);
qDebug() << "TargetSet=" << imp_set.counterSets.at(i);
qDebug() << "Section=" << imp_set.counterSections.at(i);
qDebug() << "Text=" << imp_set.counterText.at(i);
}
qDebug() << "Read Preprocessor-Values:" << imp_set.nr_of_preprocessors;
for (int i=0;i<imp_set.nr_of_preprocessors;i++)
{
qDebug() << i << "Preprocessor";
qDebug() << "Type=" << imp_set.preprocessingType.at(i);
qDebug() << "TargetSet=" << imp_set.preprocessingSet.at(i);
qDebug() << "Target=" << imp_set.preprocessingTarget.at(i);
qDebug() << "Key=" << imp_set.preprocessingKey.at(i);
qDebug() << "CharA=" << imp_set.preprocessingCharA.at(i);
qDebug() << "CharB=" << imp_set.preprocessingCharB.at(i);
}*/
}

inputIniPreprocessing::inputIniPreprocessing(QWidget * parent):QWidget(parent)
{
layout=new QHBoxLayout(this);
//layout->setMargin(0);
layout->setContentsMargins(0,0,0,0);
layout->setSpacing(STD_SPACING);

int nr=6;
QString * entr=new QString[64];
int * n_vals=new int[64];
entr[0]=tr("After first A");
entr[1]=tr("After last A");
entr[2]=tr("Before first A");
entr[3]=tr("Before last A");
entr[4]=tr("Between first A/B");
entr[5]=tr("Between last A/B");
n_vals[0]=INI_PREPROCESSING_AFTER_FIRST;
n_vals[1]=INI_PREPROCESSING_AFTER_LAST;
n_vals[2]=INI_PREPROCESSING_BEFORE_FIRST;
n_vals[3]=INI_PREPROCESSING_BEFORE_LAST;
n_vals[4]=INI_PREPROCESSING_BETWEEN_FIRST;
n_vals[5]=INI_PREPROCESSING_BETWEEN_LAST;
selType=new StdSelector(this,tr("Type:"),nr,entr);
selType->setNewEntries(nr,entr,n_vals);

lenCharA=new stdLineEdit(this,tr("A:"));
lenCharA->lenText->setText(QString(","));
lenCharA->setToolTip(tr("Search character"));
lenCharB=new stdLineEdit(this,tr("B:"));
lenCharB->lenText->setText(QString(","));
lenCharB->setToolTip(tr("End character"));
lenCharB->hide();
spnMultA=new QSpinBox(this);
spnMultA->setRange(1,200);
spnMultA->setValue(1);
spnMultA->setToolTip(tr("Multiple of Char A\ne.g. a value of 3 means 'third occurance of Char A'\nif type=first it is counted from left to right, if type=last it is counted from right to left"));
spnMultB=new QSpinBox(this);
spnMultB->setRange(1,200);
spnMultB->setToolTip(tr("Multiple of Char B\ne.g. a value of 3 means 'third occurance of Char B after Char A'"));
spnMultB->setValue(1);
spnMultB->hide();

nr=2;
entr[0]=tr("Key A");
entr[1]=tr("Key B");
selKey=new StdSelector(this,tr("Key:"),nr,entr);

nr=2;
entr[0]=tr("None");
entr[1]=tr("Column count");//just dummies
selTarget=new StdSelector(this,QString("-->"),nr,entr);
selTarget->lblText->hide();
selTarget->cmbSelect->clear();
nr=0;
for (int i=0;i<NUMBER_OF_IMPORT_DESTINATIONS;i++)
{

    if (ImportDestinationType[i]&(1))
    {
    entr[nr]=QString(ImportDestinationName[i]);
    n_vals[nr++]=i;
    //selTarget->cmbSelect->addItem(QString(ImportDestinationName[i]));
    }
}
selTarget->setNewEntries(nr,entr,n_vals);
selTarget->setToolTip(tr("Where to put the counting-result"));

nr=1+MAX_BIN_IMPORT_CHANNELS;
entr[0]=tr("All");
n_vals[0]=-1;
for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
{
entr[i+1]=QString::number(i);
n_vals[i+1]=i;
}
selSet=new StdSelector(this,QString("-->#-->"),nr,entr);
selSet->setNewEntries(nr,entr,n_vals);
selSet->setToolTip(tr("Target-Set"));

layout->addWidget(selType);
layout->addWidget(lenCharA);
layout->addWidget(spnMultA);
layout->addWidget(lenCharB);
layout->addWidget(spnMultB);
layout->addWidget(selKey);
layout->addWidget(selSet);
layout->addWidget(selTarget);
connect(selType,SIGNAL(currentIndexChanged(int)),this,SLOT(typeChanged(int)));
connect(selKey,SIGNAL(currentIndexChanged(int)),this,SLOT(valueCanged(int)));
connect(lenCharA,SIGNAL(changed()),this,SLOT(generatePreview()));
connect(lenCharB,SIGNAL(changed()),this,SLOT(generatePreview()));
connect(spnMultA,SIGNAL(valueChanged(int)),this,SLOT(valueCanged(int)));
connect(spnMultB,SIGNAL(valueChanged(int)),this,SLOT(valueCanged(int)));
setLayout(layout);
delete[] entr;
delete[] n_vals;
}

void inputIniPreprocessing::init(QStringList & keys)
{
selKey->blockSignals(true);
selKey->cmbSelect->clear();
selKey->cmbSelect->addItems(keys);
selKey->blockSignals(false);
}

void inputIniPreprocessing::typeChanged(int t)
{
    switch (t)
    {
    case INI_PREPROCESSING_AFTER_FIRST:
    case INI_PREPROCESSING_AFTER_LAST:
    case INI_PREPROCESSING_BEFORE_FIRST:
    case INI_PREPROCESSING_BEFORE_LAST:
    lenCharB->hide();
    spnMultB->hide();
    break;
    case INI_PREPROCESSING_BETWEEN_FIRST:
    case INI_PREPROCESSING_BETWEEN_LAST:
    lenCharB->show();
    spnMultB->show();
    break;
    }
generatePreview();
}

void inputIniPreprocessing::getPostprocessingSettings(int & Type, QString & key, QString & A, QString & B, int &multA, int &multB, int & set, int & target)
{
Type=selType->currentValue();
key=selKey->currentText();
A=lenCharA->text();
B=lenCharB->text();
set=selSet->currentValue();
target=selTarget->currentValue();
multA=spnMultA->value();
multB=spnMultB->value();
}

void inputIniPreprocessing::textChanged(QString s)
{
    (void)s;
generatePreview();
}

void inputIniPreprocessing::valueCanged(int t)
{
    (void)t;
generatePreview();
}

void inputIniPreprocessing::generatePreview(void)
{
int type,set,target,index,multA,multB;
QString A,B,key,probe;
double result;
getPostprocessingSettings(type,key,A,B,multA,multB,set,target);

index=imp_set->keys.indexOf(key);
if (index<0 || index>=imp_set->vals.length())
{
qDebug() << "Key" << key << "not found!?";
return;
}
probe=imp_set->vals.at(index);
result=processString(probe,type,A,B,multA,multB,key);
//qDebug() << "Generating preview";
selSet->lblText->setText(QString("-->")+key+QString("(")+QString::number(result)+QString(")-->"));

}

inputIniCounter::inputIniCounter(QWidget * parent):QWidget(parent)
{
layout=new QHBoxLayout(this);
//layout->setMargin(0);
layout->setContentsMargins(0,0,0,0);
layout->setSpacing(STD_SPACING);
int nr=2;
QString * entr=new QString[64];
int * n_vals=new int[64];
entr[0]=tr("Nr. of entries");
entr[1]=tr("specific entries");
selType=new StdSelector(this,QString("Count:"),nr,entr);
selType->setToolTip(tr("What is to be counted: either the amount of entries in a section of the ini-file\nor all entries that contain specific text"));
lenText=new stdLineEdit(this,tr("Text:"));
lenText->setToolTip(tr("Enter the specific text that an entry must contain to be counted.\nIf you need more than one text segment separate them with '*' (e.g. 'Col*Count' looks for 'Col' and 'Count' in an entry; 'ColumnCount' or 'Count of Columns' would be found, 'Count' alone would not be found).\nThe entries do not have to match exactely, but must contain every text segment mentioned here."));
lenText->setEnabled(false);
entr[0]=tr("None");
entr[1]=tr("Column count");
selTarget=new StdSelector(this,QString("-->"),nr,entr);
selTarget->lblText->hide();
selTarget->cmbSelect->clear();
for (int i=0;i<NUMBER_OF_IMPORT_DESTINATIONS;i++)
{
    if (ImportDestinationType[i]&(1))
    {
    selTarget->cmbSelect->addItem(QString(ImportDestinationName[i]));
    }
}
selTarget->setToolTip(tr("Where to put the counting-result"));
entr[0]=tr("All");
entr[1]=tr("General");
selSection=new StdSelector(this,tr("Section:"),nr,entr);
selSection->setToolTip(tr("In which section of the ini-file to count entries"));
nr=1+MAX_BIN_IMPORT_CHANNELS;
entr[0]=tr("All");
n_vals[0]=-1;
for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
{
entr[i+1]=QString::number(i);
n_vals[i+1]=i;
}
selSet=new StdSelector(this,QString("-->#-->"),nr,entr);
selSet->setNewEntries(nr,entr,n_vals);

selSet->setToolTip(tr("Target-Set"));
layout->addWidget(selType);
layout->addWidget(selSection);
layout->addWidget(lenText);
layout->addWidget(selSet);
layout->addWidget(selTarget);
connect(selType,SIGNAL(currentIndexChanged(int)),this,SLOT(typeChanged(int)));
connect(selSection,SIGNAL(currentIndexChanged(int)),this,SLOT(sourceChanged(int)));
connect(lenText,SIGNAL(changed(void)),this,SLOT(generatePreview(void)));
setLayout(layout);
delete[] entr;
delete[] n_vals;
}

void inputIniCounter::init(QStringList & sections)
{
    selSection->cmbSelect->blockSignals(true);
selSection->cmbSelect->clear();
selSection->cmbSelect->addItem(tr("All"));
selSection->cmbSelect->addItems(sections);
    selSection->cmbSelect->blockSignals(false);
}

void inputIniCounter::typeChanged(int t)
{
(void)t;
    if (selType->currentIndex()==0)//all entries
    {
    lenText->setEnabled(false);
    }
    else//specific entries
    {
    lenText->setEnabled(true);
    }
generatePreview();
}

void inputIniCounter::getSettings(int & type, QString & section, QString & text, int & target, int & set)
{
type=selType->currentIndex();
if (selSection->currentIndex()==0) section=QString("");//for the "All"-Entry we set an empty section!!
else section=selSection->currentText();
text=lenText->text();
target=selTarget->currentIndex();
set=selSet->currentValue();
}

void inputIniCounter::sourceChanged(int t)
{
    (void)t;
    generatePreview();
}

void inputIniCounter::sourceTextChanged(QString & s)
{
    (void)s;
    generatePreview();
}

void inputIniCounter::generatePreview(void)
{
QStringList sections;
QList<QStringList> sec_vals;
//qDebug() << "imp_set->keys=" << imp_set->keys;
if (imp_set->keys.length()<=0)
{
selSet->lblText->setText(QString("-->#-->"));
return;
}
split_ini_keys(imp_set->keys,sections,sec_vals);
int type,target,set;
QString section,text;
getSettings(type,section,text,target,set);
int counter=evaluateSingleCounter(sections,sec_vals,type,section,text);
//qDebug() << "Preview:" << counter;
selSet->lblText->setText(QString("-->")+QString::number(counter)+QString("-->"));
}

multiIniCountPreproc::multiIniCountPreproc(QWidget * parent, int t):QWidget(parent)
{
type=t;//0=counter, 1=preprocessor
layout=new QGridLayout(this);
//layout->setMargin(0);//no margin here because it is to be part of a higher layout
layout->setContentsMargins(0,0,0,0);
layout->setSpacing(STD_SPACING);
nr_of_counters=allocated=0;
counter=NULL;
preproc=NULL;
minus=NULL;
plus=new QPushButton(QString("+"),this);
connect(plus,SIGNAL(clicked()),this,SLOT(plusClicked()));
lblTitle=new QLabel(tr("Entries counters:"),this);
if (type==1) lblTitle->setText(tr("Preprocessors:"));
layout->addWidget(lblTitle,0,0,1,2);
layout->addWidget(plus,1,0,1,2);

#if QT_VERSION >= 0x050000

#else
    map=new QSignalMapper;
#endif

sections.clear();
setLayout(layout);
redisplayCounters();
}

void multiIniCountPreproc::init(struct importSettings & input)
{
/*qDebug() << input.keys.length() << "keys=" << input.keys;
qDebug() << input.vals.length() << "vals=" << input.vals;*/

/*
    int nr_of_import_tokens;//how many relevant tokens are present in an ini-file
    int * token_target;//where to import header-data into
    QStringList vals,keys;//header-informations form an ini-file
    QList<int> import_channel_dest;//what channel the data is to import to (-1 = general information, not specific to a channel)
    QList<int> import_dest;//where to import the data read from the header
    //entry-counters
    int nr_of_counters;
    QList<int> counterTypes,counterTargets;
    QStringList counterSections,counterText;
*/

QList<QStringList> sec_vals;
split_ini_keys(input.keys,sections,sec_vals);
int pos;
//qDebug() << endl << sections.length() << "section=" << sections;
//qDebug() << sec_vals.length() << "sec_vals=" << sec_vals << endl;

if (type==0)//counters
{
    for (int i=0;i<allocated;i++)
    {
    counter[i]->selSection->blockSignals(true);
    pos=counter[i]->selSection->currentIndex();
    counter[i]->init(sections);
    counter[i]->selSection->setCurrentIndex(pos);
    counter[i]->selSection->blockSignals(false);
    }
}
else//preprocessors
{
    for (int i=0;i<allocated;i++)
    {
    //pos=preproc[i]->selSection->currentIndex();
    preproc[i]->init(input.keys);//sections);
    //preproc[i]->selSection->setCurrentIndex(pos);
    }
}

}

void multiIniCountPreproc::clearCounters(void)
{
nr_of_counters=0;
for (int i=0;i<allocated;i++)
{
minus[i]->hide();
    if (type==0)
    counter[i]->hide();
    else
    preproc[i]->hide();
}
redisplayCounters();
}

void multiIniCountPreproc::setAllCounters(importSettings & input)
{
    if (type==1)
    {
    qDebug() << "ERROR: multiIniCountPreproc: setAllCounters called for Preprocessors!";
    return;
    }
    if (input.nr_of_counters<0) input.nr_of_counters=0;
    if (input.nr_of_preprocessors<0) input.nr_of_preprocessors=0;
init(input);
//qDebug() << "Counters: init complete" << input.nr_of_counters;
if (allocated<input.nr_of_counters)//not enough counters allocated
{
inputIniCounter ** counter2=new inputIniCounter * [input.nr_of_counters];
QPushButton ** minus2=new QPushButton*[input.nr_of_counters];
for (int i=0;i<allocated;i++)
{
counter2[i]=counter[i];
minus2[i]=minus[i];
}
for (int i=allocated;i<input.nr_of_counters;i++)
{
counter2[i]=new inputIniCounter(this);
minus2[i]=new QPushButton(QString("-"),this);
}
delete[] counter;
delete[] minus;
counter=counter2;
minus=minus2;
nr_of_counters=allocated=input.nr_of_counters;
}//end increase nr_of_counters
else//enough space available
{
nr_of_counters=input.nr_of_counters;
}

for (int i=0;i<allocated;i++)
{
counter[i]->init(sections);
counter[i]->imp_set=&input;
}
int index;
for (int i=0;i<nr_of_counters;i++)
{
if (i>=input.counterText.length()) continue;
counter[i]->lenText->blockSignals(true);
counter[i]->lenText->setText(input.counterText.at(i));
counter[i]->lenText->blockSignals(false);
counter[i]->selTarget->blockSignals(true);
//qDebug() << "Target=" << input.counterTargets.at(i) << "TargetSet=" << input.counterSets.at(i) << "Type=" << input.counterTypes.at(i);
counter[i]->selTarget->setCurrentIndex(input.counterTargets.at(i));
counter[i]->selTarget->blockSignals(false);
    if (input.counterSections.at(i).isEmpty())
    {
    index=0;
    }
    else
    {
    index=sections.indexOf(input.counterSections.at(i));
    //qDebug() << "Counter" << i << "Section=" << input.counterSections.at(i) << "index=" << index;
    if (index>=0) index++;
    }
counter[i]->selSection->blockSignals(true);
counter[i]->selSection->setCurrentIndex(index);
counter[i]->selSection->blockSignals(false);
counter[i]->selSet->setCurrentValue(input.counterSets.at(i));
counter[i]->selType->blockSignals(true);
counter[i]->selType->setCurrentValue(input.counterTypes.at(i));
counter[i]->selType->blockSignals(false);
counter[i]->generatePreview();
}
//qDebug() << "redisplaying";
redisplayCounters();
}

void multiIniCountPreproc::setAllPreprocessors(importSettings & input)
{
    if (type==0)
    {
    qDebug() << "ERROR: multiIniCountPreproc: setAllPreprocessors called for Counters!";
    return;
    }
init(input);
//qDebug() << "Preprocessors: init complete" << input.nr_of_preprocessors;
if (allocated<input.nr_of_preprocessors)//not enough counters allocated
{
inputIniPreprocessing ** counter2=new inputIniPreprocessing * [input.nr_of_preprocessors];
QPushButton ** minus2=new QPushButton*[input.nr_of_preprocessors];
for (int i=0;i<allocated;i++)
{
counter2[i]=preproc[i];
minus2[i]=minus[i];
}
for (int i=allocated;i<input.nr_of_preprocessors;i++)
{
counter2[i]=new inputIniPreprocessing(this);
minus2[i]=new QPushButton(QString("-"),this);
}
delete[] counter;
delete[] minus;
preproc=counter2;
minus=minus2;
nr_of_counters=allocated=input.nr_of_preprocessors;
}//end increase nr_of_counters
else//enough space available
{
nr_of_counters=input.nr_of_preprocessors;
}
for (int i=0;i<allocated;i++)
{
preproc[i]->init(input.keys);
preproc[i]->imp_set=&input;
}
int index;
for (int i=0;i<nr_of_counters;i++)
{
if (i>=input.preprocessingType.length()) continue;
preproc[i]->lenCharA->blockSignals(true);
preproc[i]->lenCharA->setText(input.preprocessingCharA.at(i));
preproc[i]->lenCharA->blockSignals(false);
preproc[i]->lenCharB->blockSignals(true);
preproc[i]->lenCharB->setText(input.preprocessingCharB.at(i));
preproc[i]->lenCharB->blockSignals(false);
preproc[i]->spnMultA->blockSignals(true);
preproc[i]->spnMultB->blockSignals(true);
preproc[i]->spnMultA->setValue(input.preprocessingMultipleA.at(i));
preproc[i]->spnMultA->setValue(input.preprocessingMultipleB.at(i));
preproc[i]->spnMultA->blockSignals(false);
preproc[i]->spnMultB->blockSignals(false);
preproc[i]->selTarget->blockSignals(true);
preproc[i]->selTarget->setCurrentValue(input.preprocessingTarget.at(i));
//qDebug() << "Target=" << input.preprocessingTarget.at(i);
preproc[i]->selTarget->blockSignals(false);
preproc[i]->selSet->blockSignals(true);
preproc[i]->selSet->setCurrentIndex(input.preprocessingSet.at(i)+1);
preproc[i]->selSet->blockSignals(false);
preproc[i]->selType->blockSignals(true);
preproc[i]->selType->setCurrentIndex(input.preprocessingType.at(i));
preproc[i]->selType->blockSignals(false);
index=input.keys.indexOf(input.preprocessingKey.at(i));
//qDebug() << "keys=" << input.keys << "looking for" << input.preprocessingKey.at(i);
if (index<0)
{
//qDebug() << "key" << input.preprocessingKey.at(i) << "not found!";
index=0;
}
preproc[i]->selKey->blockSignals(true);
preproc[i]->selKey->setCurrentIndex(index);
preproc[i]->selKey->blockSignals(false);
preproc[i]->typeChanged(preproc[i]->selType->currentIndex());
}

//qDebug() << "redisplaying";
redisplayCounters();
}

void multiIniCountPreproc::minusClicked(int c)
{
//qDebug() << "minus" << c << "clicked, allocated=" << allocated << "nr_of_counters=" << nr_of_counters;
inputIniCounter ** counter2=NULL;
inputIniPreprocessing ** preproc2=NULL;
if (type==0)
{
counter2=new inputIniCounter * [nr_of_counters];
}
else//type==1
{
preproc2=new inputIniPreprocessing * [nr_of_counters];
}
QPushButton ** minus2=new QPushButton * [nr_of_counters];
for (int i=0;i<c;i++)
{
    if (type==0)
    counter2[i]=counter[i];
    else
    preproc2[i]=preproc[i];
minus2[i]=minus[i];
}
for (int i=c+1;i<nr_of_counters;i++)
{
    if (type==0)
    counter2[i-1]=counter[i];
    else
    preproc2[i-1]=preproc[i];
minus2[i-1]=minus[i];
}
minus2[nr_of_counters-1]=minus[c];//the last one will be the deleted one for reuse later
if (type==0)
{
counter2[nr_of_counters-1]=counter[c];
memcpy(counter,counter2,sizeof(inputIniCounter*)*nr_of_counters);
}
else//type==1
{
preproc2[nr_of_counters-1]=preproc[c];
memcpy(preproc,preproc2,sizeof(inputIniPreprocessing*)*nr_of_counters);
}
memcpy(minus,minus2,sizeof(QPushButton*)*nr_of_counters);
nr_of_counters--;
N_DELETE2(counter2);
N_DELETE2(preproc2);
N_DELETE2(minus2);
//qDebug() << "finished minus" << c << "clicked, allocated=" << allocated << "nr_of_counters=" << nr_of_counters;
redisplayCounters();
}

void multiIniCountPreproc::redisplayCounters(void)
{
layout->removeWidget(plus);
for (int i=0;i<allocated;i++)
{
    if (type==0)
    layout->removeWidget(counter[i]);
    else
    layout->removeWidget(preproc[i]);
layout->removeWidget(minus[i]);
disconnect(minus[i],SIGNAL(clicked()),nullptr,nullptr);
}
int index=1;//index==0 is the title
for (int i=0;i<nr_of_counters;i++)
{
    if (type==0)
    layout->addWidget(counter[i],index,0,1,1);
    else
    layout->addWidget(preproc[i],index,0,1,1);
layout->addWidget(minus[i],index++,1,1,1);
#if QT_VERSION >= 0x050000
    connect(minus[i],&QPushButton::clicked,this,[this,i](){this->minusClicked(i);});
#else
    connect(minus[i],SIGNAL(clicked()),map,SLOT(map()));
    connect(map,SIGNAL(mapped(int)),this,SLOT(minusClicked(int)));
    map->setMapping(minus[i],i);
#endif
}
layout->addWidget(plus,index,0,1,2);
for (int i=0;i<nr_of_counters;i++)
{
    if (type==0)
    counter[i]->show();
    else
    preproc[i]->show();
minus[i]->show();
}
for (int i=nr_of_counters;i<allocated;i++)
{
    if (type==0)
    counter[i]->hide();
    else
    preproc[i]->hide();
minus[i]->hide();
}
emit(nrOfCountersChanged());
}

void multiIniCountPreproc::plusClicked(void)
{
//int index=1;
//qDebug() << "Plus Clicked: allocated=" << allocated << "nr_of_counters=" << nr_of_counters;
if (allocated>=nr_of_counters+1)//enough elements present
{
    if (type==0)
    counter[nr_of_counters]->init(sections);//just (re)init
    else
    preproc[nr_of_counters]->init(imp_set->keys);//just (re)init
//counter[nr_of_counters]->show();
//index=nr_of_counters+1;
//qDebug() << "enough";
}
else//more elements needed
{
inputIniCounter ** counter2=NULL;
inputIniPreprocessing ** preproc2=NULL;
    if (type==0)
    counter2=new inputIniCounter * [nr_of_counters+1];
    else
    preproc2=new inputIniPreprocessing * [nr_of_counters+1];
QPushButton ** minus2=new QPushButton*[nr_of_counters+1];
//qDebug() << "NOT enough: nr_of_counters=" << nr_of_counters << "allocated=" << allocated;
    for (int i=0;i<nr_of_counters;i++)
    {
        if (type==0)
        counter2[i]=counter[i];
        else
        preproc2[i]=preproc[i];
    minus2[i]=minus[i];
    //layout->removeWidget(counter[i]);
    }
if (type==0)
{
counter2[nr_of_counters]=new inputIniCounter(this);
counter2[nr_of_counters]->init(sections);
counter2[nr_of_counters]->imp_set=imp_set;
}
else
{
preproc2[nr_of_counters]=new inputIniPreprocessing(this);
preproc2[nr_of_counters]->init(imp_set->keys);
preproc2[nr_of_counters]->imp_set=imp_set;
}
minus2[nr_of_counters]=new QPushButton(QString("-"),this);
if (minus!=NULL) delete[] minus;
minus=minus2;
    if (type==0)
    {
    if (counter!=NULL) delete[] counter;
    counter=counter2;
    }
    else
    {
    if (preproc!=NULL) delete[] preproc;
    preproc=preproc2;
    }
//index=nr_of_counters+1;
//qDebug() << "Adding Counter:" << nr_of_counters << "index=" << index;
allocated=nr_of_counters+1;
}
nr_of_counters++;
//qDebug() << "finished plus: nr_of_counters=" << nr_of_counters << "index=" << index;
//qDebug() << "finished Plus Clicked: allocated=" << allocated << "nr_of_counters=" << nr_of_counters;
redisplayCounters();
}

void multiIniCountPreproc::get_all_counter_settings(struct importSettings & input)
{
input.nr_of_counters=this->nr_of_counters;
input.counterTypes.clear();
input.counterTargets.clear();
input.counterSections.clear();
input.counterText.clear();
input.counterSets.clear();
QString section,text;
int type,target,set;
    for (int i=0;i<nr_of_counters;i++)
    {
    counter[i]->getSettings(type,section,text,target,set);
    input.counterTypes << type;
    input.counterTargets << target;
    input.counterSections << section;
    input.counterText << text;
    input.counterSets << set;
    }
}

void multiIniCountPreproc::get_all_preprocessor_settings(struct importSettings & input)
{
input.nr_of_preprocessors=this->nr_of_counters;
input.preprocessingType.clear();
input.preprocessingSet.clear();
input.preprocessingTarget.clear();
input.preprocessingKey.clear();
input.preprocessingCharA.clear();
input.preprocessingCharB.clear();
input.preprocessingMultipleA.clear();
input.preprocessingMultipleB.clear();
int Type,set,target,multA,multB;
QString key,A,B;
    for (int i=0;i<nr_of_counters;i++)
    {
    preproc[i]->getPostprocessingSettings(Type,key,A,B,multA,multB,set,target);
    input.preprocessingType << Type;
    input.preprocessingSet << set;
    input.preprocessingTarget << target;
    input.preprocessingKey << key;
    input.preprocessingCharA << A;
    input.preprocessingCharB << B;
    input.preprocessingMultipleA << multA;
    input.preprocessingMultipleB << multB;
    }
}

int multiIniCountPreproc::nr_of_lines(void)
{
return 2+nr_of_counters;
}

void multiIniCountPreproc::setImportSetting(importSettings * i_s)
{
    imp_set=i_s;
    for (int i=0;i<nr_of_counters;i++)
    {
        if (type==0)
        counter[i]->imp_set=i_s;
        else
        preproc[i]->imp_set=i_s;
    }
}

pageHeaderInfo::pageHeaderInfo(QWidget * parent):QWidget(parent)
{
    grid=new QVBoxLayout;
    //grid->setMargin(STD_MARGIN);
    grid->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    grid->setSpacing(STD_SPACING);

    gridLayout=new QGridLayout;
    //gridLayout->setMargin(STD_MARGIN);
    gridLayout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    gridLayout->setSpacing(STD_SPACING);

    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(STD_SPACING);

    /*
    empty0=new QWidget;
    QHBoxLayout * layout0=new QHBoxLayout;
    //layout0->setMargin(STD_MARGIN);
    layout0->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout0->setSpacing(STD_SPACING);
    empty0->setLayout(layout0);
    */

    empty1=new QWidget;
    QHBoxLayout * layout1=new QHBoxLayout;
    //layout1->setMargin(STD_MARGIN);
    layout1->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
    empty1->setLayout(layout1);

    empty=new QWidget;
    scroll=new QScrollArea(this);
    scroll->setWidget(empty);
    cmdAdd=new QPushButton(QString("+"),this);
    cmdAdd->setToolTip(tr("Add another import token."));
    connect(cmdAdd,SIGNAL(clicked()),SLOT(doNew()));
    Headers=new QLabel*[5];
    for (int i=0;i<5;i++)
    {
        Headers[i]=new QLabel(QString(""),this);
        //layout0->addWidget(Headers[i]);
    }
    Headers[0]->setText(tr("Offset  "));
    Headers[1]->setText(tr("Format (Bytes)"));
    Headers[2]->setText(tr("Bytes"));
    Headers[3]->setText(tr("Import as"));
    Headers[4]->setText(tr("Remove"));
    //grid->addWidget(empty0);
    grid->addWidget(scroll);
    lblEndChar=new QLabel(QString("String-End-Char (Ascii-code):"),this);
    layout1->addWidget(lblEndChar);
    lenEndChar=new QLineEdit(QString("0"),this);
    layout1->addWidget(lenEndChar);
    cmdTestLoad=new QPushButton(QString("Test-Load"),this);
    cmdTestLoad->setToolTip(tr("Try to load header data using current settings."));
    layout1->addWidget(cmdTestLoad);
    connect(cmdTestLoad,SIGNAL(clicked()),SLOT(doTestLoad()));
    grid->addWidget(empty1);
    setLayout(grid);
#if QT_VERSION >= 0x050000

#else
    map=new QSignalMapper;
#endif
    number_of_lines=1;
    inFormats=new inputLine*[number_of_lines+2];
    inFormats[0]=new inputLine(0,this);
    inFormats[0]->cmdNew->setEnabled(false);//never delete first line
#if QT_VERSION >= 0x050000
    connect(inFormats[0]->cmdNew,&QPushButton::clicked,this,[this](){this->doDelete(0);});
#else
    connect(inFormats[0]->cmdNew,SIGNAL(clicked()),map,SLOT(map()));
    connect(map,SIGNAL(mapped(int)),this,SLOT(doDelete(int)));
    map->setMapping(inFormats[0]->cmdNew,0);
#endif
    connect(inFormats[0]->cmbFormat,SIGNAL(currentIndexChanged(int)),this,SLOT(offsetChanged(int)));
    connect(inFormats[0]->spnSize,SIGNAL(valueChanged(int)),this,SLOT(offsetChanged(int)));

    //layout->addWidget(inFormats[0]);
        for (int i=0;i<5;i++)
        {
        gridLayout->addWidget(Headers[i],0,i,1,1);
        }
    gridLayout->addWidget(inFormats[0]->lblOffset,1,0,1,1);
    gridLayout->addWidget(inFormats[0]->cmbFormat,1,1,1,1);
    gridLayout->addWidget(inFormats[0]->spnSize,1,2,1,1);
    gridLayout->addWidget(inFormats[0]->cmbImportAs,1,3,1,1);
    gridLayout->addWidget(inFormats[0]->cmdNew,1,4,1,1);
    gridLayout->addWidget(cmdAdd,2,0,1,5);
    gridLayout->setRowStretch(0,0);
    gridLayout->setRowStretch(1,10);
    gridLayout->setRowStretch(2,10);

    //layout->addWidget(cmdAdd);
    //empty->setLayout(layout);
    empty->setLayout(gridLayout);
    empty->setGeometry(0,0,500,28*(number_of_lines+2));

    nr_of_entries=0;
    for (int i=0;i<NUMBER_OF_IMPORT_DESTINATIONS;i++)
    {
        if (ImportDestinationType[i]&1)
        {
            entries[nr_of_entries]=QString(ImportDestinationName[i]);
            entry_values[nr_of_entries++]=ImportDestination[i];
        }
    }

    //nr_of_sels=0;
    iniDataGroup=new inputIniData(this);
    iniDataGroup->imp_set=&(par_wid->imp_set);
    connect(iniDataGroup->multCounters,SIGNAL(nrOfCountersChanged()),this,SLOT(resizeIniDisplay()));
    connect(iniDataGroup->multPreprocessors,SIGNAL(nrOfCountersChanged()),this,SLOT(resizeIniDisplay()));
    manHeaderGroup=new manualHeaderData(this);
    manHeaderGroup->setVisible(false);
    //iniDataGroup->setVisible(false);

    cmdReadIni=new QPushButton(tr("Read Ini File"),this);
    connect(cmdReadIni,SIGNAL(clicked()),SLOT(doReadIni()));
    cmdReadIni->setVisible(false);
    scroll2=new QScrollArea;
    /*empty2=new QWidget;
    layout2=new QVBoxLayout;
    //layout2->setMargin(STD_MARGIN);
    layout2->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout2->setSpacing(STD_SPACING);
    empty2->setLayout(layout2);
    empty2->setVisible(false);*/
    //scroll2->setWidget(empty2);
    scroll2->setWidget(iniDataGroup);
    scroll2->setVisible(false);

    scroll3=new QScrollArea;
    scroll3->setWidget(manHeaderGroup);
    scroll3->setVisible(false);

    grid->addWidget(cmdReadIni);
    grid->addWidget(scroll2);
    grid->addWidget(scroll3);
}

void pageHeaderInfo::changeRepresentation(int r)
{
(void)r;
bool headerPresent=par_wid->chkHeader->isChecked();
int headerType=par_wid->cmbHeaderFileFormat->currentIndex();
int formatSource=par_wid->cmbFormatSource->currentIndex();

/*cout << "Change Header Representation" << endl;
cout << "headerPresent=" << headerPresent << endl;
cout << "formatSource=" << formatSource << endl;
cout << "headerType=" << headerType << endl;*/

    if (headerPresent==false)
    {
        cmdReadIni->setVisible(false);
        manHeaderGroup->setVisible(true);
        manHeaderGroup->setEnabled(false);
        scroll2->setVisible(false);
        scroll3->setVisible(false);
        scroll->setVisible(false);
        //empty0->setVisible(false);
        empty1->setVisible(false);
    }
    else if (formatSource==0)//manual
    {
        cmdReadIni->setVisible(false);
        manHeaderGroup->setVisible(true);
        manHeaderGroup->setEnabled(true);
        scroll2->setVisible(false);
        scroll3->setVisible(true);
        scroll->setVisible(false);
        //empty0->setVisible(false);
        empty1->setVisible(false);
    }
    else if (formatSource==1 || (formatSource==2 && headerType==0))
    {
        cmdReadIni->setVisible(false);
        manHeaderGroup->setVisible(false);
        scroll2->setVisible(false);
        scroll3->setVisible(false);
        scroll->setVisible(true);
        //empty0->setVisible(true);
        empty1->setVisible(true);
    }
    else if (formatSource==2 && headerType==1)//ini-Header
    {
        cmdReadIni->setVisible(true);
        manHeaderGroup->setVisible(false);
        scroll2->setVisible(true);
        scroll3->setVisible(false);
        scroll->setVisible(false);
        //empty0->setVisible(false);
        empty1->setVisible(false);
    }
    else//ascii-file
    {

    }
}

void get_all_settings_from_ini_file(QString ini_file,QStringList & keys,QStringList & vals,QList<int> & import_channels)
{
QVariant val1;
QString val2,tval;
QStringList val3;
QString val4;
QSettings settings(ini_file,QSettings::IniFormat);
(void)import_channels;
//cout << "ini_file to read from=" << ini_file.toLocal8Bit().constData() << endl;
keys.clear();
vals.clear();
//import_channels.clear();
keys=settings.allKeys();
if (settings.status()!=QSettings::NoError)
{
val4=QObject::tr("Unable to read data from ini-file: ")+ini_file;
errmsg(val4.toLocal8Bit().constData());
keys.clear();
    return;
}
//qDebug() << "Status=" << settings.status();
    for (int i=0;i<keys.length();i++)
    {
    //if (keys.at(i).isEmpty() || settings.contains(keys.at(i))==false) continue;
    val1=settings.value(keys.at(i));
//    val4=val1.toString().replace(QString("\\u0007"),QString("\\A"));
//qDebug() << val1.toString() << "local=" << val1.toString().toLocal8Bit().constData() << "corrected=" << val4;
    val2=val1.toString();
    val3=val1.toStringList();
        if (val1.type()==QVariant::String)
        {
        tval=val2;
        }
        else if (val1.type()==QVariant::StringList)
        {
        tval=val3.at(0);
        for (int j=1;j<val3.length();j++)
            tval+=QString(",")+val3.at(j);
        }
        else
        {
        tval=QObject::tr("unidentified");
        }
    vals << tval;
    //import_channels << -1;//none
    }
}

void pageHeaderInfo::doReadIni(void)
{
struct importSettings null_import;
initSettings(null_import,false);
QString err_txt;
int std_schema_nr;
bool is_header_file;
par_wid->readAndCompleteFileNames(2,std_schema_nr,is_header_file);
read_header_settings(null_import);
//iniDataGroup->setCounterData(null_import);
    if (par_wid->headerFileNames.length()<=0)
    {
    err_txt=tr("No header-file selected.");
    errwin(err_txt.toLocal8Bit().constData());
    }
    else
    {
    par_wid->imp_set.HeaderFile=par_wid->headerFileNames.at(par_wid->bin_file_nr_to_import);
        if (par_wid->cur_import_scheme>=0)
        read_INI_header(par_wid->imp_set,std_bin_import_settings[par_wid->cur_import_scheme]);
        else
        read_INI_header(par_wid->imp_set,null_import);
    iniDataGroup->initData(par_wid->imp_set);
    resizeIniDisplay();
    }
}

void pageHeaderInfo::resizeIniDisplay(void)
{
int wid=800;
int s_h=iniDataGroup->titles[0]->height();
if (scroll2->width()>810) wid=scroll2->width()-10;
if (s_h<25) s_h=25;
else if (s_h*0.8>this->cmdReadIni->height()) s_h=this->cmdReadIni->height()*0.8;
iniDataGroup->layout->removeWidget(iniDataGroup->multCounters);
iniDataGroup->layout->removeWidget(iniDataGroup->multPreprocessors);
int hi=iniDataGroup->multCounters->nr_of_lines();
iniDataGroup->layout->addWidget(iniDataGroup->multCounters,1+par_wid->imp_set.keys.length(),0,hi,4);
int hi2=iniDataGroup->multPreprocessors->nr_of_lines();
iniDataGroup->layout->addWidget(iniDataGroup->multPreprocessors,1+hi+par_wid->imp_set.keys.length(),0,hi2,4);
//qDebug() << "keys=" << par_wid->imp_set.keys.length() << "counters=" << iniDataGroup->multCounters->nr_of_counters << "nrOfPreproc=" << iniDataGroup->multPreprocessors->nr_of_counters;
iniDataGroup->setMinimumSize(wid,(5+s_h)*(1+par_wid->imp_set.keys.length()+(hi+hi2)*1.05));
//iniDataGroup->setGeometry(0,0,wid,(5+s_h)*(1+par_wid->imp_set.keys.length()));
//scroll2->adjustSize();
}

void pageHeaderInfo::doTestLoad(void)
{
    par_wid->determine_string_size=true;
//first: read header settings into current scheme (not set)
    par_wid->CheckHeadersAndDatFiles();
    par_wid->imp_set.HeaderFile=par_wid->headerFileNames.at(0);
    read_header_settings(par_wid->imp_scheme);
//this is for reading the header only and importing all the informations to check whether the file-structure matches the informations set
    emit(readHeader());
qApp->processEvents();
    par_wid->convertSettingsToString();
    par_wid->tabFileInfo->headerContents=par_wid->settingString;
}

void pageHeaderInfo::read_header_settings(struct importSettings & imp_set)
{
//int counter;
imp_set.header_present=par_wid->chkHeader->isChecked();
imp_set.multiple_header_files=par_wid->chkMultiHeaders->isChecked();
int val=lenEndChar->text().toInt();

imp_set.string_end_char=(char)val;
if (par_wid->cmbFormatSource->currentIndex()==0)//manual
imp_set.header_format=0;
else if (par_wid->cmbFormatSource->currentIndex()==1)//header in data file
imp_set.header_format=1;
else
imp_set.header_format=2+par_wid->cmbHeaderFileFormat->currentIndex();//header in separate file

    if (par_wid->cmbHeaderFileFormat->currentIndex()==0)//binary header information
    {
    //cout << "read header settings: binary header" << endl;
    imp_set.nr_of_header_values=number_of_lines;
    if (imp_set.header_value_format!=NULL) delete[] imp_set.header_value_format;
    if (imp_set.header_value_size!=NULL) delete[] imp_set.header_value_size;
    if (imp_set.header_value_import!=NULL) delete[] imp_set.header_value_import;
    imp_set.header_value_format=new int[number_of_lines];
    imp_set.header_value_size=new int[number_of_lines];
    imp_set.header_value_import=new int[number_of_lines];
    imp_set.headersize=0;
        for (int i=0;i<number_of_lines;i++)
        {
        imp_set.header_value_format[i]=inFormats[i]->getType();
        imp_set.header_value_size[i]=inFormats[i]->getSize();
        imp_set.header_value_import[i]=inFormats[i]->getTarget();
        imp_set.headersize+=imp_set.header_value_size[i];
        }
    }
    else if (par_wid->cmbHeaderFileFormat->currentIndex()==1)//ini-header information
    {
    /*imp_set.keys.clear();
    if (imp_set.token_target!=NULL) delete[] imp_set.token_target;
    imp_set.token_target=new int[nr_of_sels+1];
    counter=0;
        for (int i=0;i<nr_of_sels;i++)
        {
            if (sels[i]->currentValue()!=IMPORT_TO_NONE)
            {
            imp_set.keys << keys.at(i);
            imp_set.token_target[counter++]=sels[i]->currentValue();
            }
        }
    imp_set.nr_of_import_tokens=imp_set.keys.length();*/
    //cout << "read header settings: ini header" << endl;
        iniDataGroup->setData(imp_set);
    }
    else//ascii header
    {

    }
/*qDebug() << "read_header: nr_of_counters=" << imp_set.nr_of_counters;
qDebug() << "read_header: nr_of_preprocessors=" << imp_set.nr_of_preprocessors;*/
}

void pageHeaderInfo::write_header_settings(struct importSettings & imp_set)
{
//cout << "write header settings to gui" << endl;
par_wid->chkHeader->setChecked(imp_set.header_present);
par_wid->chkMultiHeaders->setChecked(imp_set.multiple_header_files);
    if (imp_set.header_present)
    par_wid->chkMultiHeaders->setVisible(true);
    else
    par_wid->chkMultiHeaders->setVisible(false);
int val=imp_set.header_format-2;
if (val==-2)//manual
{
par_wid->cmbFormatSource->setCurrentIndex(0);
par_wid->cmbHeaderFileFormat->setCurrentIndex(0);
}
else if (val==-1)//header in data file
{
par_wid->cmbFormatSource->setCurrentIndex(1);
par_wid->cmbHeaderFileFormat->setCurrentIndex(0);
}
else//separate header file
{
par_wid->cmbFormatSource->setCurrentIndex(2);
par_wid->cmbHeaderFileFormat->setCurrentIndex(val);
}
lenEndChar->setText(QString::number((int)(imp_set.string_end_char)));
qApp->processEvents();
    if (par_wid->cmbHeaderFileFormat->currentIndex()==0)//binary header information
    {
    //cout << "setting binary header data number_of_lines=" << number_of_lines << endl;
    //cout << "imp_set.nr_of_header_values=" << imp_set.nr_of_header_values << endl;
        while (number_of_lines>imp_set.nr_of_header_values)
        {
        doDelete(number_of_lines-1);
        }
        while (number_of_lines<imp_set.nr_of_header_values)
        {
        doNew();
        }
        for (int i=0;i<number_of_lines;i++)
        {
        //cout << "header_val_format=" << imp_set.header_value_format[i] << endl;
        inFormats[i]->setType(imp_set.header_value_format[i]);
        inFormats[i]->setSize(imp_set.header_value_size[i]);
        inFormats[i]->setTarget(imp_set.header_value_import[i]);
        }
    }
    else if (par_wid->cmbHeaderFileFormat->currentIndex()==1)//ini-header information
    {
        //cout << "ini-Header is going to be displayed" << endl;
        iniDataGroup->initData(imp_set);
        resizeIniDisplay();
        //cout << "finished displaying iniheader" << endl;

        /*for (int i=0;i<imp_set.nr_of_import_tokens;i++)
        {
            for (int j=0;j<nr_of_sels;j++)
            {
                if (keys.at(j)==imp_set.keys.at(i))
                {
                sels[i]->setCurrentValue(imp_set.token_target[i]);
                break;
                }
            }
        }*/
    }
    else//ascii header
    {

    }

}

void pageHeaderInfo::updateOffsets(void)
{
    int offset=0;
    char dummy[32];
    for (int i=0;i<number_of_lines;i++)
    {
        sprintf(dummy,"%d",offset);
        inFormats[i]->lblOffset->setText(QString(dummy));
        offset+=inFormats[i]->getSize();
    }
}

void pageHeaderInfo::doNew(void)
{
//cout << "before new=" << gridLayout->rowCount() << endl;
    inputLine ** nlines=new inputLine*[number_of_lines+2];
    for (int i=0;i<number_of_lines;i++)
        nlines[i]=inFormats[i];
    nlines[number_of_lines]=new inputLine(0,this);

    connect(nlines[number_of_lines]->cmbFormat,SIGNAL(currentIndexChanged(int)),SLOT(offsetChanged(int)));
    connect(nlines[number_of_lines]->spnSize,SIGNAL(valueChanged(int)),SLOT(offsetChanged(int)));
#if QT_VERSION >= 0x050000
    connect(nlines[number_of_lines]->cmdNew,&QPushButton::clicked,this,[this](){this->doDelete(number_of_lines);});
#else
    connect(nlines[number_of_lines]->cmdNew,SIGNAL(clicked()),map,SLOT(map()));
    map->setMapping(nlines[number_of_lines]->cmdNew,number_of_lines);
#endif
    int rows=number_of_lines+2;
    gridLayout->removeWidget(cmdAdd);
    gridLayout->addWidget(cmdAdd,rows,0,1,5);
    gridLayout->setRowStretch(rows,10);
    //layout->insertWidget(number_of_lines,nlines[number_of_lines]);

    gridLayout->addWidget(nlines[number_of_lines]->lblOffset,rows-1,0,1,1);
    gridLayout->addWidget(nlines[number_of_lines]->cmbFormat,rows-1,1,1,1);
    gridLayout->addWidget(nlines[number_of_lines]->spnSize,rows-1,2,1,1);
    gridLayout->addWidget(nlines[number_of_lines]->cmbImportAs,rows-1,3,1,1);
    gridLayout->addWidget(nlines[number_of_lines]->cmdNew,rows-1,4,1,1);

    number_of_lines++;
    delete[] inFormats;
    inFormats=nlines;
    empty->setGeometry(0,0,500,(28)*(number_of_lines+2));
    updateOffsets();
//cout << "after new=" << gridLayout->rowCount() << endl;
}

void pageHeaderInfo::doDelete(int j)
{
//cout << "before delete=" << gridLayout->rowCount() << endl;
    inputLine ** nlines=new inputLine*[number_of_lines+1];
    int ofs=0;
//cout << "Deleting " << j << endl;
    for (int i=0;i<number_of_lines;i++)
    {
        if (i!=j)
        nlines[ofs++]=inFormats[i];
#if QT_VERSION >= 0x050000

#else
    map->removeMappings(inFormats[i]->cmdNew);
#endif
    }
    gridLayout->removeWidget(cmdAdd);
    for (int i=number_of_lines-1;i>=j;i--)
    {
        gridLayout->removeWidget(inFormats[i]->lblOffset);
        gridLayout->removeWidget(inFormats[i]->cmbFormat);
        gridLayout->removeWidget(inFormats[i]->spnSize);
        gridLayout->removeWidget(inFormats[i]->cmbImportAs);
        gridLayout->removeWidget(inFormats[i]->cmdNew);
//cout << "remove=" << i << endl;
    }
    delete inFormats[j];
    for (int i=j+1;i<number_of_lines;i++)
    {
//cout << "add Widget again=" << i << endl;
        gridLayout->addWidget(inFormats[i]->lblOffset,i,0,1,1);
        gridLayout->addWidget(inFormats[i]->cmbFormat,i,1,1,1);
        gridLayout->addWidget(inFormats[i]->spnSize,i,2,1,1);
        gridLayout->addWidget(inFormats[i]->cmbImportAs,i,3,1,1);
        gridLayout->addWidget(inFormats[i]->cmdNew,i,4,1,1);
    }
//cout << "add Add-Button at " << number_of_lines << endl;
    gridLayout->addWidget(cmdAdd,number_of_lines,0,1,5);
    delete[] inFormats;
    inFormats=nlines;
    number_of_lines--;
    empty->setGeometry(0,0,500,28*(number_of_lines+2));
    for (int i=0;i<number_of_lines;i++)
    {
#if QT_VERSION >= 0x050000
        connect(inFormats[i]->cmdNew,&QPushButton::clicked,this,[this,i](){this->doDelete(i);});
#else
        connect(inFormats[i]->cmdNew,SIGNAL(clicked()),map,SLOT(map()));
        map->setMapping(inFormats[i]->cmdNew,i);
#endif
    }
    updateOffsets();
//cout << "after delete=" << gridLayout->rowCount() << endl;
}

void pageHeaderInfo::offsetChanged(int i)
{
    (void)i;
    updateOffsets();
}

pageDataInfo::pageDataInfo(QWidget * parent):QWidget(parent)
{
    grid=new QGridLayout;
    //grid->setMargin(STD_MARGIN);
    grid->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    grid->setSpacing(STD_SPACING);
#if QT_VERSION >= 0x050000

#else
    map=new QSignalMapper(this);
#endif
    empty=new QWidget;
    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    empty->setLayout(layout);
    lblComment=new QLabel(tr("Structure of Dataset in binary file (Channel / Format / Bytesize / Import-Target):"),this);
    lblChannelCount=new QLabel(tr("Channel-Count (number of sets):"),this);
    spnChannelCount=new QSpinBox(this);
    spnChannelCount->setMinimum(0);
    spnChannelCount->setMaximum(1000);
    spnChannelCount->setValue(1);
    connect(spnChannelCount,SIGNAL(valueChanged(int)),SLOT(channelCountChanged(int)));
    lblDataSetCount=new QLabel(tr("Data-Set-Count (setlength):"),this);
    spnDataSetCount=new QSpinBox(this);
    spnDataSetCount->setMinimum(0);
    spnDataSetCount->setMaximum(INT_MAX);
    scroll=new QScrollArea;
    scroll->setWidget(empty);
    number_of_lines=1;
    inFormats=new inputLine*[number_of_lines+2];
    inFormats[0]=new inputLine(1,this);
    layout->addWidget(inFormats[0]);
    empty->setGeometry(0,0,500,35);
    chkReadToEOF=new QCheckBox(tr("Read Data until EOF"),this);
    //chkKeppTrigger=new QCheckBox(tr("KeepTriggerChannel"),this);
    selDataCompressed=new CompressionSelector(this);
    selDataCompressed->cmbCompression->lblText->setText(tr("Data decompression method:"));
    selDataCompressed->selComprLevel->setVisible(false);

    int nr=3;
    int values[3];
    QString entr[3];
    entr[0]=tr("No compression");
    entr[1]=tr("Qt-internal compression");
    entr[2]=tr("External compression (zlib)");
    values[0]=COMPRESSION_NONE;
    values[1]=COMPRESSION_QTINTERNAL;
    values[2]=COMPRESSION_EXTERNAL_ZLIB;
    selDataCompressed->cmbCompression->setNewEntries(nr,entr,values);

    nr=1;
    entr[0]=QString("0");
    selTriggerSet=new StdSelector(this,tr("Trigger channel:"),nr,entr);

    connect(chkReadToEOF,SIGNAL(toggled(bool)),SLOT(eofToggled(bool)));
    int nr_of_entries=2;
    QString * entries=new QString[4];
    entries[0]=QString("a0 b0 c0 | a1 b1 c1 | ... | an bn cn");
    entries[1]=QString("a0 a1 ... an | b0 b1 ... bn | c0 c1 ... cn");
    selOrder=new StdSelector(this,tr("Channel ordering in file:"),nr_of_entries,entries);
    nr_of_entries=4;
    entries[0]=tr("No trigger");
    entries[1]=tr("Rising edge");
    entries[2]=tr("Falling edge");
    entries[3]=tr("Either edge");
    selTriggerType=new StdSelector(this,tr("Trigger type:"),nr_of_entries,entries);
    int * tri_vals=new int[4];
        for (int i=0;i<4;i++)
        tri_vals[i]=i-1;
    selTriggerType->setValues(tri_vals);
        delete[] tri_vals;
    selTriggerValue=new stdLineEdit(this,tr("Trigger value:"));
    selTriggerValue->setToolTip(tr("The trigger value can be an absolute value which the trigger-channel has to pass.\nThe value can also be given in %.  In this case the value is calculated between\nmin (0%) and max value (100%) of the trigger-channel.\nJust add the '%'-character at the end of the value to indicate that you want the percentage."));
        //selTriggerValue->lblText->setText(tr("Trigger value:"));
        //selTriggerValue->spnLineWidth->setRange(-1e12,1e12);
        //selTriggerValue->spnLineWidth->setDecimals(6);
    int row=0;
    grid->addWidget(lblChannelCount,row,0);
    grid->addWidget(spnChannelCount,row++,1);
    grid->addWidget(lblDataSetCount,row,0);
    grid->addWidget(spnDataSetCount,row++,1);
    grid->addWidget(selOrder,row++,0,1,2);
    grid->addWidget(selTriggerType,row,0,1,1);
    grid->addWidget(selTriggerSet,row++,1,1,1);
    grid->addWidget(selTriggerValue,row++,0,1,2);
    grid->addWidget(lblComment,row++,0,1,2);
    grid->addWidget(scroll,row++,0,1,2);
    grid->addWidget(selDataCompressed,row++,0,1,2);
    grid->addWidget(chkReadToEOF,row,0,1,1);
    //grid->addWidget(chkKeppTrigger,row++,1,1,1);
    setLayout(grid);
#if QT_VERSION >= 0x050000

#else
    connect(map,SIGNAL(mapped(int)),SLOT(input_target_changed(int)));
#endif
}

void pageDataInfo::channelCountChanged(int i)
{
inputLine ** inLines=new inputLine*[i+2];
char dummy[32];
#if QT_VERSION >= 0x050000

#else
        for (int j=0;j<number_of_lines;j++)
        map->removeMappings(inFormats[j]->cmbImportAs);
#endif
//qDebug() << "Channel Count Changed=" << i << endl;
QString * entr=new QString[2+i];
int * entr_val=new int[2+i];
int tr_ch=selTriggerSet->currentValue();
for (int k=0;k<i;k++)
{
entr_val[k]=k;
entr[k]=QString::number(k);
}
selTriggerSet->setNewEntries(i,entr,entr_val);
selTriggerSet->setCurrentValue(tr_ch);
delete[] entr;
delete[] entr_val;
    if (i>number_of_lines)//new line(s)
    {
        for (int j=0;j<number_of_lines;j++)
        {
            inLines[j]=inFormats[j];
        }
        for (int j=number_of_lines;j<i;j++)
        {
            inLines[j]=new inputLine(1,this);
            layout->addWidget(inLines[j]);
            sprintf(dummy,"%d:",j);
            inLines[j]->lblOffset->setText(QString(dummy));
        }
        delete[] inFormats;
        inFormats=inLines;
    }
    else if (i<number_of_lines)
    {
        for (int j=i;j<number_of_lines;j++)
            delete  inFormats[j];
        delete[] inLines;
    }

    number_of_lines=i;
    empty->setGeometry(0,0,500,35*number_of_lines+2);

    for (int j=0;j<number_of_lines;j++)
    {
#if QT_VERSION >= 0x050000
    //connect(inFormats[j]->cmbImportAs,&QComboBox::currentIndexChanged(int),this,[this,j](){this->input_target_changed(j);});
    connect(inFormats[j]->cmbImportAs,QOverload<int>::of(&QComboBox::currentIndexChanged),this,[this,j](int index){(void)index;this->input_target_changed(j);});
#else
    connect(inFormats[j]->cmbImportAs,SIGNAL(currentIndexChanged(int)), map, SLOT(map()));
    map->setMapping(inFormats[j]->cmbImportAs,j);
#endif
    }

    emit(newChannelCount(i));
}

void pageDataInfo::eofToggled(bool i)
{
    lblDataSetCount->setEnabled(!i);
    spnDataSetCount->setEnabled(!i);
}

void pageDataInfo::input_target_changed(int t)
{
static int update_running=0;
if (update_running==1 || !(inFormats[t]->cmbImportAs->currentIndex()==7 || inFormats[t]->cmbImportAs->currentIndex()==1)) return;
update_running=1;
    for (int j=0;j<number_of_lines;j++)
    {
        if (j==t) continue;
    if (inFormats[j]->cmbImportAs->currentIndex()==7 && inFormats[t]->cmbImportAs->currentIndex()==7)
    inFormats[j]->cmbImportAs->setCurrentIndex(2);
    else if (inFormats[j]->cmbImportAs->currentIndex()==1 && inFormats[t]->cmbImportAs->currentIndex()==1)
    inFormats[j]->cmbImportAs->setCurrentIndex(0);
    }
update_running=0;
}

void pageDataInfo::readDataSettings(importSettings & imp_set)
{
    if (imp_set.channel_format!=NULL) delete[] imp_set.channel_format;
    if (imp_set.channel_size!=NULL) delete[] imp_set.channel_size;
    if (imp_set.channel_target!=NULL) delete[] imp_set.channel_target;
    imp_set.channels=spnChannelCount->value();
    imp_set.read_to_eof=chkReadToEOF->isChecked();
    imp_set.data_is_compressed=selDataCompressed->method();
        if (imp_set.read_to_eof) imp_set.points=-1;
        else imp_set.points=spnDataSetCount->value();
    imp_set.channel_target=new int[imp_set.channels];
    imp_set.channel_size=new int[imp_set.channels];
    imp_set.channel_format=new int[imp_set.channels];
    for (int i=0;i<imp_set.channels;i++)
    {
        imp_set.channel_target[i]=inFormats[i]->getTarget();
        imp_set.channel_size[i]=inFormats[i]->getSize();
        imp_set.channel_format[i]=inFormats[i]->getType();
    }
    //imp_set.channel_format_known=true;
    imp_set.setorder=selOrder->currentIndex();
    //imp_set.keep_trigger=chkKeppTrigger->isChecked();
    imp_set.trigger_channel=selTriggerSet->currentValue();
    ///imp_set.triggervalue=selTriggerValue->value();
    QString tmp_text=selTriggerValue->text();
    int pos=tmp_text.indexOf("%");
    if (pos>=0)
    {
    imp_set.trigger_is_percent=true;
    tmp_text=tmp_text.left(pos);
    }
    else
    {
    imp_set.trigger_is_percent=false;
    }
    imp_set.triggervalue=tmp_text.toDouble();
    //qDebug() << "Trigger read=" << tmp_text << "Value=" << imp_set.triggervalue << "Percent=" << imp_set.trigger_is_percent;
    imp_set.trigger_type=selTriggerType->currentValue();
}

void pageDataInfo::writeDataSettings(importSettings & imp_set)
{
spnChannelCount->setValue(imp_set.channels);
    if (imp_set.points<0)
    spnDataSetCount->setValue(0);
    else
    spnDataSetCount->setValue(imp_set.points);
chkReadToEOF->setChecked(imp_set.read_to_eof);
selDataCompressed->setMethod(imp_set.data_is_compressed);
qApp->processEvents();
    //imp_set.channel_format_known==true &&
    if (imp_set.channel_target!=NULL && imp_set.channel_size!=NULL && imp_set.channel_format!=NULL)
    {
        for (int i=0;i<imp_set.channels;i++)
        {
        inFormats[i]->setTarget(imp_set.channel_target[i]);
        inFormats[i]->setSize(imp_set.channel_size[i]);
        inFormats[i]->setType(imp_set.channel_format[i]);
        }
    }
selOrder->setCurrentValue(imp_set.setorder);
//chkKeppTrigger->setChecked(imp_set.keep_trigger);
selTriggerSet->setCurrentValue(imp_set.trigger_channel);
char dummy[128];
sprintf(dummy,"%g",imp_set.triggervalue);
QString set_Text(dummy);
if (imp_set.trigger_is_percent==true)
{
    set_Text+=QString(" %");
}
Replace_Dec_Sep_In_Single_String(set_Text);
selTriggerValue->setText(set_Text);
///selTriggerValue->setValue(imp_set.triggervalue);
selTriggerType->setCurrentValue(imp_set.trigger_type);
}

pageFileInfo::pageFileInfo(QWidget * parent):QWidget(parent)
{
    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    lblText=new QLabel(tr("Informations about file / Informations read from header"),this);
    lenText=new QTextEdit(QString(""),this);
    lenText->setReadOnly(true);
    lenText->setWordWrapMode(QTextOption::NoWrap);
    layout->addWidget(lblText);
    layout->addWidget(lenText);
    setLayout(layout);
    headerContents=QString("");
    DatFile=NULL;
    HeaderFile=NULL;
}

pageFileInfo::~pageFileInfo()
{
    if (DatFile!=NULL) delete[] DatFile;
    if (HeaderFile!=NULL) delete[] HeaderFile;
}

void pageFileInfo::showEvent(QShowEvent * event)
{
    event->accept();
    emit(requestInfos());
    qApp->processEvents();
    ShowInfos();
}

void pageFileInfo::ShowInfos(void)
{
    QString filenames=QString::fromLocal8Bit(DatFile);
    lenText->clear();
    char dummy[256];
    if (DatFile)
    {
        if (filenames.contains(";"))
        {
        filenames=filenames.left(filenames.indexOf(";"));
        lenText->append("Multiple files selected; only info on first file shown!");
        }
            if (DatFile==HeaderFile)
            lenText->append(QString("Headerfile=Datafile=\"")+filenames+QString("\""));
            else
            lenText->append(QString("Datafile=\"")+filenames+QString("\""));
        QFileInfo * dfi=new QFileInfo(filenames);
        if (dfi->exists())
        {
        sprintf(dummy,"FileSize= %ld Bytes",(long)dfi->size());
        lenText->append(QString(dummy));
        }
        else
        {
        lenText->append(tr("This File does not exist!"));
        }
    }
    else
    {
        if (DatFile==HeaderFile)
        lenText->append(tr("No Datafile and Headerfile selected!"));
        else
        lenText->append(tr("No Datafile selected!"));
    }
    if (!HeaderFile)
    {
        lenText->append(tr("No Headerfile selected!"));
    }
    else if (DatFile!=HeaderFile && strcmp(DatFile,HeaderFile)!=0)
    {
        lenText->append(QString(" "));
        if (HeaderFile)
        {
            lenText->append(QString("Headerfile=\"")+QString::fromLocal8Bit(HeaderFile)+QString("\""));
            QFileInfo * hfi=new QFileInfo(QString::fromLocal8Bit(HeaderFile));
            if (hfi->exists())
            {
            sprintf(dummy,"Filesize= %ld Bytes",(long)hfi->size());
            lenText->append(QString(dummy));
            }
            else
            {
            lenText->append(tr("This File does not exist!"));
            }
        }
        else
        lenText->append(tr("No Headerfile selected!"));
    }
    lenText->append(QString(" "));
    lenText->append(headerContents);
}

pageImportInfo::pageImportInfo(QWidget * parent):QWidget(parent)
{
    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    selType=new stdSetTypeSelector(this);
    selType->setShowAll(true);
    selType->lblText->setText(tr("Set-Type for imported data:"));
    lblImportTo=new QLabel(tr("Read to graph:"),this);
    importGraph=new uniList(GRAPHLIST,this);
    int number=4;
    QString entr[4];
    int vals[4];
    entr[0]=tr("None");
    vals[0]=AUTOSCALE_NONE;
    entr[1]=tr("X");
    vals[1]=AUTOSCALE_X;
    entr[2]=tr("Y");
    vals[2]=AUTOSCALE_Y;
    entr[3]=tr("XY");
    vals[3]=AUTOSCALE_XY;
    selAutoscale=new StdSelector(this,tr("Autoscale on read:"),number,entr);
    selAutoscale->setValues(vals);
    selAutoscale->setCurrentIndex(3);
    layout->addWidget(selType);
    layout->addWidget(selAutoscale);
    layout->addWidget(lblImportTo);
    layout->addWidget(importGraph);
    setLayout(layout);
}

void pageImportInfo::newChannelCount(int i)
{
    (void)i;
}

void pageImportInfo::read_settings(struct importSettings & imp_set)
{
imp_set.set_type=selType->currentValue();
imp_set.autoscale=selAutoscale->currentValue();
int nr_sel,*selection=new int[2];
    importGraph->get_selection(&nr_sel,&selection);
    if (nr_sel<1) imp_set.target_gno=-1;//no target graph!?
    else imp_set.target_gno=selection[0];
delete[] selection;
}

void pageImportInfo::write_settings(struct importSettings & imp_set)
{
selType->setCurrentIndex(imp_set.set_type);
selAutoscale->setCurrentValue(imp_set.autoscale);
int *selection=new int[2];
    selection[0]=imp_set.target_gno;
    importGraph->set_new_selection(1,selection);
delete[] selection;
}

frmBinaryFormatInput::frmBinaryFormatInput(QWidget * parent):QDialog(parent)
{
    /*dlgLoadFormat=NULL;
    dlgSaveFormat=NULL;
    dlgLoadIniFile=NULL;
    dlgLoadDataFile=NULL;*/
    LoadFormatPath.clear();
    SaveFormatPath.clear();
    LoadIniPath.clear();
    LoadDataPath.clear();
    FormatFileLastUsed.clear();

    CreateActions();

    mnuBar=new QMenuBar(this);
    mnuData=new QMenu(tr("File"),mnuBar);
    mnuSettings=new QMenu(tr("Settings"),mnuBar);

    mnuData->addAction(actLoadDataFile);
    mnuData->addAction(actLoadHeaderFile);
    mnuData->addSeparator();
    mnuData->addAction(actClose);
    mnuSettings->addAction(actautoguess);
    actautoguess->setChecked(true);
    mnuSettings->addSeparator();
    mnuSettings->addAction(actLoadSettings);
    mnuSettings->addAction(actSaveSettings);
    mnuSettings->addSeparator();
    mnuSettings->addAction(actLoadStdSettings);
    mnuSettings->addAction(actSaveStdSettings);
    mnuSettings->addSeparator();
    mnuSettings->addAction(actDeleteSettings);
    mnuBar->addMenu(mnuData);
    mnuBar->addMenu(mnuSettings);

    initSettings(imp_set,false);
    initSettings(imp_scheme,false);

    imp_set.title=new char[2];
    imp_set.subtitle=new char[2];
    imp_set.x_title=new char[2];
    imp_set.y_title=new char[2];
        for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
        imp_set.set_title[i]=new char[2];
    imp_set.first_data=new double*[2];
    imp_set.channel_format=new int[2];
    imp_set.channel_size=new int[2];
    imp_set.channel_target=new int[2];
    //imp_set.channel_format_known=false;
    imp_set.nr_of_import_tokens=0;
    imp_set.token_target=new int[2];
    imp_set.valid_status=-1;//to tell the functions, that we did not initialize anything (we do not know anything about the file format yet)

    determine_string_size=auto_transfer_from_header=true;

    headerFileNames.clear();
    datFileNames.clear();

    setWindowTitle(tr("QtGrace: Binary file input"));
    grid=new QGridLayout;
    //grid->setMargin(STD_MARGIN);
    grid->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    grid->setSpacing(STD_SPACING);
    QGridLayout * layout=new QGridLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(STD_SPACING*2);
    QWidget * empty=new QWidget;
    QWidget * empty2=new QWidget;
    QHBoxLayout * layout2=new QHBoxLayout;
    //layout2->setMargin(STD_MARGIN);
    layout2->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout2->setSpacing(STD_SPACING);
    QLabel * lblempty=new QLabel(QString(""),this);
    layout2->addWidget(lblempty);
    empty2->setLayout(layout2);

    /*cmdSave=new QPushButton(tr("Save Format"),this);
    connect(cmdSave,SIGNAL(clicked()),SLOT(doSaveFileFormat()));
    cmdLoad=new QPushButton(tr("Load Format"),this);
    connect(cmdLoad,SIGNAL(clicked()),SLOT(doLoadFileFormat()));
    cmdStdSave=new QPushButton(tr("Save Std.-Format"),this);
    connect(cmdStdSave,SIGNAL(clicked()),SLOT(doSaveStdFormat()));
    cmdStdLoad=new QPushButton(tr("Load Std.-Format"),this);
    connect(cmdStdLoad,SIGNAL(clicked()),SLOT(doLoadStdFormat()));*/

    lblFormatSource=new QLabel(tr("Format Source:"),this);
    cmbFormatSource=new QComboBox(this);
    cmbFormatSource->addItem(tr("manual"));
    cmbFormatSource->addItem(tr("datafile"));
    cmbFormatSource->addItem(tr("seperate file"));
    cmbFormatSource->setCurrentIndex(1);
    connect(cmbFormatSource,SIGNAL(currentIndexChanged(int)),SLOT(formatSourceChanged(int)));
        lenDataFile=new stdLineEdit(this,tr("Datafile:"));
        lenDataFile->setAcceptDrops(true);
        lenDataFile->setText(QString(""));
        lenHeaderFile=new stdLineEdit(this,tr("Headerfile:"));
        lenHeaderFile->setAcceptDrops(true);
        lenHeaderFile->setText(QString(""));
    connect(lenDataFile,SIGNAL(changed()),SLOT(newFileEntry()));
    connect(lenHeaderFile,SIGNAL(changed()),SLOT(newFileEntry()));
    /*lblDataFile=new QLabel(tr("Datafile:"),this);
    lenDataFile=new QLineEdit(QString(""),this);
    lblHeaderFile=new QLabel(tr("Headerfile:"),this);
    lenHeaderFile=new QLineEdit(QString(""),this);*/

    /*chkAutoGuessFormat=new QCheckBox(tr("Auto-guess binary file format"),this);
    chkAutoGuessFormat->setChecked(true);*/
    lblCurScheme=new QLabel(tr("Current import scheme: None"),this);
    chkHeader=new QCheckBox(tr("Header informations present"),this);
    chkHeader->setChecked(true);
    connect(chkHeader,SIGNAL(toggled(bool)),SLOT(headerToggled(bool)));
    chkMultiHeaders=new QCheckBox(tr("separate header file for every data file"),this);
    chkMultiHeaders->setChecked(true);
    lblHeaderFileFormat=new QLabel(tr("Headerfile-Format:"),this);
    cmbHeaderFileFormat=new QComboBox(this);
    cmbHeaderFileFormat->addItem(tr("binary-file"));
    cmbHeaderFileFormat->addItem(tr("ini-file"));
    /// cmbHeaderFileFormat->addItem(tr("ascii-file"));///deactivated at the moment
    connect(cmbHeaderFileFormat,SIGNAL(currentIndexChanged(int)),SLOT(HeaderFormatChanged(int)));

    tabs=new QTabWidget;
    tabHeader=new pageHeaderInfo(this);
    tabHeader->par_wid=this;
    tabDataInfo=new pageDataInfo(this);
    tabFileInfo=new pageFileInfo(this);
    tabImportInfo=new pageImportInfo(this);
    connect(tabHeader,SIGNAL(readHeader()),this,SLOT(readHeader()));
    connect(tabFileInfo,SIGNAL(requestInfos()),SLOT(transmitInfos()));
    tabs->addTab(tabHeader,tr("Header-Format"));
    tabs->addTab(tabFileInfo,tr("File-Info"));
    tabs->addTab(tabDataInfo,tr("Data-Format"));
    tabs->addTab(tabImportInfo,tr("Import"));

    aac=new stdButtonGroup(this,true,true,false);
    connect(aac->cmdApply,SIGNAL(clicked()),SLOT(doOK()));
    connect(aac->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
    connect(aac->cmdClose,SIGNAL(clicked()),SLOT(doClose()));

    cmdSelectDataFile=new QPushButton(tr("Browse..."),this);
    connect(cmdSelectDataFile,SIGNAL(clicked()),SLOT(SelectDataFile()));
    cmdSelectHeaderFile=new QPushButton(tr("Browse..."),this);
    connect(cmdSelectHeaderFile,SIGNAL(clicked()),SLOT(SelectHeaderFile()));

int index=0,index2=0;
    //layout->addWidget(chkAutoGuessFormat,index,0,1,2);
    //layout->addWidget(lblCurScheme,index++,2,1,2);
    layout->addWidget(lblCurScheme,index++,0,1,4);
    /*layout->addWidget(cmdLoad,index,0,1,1);
    layout->addWidget(cmdSave,index,1,1,1);
    layout->addWidget(cmdStdLoad,index,2,1,1);
    layout->addWidget(cmdStdSave,index++,3,1,1);*/
    layout->addWidget(chkHeader,index,0,1,2);
    layout->addWidget(chkMultiHeaders,index++,2,1,2);
    empty->setLayout(layout);

#ifndef MAC_SYSTEM
    grid->addWidget(mnuBar,index2++,0,1,3);
#endif
    grid->addWidget(empty,index2++,0,1,3);
    grid->addWidget(lblFormatSource,index2,0);
    grid->addWidget(cmbFormatSource,index2++,1);
    /*grid->addWidget(lblDataFile,2,0);
    grid->addWidget(lenDataFile,2,1);*/
    grid->addWidget(lenDataFile,index2,0,1,2);
    grid->addWidget(cmdSelectDataFile,index2++,2);
    /*grid->addWidget(lblHeaderFile,3,0);
    grid->addWidget(lenHeaderFile,3,1);*/
    grid->addWidget(lenHeaderFile,index2,0,1,2);
    grid->addWidget(cmdSelectHeaderFile,index2++,2);
    grid->addWidget(lblHeaderFileFormat,index2,0);
    grid->addWidget(cmbHeaderFileFormat,index2++,1);
    grid->addWidget(empty2,index2++,0,1,3);
    grid->addWidget(tabs,index2++,0,1,3);
    grid->addWidget(aac,index2++,0,1,3);
    setLayout(grid);

    cmbFormatSource->setCurrentIndex(1);
    formatSourceChanged(1);
    initSettings(imp_set,false);//the settings will be uninitialized
    initSettings(imp_scheme,false);

cur_import_scheme=-1;//no schema
    resize(LastSize_FormBinaryImportFilter);
}

frmBinaryFormatInput::~frmBinaryFormatInput()
{
    LastSize_FormBinaryImportFilter=this->size();
}

void frmBinaryFormatInput::displaySettings(struct importSettings & imp_s)
{
    //cout << "header present: " << imp_set.header_present << endl;
chkHeader->setChecked(imp_s.header_present);
    //cout << "multiple_headers: " << imp_set.multiple_header_files << endl;
chkMultiHeaders->setChecked(imp_s.multiple_header_files);
    //cout << "header Format=" << imp_set.header_format << endl;
    if (imp_s.header_format==0)
    {
    cmbFormatSource->setCurrentIndex(0);
    }
    else if (imp_s.header_format==1)
    {
    cmbFormatSource->setCurrentIndex(1);
    }
    else
    {
    cmbFormatSource->setCurrentIndex(2);
    cmbHeaderFileFormat->setCurrentIndex(imp_s.header_format-2);
    }
//transmitInfos();
    tabHeader->write_header_settings(imp_s);
    tabDataInfo->writeDataSettings(imp_s);
    tabImportInfo->write_settings(imp_s);
}

void frmBinaryFormatInput::readSettings(struct importSettings & imp_s, int type)
{
    if (type==0 || type==3)
    {
    imp_s.header_present=chkHeader->isChecked();
    imp_s.multiple_header_files=chkMultiHeaders->isChecked();
        if (cmbFormatSource->currentIndex()==0)//manual
        {
        imp_s.header_format=0;
        }
        else if (cmbFormatSource->currentIndex()==1)//header in bin-data-file
        {
        imp_s.header_format=1;
        }
        else//header in separate file (bin/ini/ascii)
        {
        imp_s.header_format=2+cmbHeaderFileFormat->currentIndex();
        }
    tabHeader->read_header_settings(imp_s);
    }
if (type==1 || type==3)
tabDataInfo->readDataSettings(imp_s);
if (type==2 || type==3)
tabImportInfo->read_settings(imp_s);
/// for debugging
//SaveFileFormat("/Users/andreaswinter/Read_schema_Settings.fmt",imp_s);/// just save for testing
/// end debugging
}

void frmBinaryFormatInput::HeaderFormatChanged(int i)
{
bool headerPresent=chkHeader->isChecked();
//int headerType=cmbHeaderFileFormat->currentIndex();
int formatSource=cmbFormatSource->currentIndex();
    if (headerPresent==false || formatSource<=1)
    {
        lenHeaderFile->setVisible(false);
        cmdSelectHeaderFile->setVisible(false);
    lblHeaderFileFormat->setVisible(false);
    cmbHeaderFileFormat->setVisible(false);
        if (formatSource==1)//datafile
        {
        cmbHeaderFileFormat->setCurrentIndex(0);//always binary
        }
    }
    else//headerPresent==true && formatSource>1//ini- || ascii-header
    {
        lenHeaderFile->setVisible(true);
        cmdSelectHeaderFile->setVisible(true);
    lblHeaderFileFormat->setVisible(true);
    cmbHeaderFileFormat->setVisible(true);
    }
tabHeader->changeRepresentation(i);
}

void frmBinaryFormatInput::doSaveFileFormat(void)
{
    /*
    if (dlgSaveFormat==NULL)
    {
    dlgSaveFormat=new QFileDialog(this,tr("Save File Format Settings"),qt_grace_share_dir);
    dlgSaveFormat->setFileMode(QFileDialog::AnyFile);
    dlgSaveFormat->setNameFilter(tr("Format specification (*.fmt)"));
    }
    if (dlgSaveFormat->exec())
    {
    QStringList fileNames;
    QString str;
    fileNames = dlgSaveFormat->selectedFiles();
        if (fileNames.length()<=0) return;
        str=fileNames.at(0);
    }
    */
    QString templ_dir=QString(qt_grace_templates_dir);
    QString str;
    if (!SaveFormatPath.isEmpty())
    str=QFileDialog::getSaveFileName(this,tr("Save Format Info File"),SaveFormatPath);
    else
    str=QFileDialog::getSaveFileName(this,tr("Save Format Info File"),templ_dir);

    if (!str.isEmpty())
    {
    char * files=new char[8+str.length()];
    strcpy(files,str.toLocal8Bit().constData());
        updateSuffixes();
        initSettings(imp_set,true);
        imp_set.DataSuffix=Data_Suffix;
        imp_set.HeaderSuffix=HeaderSuffix;

        tabHeader->read_header_settings(imp_set);
        tabDataInfo->readDataSettings(imp_set);
        imp_set.set_type=tabImportInfo->selType->currentIndex();

        SaveFileFormat(files,imp_set);

        QFileInfo tmpInfo(files);
        SaveFormatPath=tmpInfo.path();

    delete[] files;
    }
}

void frmBinaryFormatInput::doLoadFileFormat(void)
{
    /*if (dlgLoadFormat==NULL)
    {
    dlgLoadFormat=new QFileDialog(this,tr("Load File Format Settings"),qt_grace_share_dir);
    dlgLoadFormat->setFileMode(QFileDialog::ExistingFile);
    dlgLoadFormat->setNameFilter(tr("Format specification (*.fmt)"));
    }
    if (dlgLoadFormat->exec())
    {
    QStringList fileNames;
    QString str;
    fileNames = dlgLoadFormat->selectedFiles();
        if (fileNames.length()<=0) return;
        str=fileNames.at(0);
    }*/
    QString templ_dir=QString(qt_grace_templates_dir);
    QString str;
    if (!LoadFormatPath.isEmpty())
    str=QFileDialog::getOpenFileName(this,tr("Load Format Info File"),LoadFormatPath,tr("Format specification (*.fmt)"));
    else
        str=QFileDialog::getOpenFileName(this,tr("Load Format Info File"),templ_dir,tr("Format specification (*.fmt)"));
    if (!str.isEmpty())
    {
    char * files=new char[8+str.length()];
    strcpy(files,str.toLocal8Bit().constData());
    FormatFileLastUsed=str;
        LoadFileFormat(files,imp_scheme);///load the import settings in the scheme
    displaySettings(imp_scheme);
    tabHeader->write_header_settings(imp_scheme);
        QFileInfo tmpInfo(files);
        LoadFormatPath=tmpInfo.path();
    cur_import_scheme=-2;//scheme loaded form a format file
        lblCurScheme->setText(tr("Current scheme: ")+tmpInfo.fileName());
        if (imp_scheme.header_present==true && imp_scheme.header_format==3)
        {
        tabHeader->doReadIni();
        }
    delete[] files;
    }//end of !str.isEmpty()
}

void frmBinaryFormatInput::doSaveStdFormat(void)
{
/*QString stdTarget=QString(qt_grace_share_dir)+QString("/QtGrace_StdBinFormat.fmt");
char * std_File_Save=new char[2+2*stdTarget.length()];
strcpy(std_File_Save,stdTarget.toLocal8Bit().constData());
    updateSuffixes();
    imp_set.DataSuffix=DataSuffix;
    imp_set.HeaderSuffix=HeaderSuffix;
    tabHeader->read_header_settings(imp_set);
    tabDataInfo->readDataSettings(imp_set);
    imp_set.set_type=tabImportInfo->selType->currentIndex();
    SaveFileFormat(std_File_Save,imp_set);
delete[] std_File_Save;*/
QString templ_dir=QString(qt_grace_templates_dir);
    if (FormSimpleListSel==NULL)
    {
    FormSimpleListSel=new frmSimpleListSelectionDialog(0);
    }
QString * entries=new QString[2+nr_of_std_bin_import_settings];
    for (int i=0;i<nr_of_std_bin_import_settings;i++)
    {
    entries[i]=std_bin_import_settings[i].name;
    }
FormSimpleListSel->init(entries,nr_of_std_bin_import_settings,false);
int ret=FormSimpleListSel->exec();
    if (ret==1 && FormSimpleListSel->return_nr!=-1)//not cancel
    {
QFileInfo fi;
    fi.setFile(lenDataFile->lenText->text());
    imp_set.DataSuffix=fi.suffix();
    fi.setFile(lenHeaderFile->lenText->text());
    imp_set.HeaderSuffix=fi.suffix();
    tabHeader->read_header_settings(imp_set);
    tabDataInfo->readDataSettings(imp_set);
    tabImportInfo->read_settings(imp_set);

        if (FormSimpleListSel->return_nr==-2)//new name
        {
        QString n_filename=templ_dir+QDir::separator()+QString("QtGrace_std_bin_format_")+FormSimpleListSel->return_name+QString(".fmt");
            //cout << "Filename=" << n_filename.toLocal8Bit().data() << endl;
        SaveFileFormat(n_filename.toLocal8Bit().data(),imp_set);
        imp_set.name=FormSimpleListSel->return_name;
        imp_set.filename=n_filename;
        struct importSettings * n_imp_set=new struct importSettings[1+nr_of_std_bin_import_settings];
        for (int i=0;i<nr_of_std_bin_import_settings;i++)
        {
        initSettings(n_imp_set[i],false);
        copy_import_settings(std_bin_import_settings+i,n_imp_set+i);
        initSettings(std_bin_import_settings[i],true);
        }
        initSettings(n_imp_set[nr_of_std_bin_import_settings],false);
        copy_import_settings(&imp_set,n_imp_set+nr_of_std_bin_import_settings);
        nr_of_std_bin_import_settings++;
        delete[] std_bin_import_settings;
        std_bin_import_settings=n_imp_set;
        }
        else if (FormSimpleListSel->return_nr>=0)//existing name
        {
        SaveFileFormat(std_bin_import_settings[FormSimpleListSel->return_nr].filename.toLocal8Bit().data(),imp_set);
        }
    }
delete[] entries;
}

void frmBinaryFormatInput::doLoadStdFormat(void)
{
/*QString stdTarget=QString(qt_grace_share_dir)+QString("/QtGrace_StdBinFormat.fmt");
char * std_File_Save=new char[2+2*stdTarget.length()];
strcpy(std_File_Save,stdTarget.toLocal8Bit().constData());
    LoadFileFormat(std_File_Save,imp_set);
delete[] std_File_Save;*/
    if (FormSimpleListSel==NULL)
    {
    FormSimpleListSel=new frmSimpleListSelectionDialog(0);
    }
QString * entries=new QString[2+nr_of_std_bin_import_settings];
    for (int i=0;i<nr_of_std_bin_import_settings;i++)
    {
    entries[i]=std_bin_import_settings[i].name;
    }
FormSimpleListSel->init(entries,nr_of_std_bin_import_settings,true);
int ret=FormSimpleListSel->exec();
    if (ret==1 && FormSimpleListSel->return_nr!=-1)//not cancel
    {
    //FormatFileLastUsed=std_bin_import_settings[FormSimpleListSel->return_nr].filename;
    LoadFileFormat(std_bin_import_settings[FormSimpleListSel->return_nr].filename.toLocal8Bit().data(),imp_set);
    LoadFileFormat(std_bin_import_settings[FormSimpleListSel->return_nr].filename.toLocal8Bit().data(),imp_scheme);
        displaySettings(imp_scheme);
        tabHeader->write_header_settings(imp_scheme);
    QFileInfo tmpInfo(std_bin_import_settings[FormSimpleListSel->return_nr].filename);
        LoadFormatPath=tmpInfo.path();
    cur_import_scheme=FormSimpleListSel->return_nr;
        lblCurScheme->setText(tr("Current scheme: ")+std_bin_import_settings[FormSimpleListSel->return_nr].name);
        if (imp_scheme.header_present==true && imp_scheme.header_format==3)
        {
        tabHeader->doReadIni();
        }
    }
delete[] entries;
}

void frmBinaryFormatInput::doClearCurrentScheme(void)
{
int ret=QMessageBox::question(this,tr("Clear current scheme"),tr("Do you really want do clear the current import settings and reset the import-dialog? (Any saved format-files stay untouched.)"),QMessageBox::Yes,QMessageBox::Cancel);
    if (ret==QMessageBox::Yes)
    {
    initSettings(imp_set);
    initSettings(imp_scheme);
    lblCurScheme->setText(tr("Current import scheme: None"));
    }
    else
    {
    cout << "CANCEL" << endl;
    }
}

void LoadFileFormat(const char *fname,struct importSettings & imp_set)
{
    QString s_dummy,s_dummy2,s_dummy3;
    int version;
    //int nr_of_channels,nr_of_datasets,nr_of_lines;
    int dint;
    int idummy;
    char dummy[512];
    char dummy2[512];//,dummy3[512];
    strcpy(dummy,fname);
    ifstream ifi;
    ifi.open(dummy);
    ifi >> dummy >> version;
///cout << fname << " --> dummy=#" << dummy << "# version=" << version << endl;
    if (strcmp(dummy,"Binary_Format_Info_File_V"))
    {
        errwin(QObject::tr("File is not a Grace-format description!").toLocal8Bit().constData());
        ifi.close();
        return;
    }
    initSettings(imp_set);//clear old settings
    if (version==1)/// old format
    {
//cout << "Loading OLD format description" << endl;
    ifi >> dint;
    imp_set.header_present=(bool)dint;
    //chkHeader->setChecked((bool)dint);
    ifi >> dint;
    imp_set.header_format=dint;
    ///cmbFormatSource->setCurrentIndex(dint);
    ifi >> dint;
    if (imp_set.header_format>1)
    {
    imp_set.header_format=2+dint;
    }
    //cmbHeaderFileFormat->setCurrentIndex(dint);
    ifi >> dummy;
    //cout << "dummy=#" << dummy << "#" << endl;
    imp_set.string_end_char=dummy[0];
    //tabHeader->lenEndChar->setText(QString(dummy));
    ifi >> imp_set.nr_of_header_values;//nr_of_lines;
    if (imp_set.header_value_format!=NULL) delete[] imp_set.header_value_format;
    if (imp_set.header_value_size!=NULL) delete[] imp_set.header_value_size;
    if (imp_set.header_value_import!=NULL) delete[] imp_set.header_value_import;
    imp_set.header_value_format=new int[2+imp_set.nr_of_header_values];
    imp_set.header_value_size=new int[2+imp_set.nr_of_header_values];
    imp_set.header_value_import=new int[2+imp_set.nr_of_header_values];
        //int nr_of_header_values;
        //int * header_value_format,* header_value_size,* header_value_import;
    /*
    //cout << "nr_of_lines=" << nr_of_lines << endl;
    while (tabHeader->number_of_lines<nr_of_lines)
    {
        //cout << "tabHeader_nroflines=" << tabHeader->number_of_lines << endl;
        tabHeader->doNew();
    }
    while (tabHeader->number_of_lines>nr_of_lines)
    {
        //cout << "tabHeader_nroflines=" << tabHeader->number_of_lines << endl;
        tabHeader->doDelete(tabHeader->number_of_lines-1);
    }*/
    for (int i=0;i<imp_set.nr_of_header_values;i++)//nr_of_lines;i++)
    {
        ifi >> dint;
        imp_set.header_value_format[i]=dint;
        //tabHeader->inFormats[i]->cmbFormat->setCurrentIndex(dint);
        ifi >> dint;
        imp_set.header_value_size[i]=dint;
        //tabHeader->inFormats[i]->spnSize->setValue(dint);
        ifi >> dint;
        imp_set.header_value_import[i]=dint;
        //tabHeader->inFormats[i]->cmbImportAs->setCurrentIndex(dint);
    }
    ifi >> dint;
    imp_set.read_to_eof=dint;
    //tabDataInfo->chkReadToEOF->setChecked((bool)dint);
    ifi >> imp_set.channels;//nr_of_channels;
    //tabDataInfo->spnChannelCount->setValue(nr_of_channels);
    ifi >> imp_set.points;//nr_of_datasets;
    //tabDataInfo->spnDataSetCount->setValue(nr_of_datasets);
    ifi >> dint;
    imp_set.setorder=dint;
    //tabDataInfo->selOrder->setCurrentIndex(dint);
    ifi >> dint;//nr_of_lines;
    //cout << "nr_of_lines=" << nr_of_lines << endl;
    //cout << "tabDataInfo->number_of_lines=" << tabDataInfo->number_of_lines << endl;
        //tabDataInfo->channelCountChanged(nr_of_lines);
    if (imp_set.channel_format!=NULL) delete[] imp_set.channel_format;
    if (imp_set.channel_size!=NULL) delete[] imp_set.channel_size;
    if (imp_set.channel_target!=NULL) delete[] imp_set.channel_target;
    imp_set.channel_format=new int[2+imp_set.channels];
    imp_set.channel_size=new int[2+imp_set.channels];
    imp_set.channel_target=new int[2+imp_set.channels];
    for (int i=0;i<imp_set.channels;i++)//nr_of_lines;i++)
    {
        ifi >> dint;
        imp_set.channel_format[i]=dint;
        //tabDataInfo->inFormats[i]->cmbFormat->setCurrentIndex(dint);
        ifi >> dint;
        imp_set.channel_size[i]=dint;
        //tabDataInfo->inFormats[i]->spnSize->setValue(dint);
        ifi >> dint;
        imp_set.channel_target[i]=dint;
        //tabDataInfo->inFormats[i]->cmbImportAs->setCurrentIndex(dint);
    }
    //imp_set.channel_format_known=true;
    ifi >> dint;
    /*if (nr_of_channels<=1)
        tabImportInfo->selType->setColumnCount(2);
    else
        tabImportInfo->selType->setColumnCount(nr_of_channels);*/
    imp_set.set_type=dint;
    //tabImportInfo->selType->setCurrentValue(dint);
    ifi.close();
    }
    else if (version==2)/// new file format
    {
    //int count_set_tokens=0;
    int nr_of_lines;
//qDebug() << "Loading NEW format description";
        ifi >> dummy2 >> idummy;//Header_present
        imp_set.header_present=idummy;
        //chkHeader->setChecked(idummy==1?true:false);
        ifi >> dummy2 >> idummy;//Multiple_headers
        imp_set.multiple_header_files=idummy;
        //chkMultiHeaders->setChecked(idummy==1?true:false);
        ifi >> dummy2 >> dummy;//Data_Suffix
        imp_set.DataSuffix=get_text_in_quotations(QString(dummy));
        //DataSuffix=QString(dummy);
        ifi >> dummy2 >> dummy;//Header_Suffix
        imp_set.HeaderSuffix=get_text_in_quotations(QString(dummy));
        //HeaderSuffix=QString(dummy);
        ifi >> dummy2 >> idummy;//Format_Source
        imp_set.header_format=idummy;
        //cmbFormatSource->setCurrentIndex(idummy);
        ifi >> dummy2 >> idummy;//Header_Format
            if (imp_set.header_format==2)
            imp_set.header_format=2+idummy;
        //cmbHeaderFileFormat->setCurrentIndex(idummy);
        ifi >> dummy2 >> dummy;//Line_End_Char(ASCII)
        imp_set.string_end_char=dummy[0];
        //tabHeader->lenEndChar->setText(dummy);
        ifi >> dummy2 >> imp_set.nr_of_header_values;//nr_of_lines;//Bin_Header_Definition_Length

        /*while (tabHeader->number_of_lines<nr_of_lines)
        {
            //cout << "tabHeader_nroflines=" << tabHeader->number_of_lines << endl;
            tabHeader->doNew();
        }
        while (tabHeader->number_of_lines>nr_of_lines)
        {
            //cout << "tabHeader_nroflines=" << tabHeader->number_of_lines << endl;
            tabHeader->doDelete(tabHeader->number_of_lines-1);
        }*/
        if (imp_set.header_value_format!=NULL) delete[] imp_set.header_value_format;
        imp_set.header_value_format=new int[2+imp_set.nr_of_header_values];
        if (imp_set.header_value_size!=NULL) delete[] imp_set.header_value_size;
        imp_set.header_value_size=new int[2+imp_set.nr_of_header_values];
        if (imp_set.header_value_import!=NULL) delete[] imp_set.header_value_import;
        imp_set.header_value_import=new int[2+imp_set.nr_of_header_values];
//cout << "Header dummy2=#" << dummy2 << "# nr=" << nr_of_lines << endl;
            if (imp_set.nr_of_header_values)//tabHeader->number_of_lines>0)
            ifi.getline(dummy2,512);//to remove the line ending
        for (int i=0;i<imp_set.nr_of_header_values;i++)//tabHeader->number_of_lines;i++)
        {
            ifi.getline(dummy2,512);
         //cout << i << " Format dummy2=#" << dummy2 << "#" << endl;
            s_dummy=QString(dummy2);
            s_dummy2=get_text_in_quotations(s_dummy);
         //cout << "gelesen=#" << s_dummy2.toLocal8Bit().constData() << "#" << endl;
            strcpy(dummy2,s_dummy2.toLocal8Bit().constData());
            //idummy=find_import_destination(dummy2,2);//data in bin-header

            idummy=find_import_format(dummy2);//data-type in bin-header

            /*
            for (int j=0;j<NUMBER_OF_COLUMN_FORMATS;j++)
            {
                if (!strcmp(dummy2,binaryImportFormatName[j]))
                {
                idummy=j;
                break;
                }
            }
            */
         //cout << "index=" << idummy << endl;
            imp_set.header_value_format[i]=idummy;
            //tabHeader->inFormats[i]->cmbFormat->setCurrentIndex(idummy);
            //ifi >> dummy2 >> dummy;//Format
            //cout << "H: Format=#" << dummy << "#" << endl;
                //ifi >> dummy2 >> s_dummy;//Format
                //cout << "H: Format=#" << s_dummy.toLocal8Bit().constData() << "#" << endl;
            /// ToDo: find the format
            //ofi << i << ":Format= \"" << binaryImportFormatName[tabHeader->inFormats[i]->cmbFormat->currentIndex()] << "\"" << endl;
            ifi >> dummy2 >> idummy;//Size
            imp_set.header_value_size[i]=idummy;
            //tabHeader->inFormats[i]->spnSize->setValue(idummy);
         //cout << "size=" << idummy << endl;
            //ifi >> dummy2 >> dummy;//ImportAs
            //cout << "H: ImportAs=#" << dummy << "#" << endl;
            ifi.getline(dummy2,512);//to remove the line ending
            ifi.getline(dummy2,512);
         //cout << i << " ImportAs dummy2=#" << dummy2 << "#" << endl;
            s_dummy=QString(dummy2);
            s_dummy2=get_text_in_quotations(s_dummy);
            strcpy(dummy2,s_dummy2.toLocal8Bit().constData());
         //cout << "gelesen=#" << s_dummy2.toLocal8Bit().constData() << "#" << endl;
            idummy=find_import_destination(dummy2,1);//header-destination in bin-header
            /*for (int j=0;j<tabHeader->inFormats[0]->cmbImportAs->count();j++)
            {
                if (QString::compare(tabHeader->inFormats[0]->cmbImportAs->itemText(j),s_dummy2)==0)
                {
                idummy=j;
                break;
                }
            }*/
        //cout << "index=" << idummy << endl;
            imp_set.header_value_import[i]=idummy;
            //tabHeader->inFormats[i]->cmbImportAs->setCurrentIndex(idummy);
                //ifi >> dummy2 >> s_dummy2;//ImportAs
                //cout << "H: ImportAs=#" << s_dummy2.toLocal8Bit().constData() << "#" << endl;
            /// ToDo: Search for this dummy
            //tabHeader->inFormats[i]->cmbImportAs->currentText().toLatin1().constData();
        }//end header-loop

        ifi >> dummy2 >> idummy;//ReadUntilEOF
        imp_set.read_to_eof=(idummy==1?true:false);
        //tabDataInfo->chkReadToEOF->setChecked(idummy==1?true:false);
        ifi >> dummy2 >> idummy;//ChannelCount
        imp_set.channels=idummy;
        //tabDataInfo->spnChannelCount->setValue(idummy);
        ifi >> dummy2 >> idummy;//NrOfDataSets
        imp_set.points=idummy;
        //tabDataInfo->spnDataSetCount->setValue(idummy);
        ifi >> dummy2 >> idummy;//SetOrderingInFile
        imp_set.setorder=idummy;
        //tabDataInfo->selOrder->setCurrentIndex(idummy);
        ifi >> dummy2 >> idummy;//Trigger_Type
        imp_set.trigger_type=idummy;
        //tabDataInfo->selTriggerType->setCurrentIndex(idummy);
        ifi >> dummy2 >> dummy;//Trigger_Value
        imp_set.triggervalue=atof(dummy);
        //tabDataInfo->selTriggerValue->setValue(atof(dummy));
        ifi >> dummy2 >> nr_of_lines;//Bin_Input_Definition_Length
//qDebug() << "Data dummy2=#" << dummy2 << "# nr=" << nr_of_lines;

        //tabDataInfo->channelCountChanged(nr_of_lines);

        if (imp_set.channel_format!=NULL) delete[] imp_set.channel_format;
        if (imp_set.channel_size!=NULL) delete[] imp_set.channel_size;
        if (imp_set.channel_target!=NULL) delete[] imp_set.channel_target;

        imp_set.channel_format=new int[imp_set.channels+2];
        imp_set.channel_size=new int[imp_set.channels+2];
        imp_set.channel_target=new int[imp_set.channels+2];

        //if (nr_of_lines>0)
        if (imp_set.channels>0)
        ifi.getline(dummy2,512);//to remove the line ending
        for (int i=0;i<imp_set.channels;i++)//tabDataInfo->number_of_lines;i++)
        {
            ifi.getline(dummy2,512);
         //cout << i << " Format dummy2=#" << dummy2 << "#" << endl;
            s_dummy=QString(dummy2);
            s_dummy2=get_text_in_quotations(s_dummy);
            strcpy(dummy2,s_dummy2.toLocal8Bit().constData());
            idummy=-1;
            for (int j=0;j<NUMBER_OF_COLUMN_FORMATS;j++)
            {
                if (!strcmp(dummy2,binaryImportFormatName[j]))
                {
                idummy=j;
                break;
                }
            }
         //cout << "index=" << idummy << endl;
            imp_set.channel_format[i]=idummy;
            //tabDataInfo->inFormats[i]->cmbFormat->setCurrentIndex(idummy);
            //ifi >> dummy2 >> dummy;//Format
         //cout << "D: Format=#" << dummy2 << "#" << endl;
            /// ToDo: find the format
            //ofi << i << ":Format= \"" << binaryImportFormatName[tabDataInfo->inFormats[i]->cmbFormat->currentIndex()] << "\"" << endl;
            ifi >> dummy2 >> idummy;//Size
            imp_set.channel_size[i]=idummy;
            //tabDataInfo->inFormats[i]->spnSize->setValue(idummy);
         //cout << "size=" << idummy << endl;
            //ifi >> dummy2 >> dummy;//ImportAs
            //cout << "H: ImportAs=#" << dummy << "#" << endl;
            ifi.getline(dummy2,512);//to remove the line ending
            ifi.getline(dummy2,512);
         //qDebug() << i << " ImportAs dummy2=#" << dummy2 << "#";
            s_dummy=QString(dummy2);
            s_dummy2=get_text_in_quotations(s_dummy);
            strcpy(dummy2,s_dummy2.toLocal8Bit().constData());
         //qDebug() << "gelesen=#" << s_dummy2.toLocal8Bit().constData() << "#";
            idummy=find_import_destination(dummy2,2);
            /*for (int j=0;j<tabDataInfo->inFormats[0]->cmbImportAs->count();j++)
            {
                if (QString::compare(tabDataInfo->inFormats[0]->cmbImportAs->itemText(j),s_dummy2)==0)
                {
                idummy=j;
                break;
                }
            }*/

            imp_set.channel_target[i]=idummy;
         //qDebug() << i << "index=" << idummy << "channel_target=" << imp_set.channel_target[i];
            //tabDataInfo->inFormats[i]->cmbImportAs->setCurrentIndex(idummy);

            if (imp_set.channel_size[i]<=0)
            {
            imp_set.channel_size[i]=binaryImportFormat[imp_set.channel_format[i]].size;
            }

        }//end i-loop over all import-channels
        //imp_set.channel_format_known=true;
        ifi >> dummy2 >> idummy;//Import_Set_As
        imp_set.set_type=idummy;
///cout << "dummy2=" << dummy2 << " idummy=" << idummy << endl;
        //tabImportInfo->selType->setCurrentValue(idummy);
        ifi >> dummy2 >> idummy;//Autoscale
        imp_set.autoscale=idummy;
        ifi >> dummy2 >> imp_set.nr_of_import_tokens;//count_set_tokens;//INI-Import-Tokens
        //qDebug() << "import_tokens=" << imp_set.nr_of_import_tokens;
        imp_set.vals.clear();
        imp_set.keys.clear();
        imp_set.import_channel_dest.clear();
            if (imp_set.nr_of_import_tokens>0)//count_set_tokens
            {
            ifi.getline(dummy2,512);//to remove the line ending
            if (imp_set.token_target!=NULL) delete[] imp_set.token_target;
            imp_set.token_target=new int[imp_set.nr_of_import_tokens];
            }
        imp_set.import_dest.clear();
        for (int i=0;i<imp_set.nr_of_import_tokens;i++)
        {
        ifi.getline(dummy2,512);
        s_dummy=QString(dummy2);
        idummy=s_dummy.indexOf(" ");
        s_dummy=s_dummy.left(idummy);
        imp_set.import_channel_dest << s_dummy.toInt();
        s_dummy=QString(dummy2);
        idummy=s_dummy.indexOf(" ");
        s_dummy=s_dummy.mid(idummy+1);
        idummy=s_dummy.lastIndexOf(" = \"");
        s_dummy=s_dummy.left(idummy);
        imp_set.keys << s_dummy;
        s_dummy=QString(dummy2);
        s_dummy2=get_text_in_quotations(s_dummy);
        imp_set.vals << s_dummy2;
/*
qDebug() << "Key=#" << imp_set.keys.last().toLocal8Bit().constData() << "#";
qDebug() << "Val=#" << imp_set.vals.last().toLocal8Bit().constData() << "#";
qDebug() << "Channel=#" << imp_set.import_channel_dest.last() << "#";
*/
        imp_set.token_target[i]=find_import_destination(imp_set.vals.last().toLocal8Bit().data(),1);
        imp_set.import_dest << imp_set.token_target[i];
        }
        ifi.getline(dummy2,512);
        dint=sscanf(dummy2,"Data-Compression= %d",&idummy);
        //qDebug() << "Dummy2=" << dummy2 << "dint=" << dint;
        imp_set.data_is_compressed=0;
        imp_set.nr_of_counters=0;
        imp_set.counterTypes.clear();
        imp_set.counterSections.clear();
        imp_set.counterText.clear();
        imp_set.counterTargets.clear();
        imp_set.counterSets.clear();

        imp_set.nr_of_preprocessors=0;
        imp_set.preprocessingType.clear();
        imp_set.preprocessingSet.clear();
        imp_set.preprocessingTarget.clear();
        imp_set.preprocessingMultipleA.clear();
        imp_set.preprocessingMultipleB.clear();
        imp_set.preprocessingKey.clear();
        imp_set.preprocessingCharA.clear();
        imp_set.preprocessingCharB.clear();

        //qDebug() << "LOAD FILE FORMAT (" << fname << "): dummy2=" << dummy2;
        if (dint==1)
        {
        imp_set.data_is_compressed=idummy;
        //qDebug() << "Read successful, compressed=" << imp_set.data_is_compressed;
        /*else
        {
        qDebug() <<"Read failed, not compression info!?";
        }*/
        ifi.getline(dummy2,512);
        dint=sscanf(dummy2,"NrOfCounters= %d",&idummy);
        //qDebug() << "Nr_of_Counters=" << idummy << "dint=" << dint;
        if (dint==1)
        {
        imp_set.nr_of_counters=idummy;
            for (int i=0;i<imp_set.nr_of_counters;i++)
            {
            ifi.getline(dummy2,512);
            dint=sscanf(dummy2,"Counter %d",&idummy);
            //qDebug() << dummy2 << "#" << dint;
            if (dint!=1) qDebug() << "Error reading Counter: " << dummy2;
            ifi.getline(dummy2,512);
            dint=sscanf(dummy2,"Type= %d",&idummy);
            //qDebug() << dummy2 << "#" << dint;
            if (dint!=1) qDebug() << "Error reading Counter Type: " << dummy2;
            imp_set.counterTypes << idummy;
            ifi.getline(dummy2,512);
            s_dummy3=QString(dummy2);
            s_dummy3=get_text_in_first_last_quotations(s_dummy3);
            //qDebug() << QString(dummy2) << "#"  << s_dummy3;
            //ofi << "Section= \"" << imp_set.counterSections.at(i).toLocal8Bit().constData() << "\"" << endl;
            imp_set.counterSections << s_dummy3;
            ifi.getline(dummy2,512);
            s_dummy3=QString(dummy2);
            s_dummy3=get_text_in_first_last_quotations(s_dummy3);
            //qDebug() << QString(dummy2) << "#" << s_dummy3;
            //ofi << "Text= \"" << imp_set.counterText.at(i).toLocal8Bit().constData() << "\"" << endl;
            imp_set.counterText << s_dummy3;
            ifi.getline(dummy2,512);
            dint=sscanf(dummy2,"Set= %d",&idummy);
            //qDebug() << dummy2 << "#" << dint;
            if (dint!=1) qDebug() << "Error reading Set: " << dummy2;
            imp_set.counterSets << idummy;
            ifi.getline(dummy2,512);
            s_dummy3=QString(dummy2);
            s_dummy3=get_text_in_first_last_quotations(s_dummy3);
            //qDebug() << QString(dummy2) << "#"  << s_dummy3;
            imp_set.counterTargets << find_import_destination(s_dummy3.toLocal8Bit().data(),1);
            //qDebug() << "Counter" << i << "Type=" << imp_set.counterTypes.last() << "Section=" << imp_set.counterSections.last() << "Text=" << imp_set.counterText.last() << "Target=" << imp_set.counterTargets.last();
            }
        ifi.getline(dummy2,512);
        dint=sscanf(dummy2,"NrOfPreprocessors= %d",&idummy);
        //qDebug() << "NrOfPreprocessors=" << idummy << "dint=" << dint;
            if (dint==1)
            {
            imp_set.nr_of_preprocessors=idummy;
                for (int i=0;i<imp_set.nr_of_preprocessors;i++)
                {
                ifi.getline(dummy2,512);
                dint=sscanf(dummy2,"Preprocessor %d",&idummy);
                //qDebug() << dummy2 << "#" << dint;
                if (dint!=1) qDebug() << "Error reading Counter: " << dummy2;
                ifi.getline(dummy2,512);
                dint=sscanf(dummy2,"Type= %d",&idummy);
                //qDebug() << dummy2 << "#" << dint;
                if (dint!=1) qDebug() << "Error reading Counter Type: " << dummy2;
                imp_set.preprocessingType << idummy;
                ifi.getline(dummy2,512);
                s_dummy3=QString(dummy2);
                s_dummy3=get_text_in_first_last_quotations(s_dummy3);
                //qDebug() << QString(dummy2) << "#"  << s_dummy3;
                imp_set.preprocessingKey << s_dummy3;
                ifi.getline(dummy2,512);
                dint=sscanf(dummy2,"Set= %d",&idummy);
                //qDebug() << dummy2 << "#" << dint;
                if (dint!=1) qDebug() << "Error reading Set: " << dummy2;
                imp_set.preprocessingSet << idummy;
                ifi.getline(dummy2,512);
                s_dummy3=QString(dummy2);
                s_dummy3=get_text_in_first_last_quotations(s_dummy3);
                //qDebug() << QString(dummy2) << "#"  << s_dummy3;
                imp_set.preprocessingTarget << find_import_destination(s_dummy3.toLocal8Bit().data(),1);
                ifi.getline(dummy2,512);
                s_dummy3=QString(dummy2);
                s_dummy3=get_text_in_first_last_quotations(s_dummy3);
                imp_set.preprocessingCharA << s_dummy3;
                ifi.getline(dummy2,512);
                s_dummy3=QString(dummy2);
                s_dummy3=get_text_in_first_last_quotations(s_dummy3);
                imp_set.preprocessingCharB << s_dummy3;
                ifi.getline(dummy2,512);
                dint=sscanf(dummy2,"MultA= %d",&idummy);
                if (dint!=1)
                {
                //qDebug() << "Error reading MultA: " << dummy2;
                imp_set.preprocessingMultipleA << 1;
                }
                else
                {
                //qDebug() << dummy2 << "#" << dint;
                imp_set.preprocessingMultipleA << idummy;
                }
                ifi.getline(dummy2,512);
                dint=sscanf(dummy2,"MultB= %d",&idummy);
                if (dint!=1)
                {
                //qDebug() << "Error reading MultB: " << dummy2;
                imp_set.preprocessingMultipleB << 1;
                }
                else
                {
                //qDebug() << dummy2 << "#" << dint;
                imp_set.preprocessingMultipleB << idummy;
                }
                //qDebug() << "Preprocessor" << i << "Type=" << imp_set.preprocessingType.last() << "Key=" << imp_set.preprocessingKey.last() << "CharA=" << imp_set.preprocessingCharA.last() << "CharB=" << imp_set.preprocessingCharB.last() << "Set=" << imp_set.preprocessingSet.last() << "Target=" << imp_set.preprocessingTarget.last();
                }
            imp_set.trigger_channel=-1;
            ifi.getline(dummy2,512);
            dint=sscanf(dummy2,"TriggerChannel= %d",&idummy);
                if (dint==1) imp_set.trigger_channel=idummy;
            ifi.getline(dummy2,512);
            dint=sscanf(dummy2,"TriggerIsPercent= %d",&idummy);
                if (dint==1) imp_set.trigger_is_percent=(idummy==1?true:false);
            }
            else
            {
            imp_set.nr_of_preprocessors=0;
            }
        }
        else
        {
        imp_set.nr_of_counters=0;
        imp_set.nr_of_preprocessors=0;
        }
        }
    }
    ifi.close();
}

void SaveFileFormat(const char * fname,struct importSettings & imp_set)
{
    char * dummy=new char[512>strlen(fname)?512:strlen(fname)];
    strcpy(dummy,fname);
    ofstream ofi;
    ofi.open(fname);
    ofi << "Binary_Format_Info_File_V 2" << endl;
    ofi << "Header_present= " << (imp_set.header_present==true?1:0) << endl;//(chkHeader->isChecked()==true?1:0) << endl;
    ofi << "Multiple_headers= " << (imp_set.multiple_header_files==true?1:0) << endl;//(chkMultiHeaders->isChecked()==true?1:0) << endl;
    ofi << "Data_Suffix= \"" << imp_set.DataSuffix.toLocal8Bit().constData() << "\"" << endl;
    ofi << "Header_Suffix= \"" << imp_set.HeaderSuffix.toLocal8Bit().constData() << "\"" << endl;
//0=manual
//1=header in data file itself
//2=header in separate binary-data-file
//3=header in separate ini-fil
//4=header in separate ascii-file
    if (imp_set.header_format<2)
    {
    ofi << "Format_Source= " << imp_set.header_format << endl;//cmbFormatSource->currentIndex()
    ofi << "Header_Format= " << 0 << endl;//cmbHeaderFileFormat->currentIndex()
    }
    else
    {
    ofi << "Format_Source= " << 2 << endl;//cmbFormatSource->currentIndex()
    ofi << "Header_Format= " << imp_set.header_format-2 << endl;//cmbHeaderFileFormat->currentIndex()
    }
    //strcpy(dummy,tabHeader->lenEndChar->text().toLocal8Bit());
    ofi << "Line_End_Char(ASCII)= " << (int)(imp_set.string_end_char) << endl;
    ofi << "Bin_Header_Definition_Length= " << imp_set.nr_of_header_values << endl;//tabHeader->number_of_lines
    for (int i=0;i<imp_set.nr_of_header_values;i++)//tabHeader->number_of_lines;i++)
    {
        ofi << i << ":Format= \"" << binaryImportFormatName[imp_set.header_value_format[i]] << "\"" << endl;//tabHeader->inFormats[i]->cmbFormat->currentIndex()
        ofi << i << ":Size= " << imp_set.header_value_size[i] << endl;//tabHeader->inFormats[i]->spnSize->value()
        ofi << i << ":ImportAs= \"" << ImportDestinationName[imp_set.header_value_import[i]] << "\"" << endl;//tabHeader->inFormats[i]->cmbImportAs->currentText().toLatin1().constData()
    }
    ofi << "ReadUntilEOF= " << (imp_set.read_to_eof==true?1:0) << endl;//tabDataInfo->chkReadToEOF->isChecked()
    ofi << "ChannelCount= " << imp_set.channels << endl;//tabDataInfo->spnChannelCount->value()
    ofi << "NrOfDataSets= " << imp_set.points << endl;//tabDataInfo->spnDataSetCount->value()
    ofi << "SetOrderingInFile= " << imp_set.setorder << endl;//tabDataInfo->selOrder->currentIndex()
    ofi << "Trigger_Type= " << imp_set.trigger_type << endl;//tabDataInfo->selTriggerType->currentIndex()
    ofi << "Trigger_Value= " << imp_set.triggervalue << endl;//tabDataInfo->selTriggerValue->value()
    ofi << "Bin_Input_Definition_Length= " << imp_set.channels << endl;//tabDataInfo->number_of_lines
    for (int i=0;i<imp_set.channels;i++)//tabDataInfo->number_of_lines;i++)
    {
        ofi << i << ":Format= \"" << binaryImportFormatName[imp_set.channel_format[i]] << "\"" << endl;//tabDataInfo->inFormats[i]->cmbFormat->currentIndex()
        ofi << i << ":Size= " << imp_set.channel_size[i] << endl;//tabDataInfo->inFormats[i]->spnSize->value()
        ofi << i << ":ImportAs= \"" << ImportDestinationName[imp_set.channel_target[i]] << "\"" << endl;//tabDataInfo->inFormats[i]->cmbImportAs->currentText().toLatin1().constData()
    }
    ofi << "Import_Set_As= " << imp_set.set_type << endl;//tabImportInfo->selType->currentValue() << endl;
    ofi << "Autoscale= " << imp_set.autoscale << endl;
/*int count_set_tokens=0;
for (int i=0;i<tabHeader->nr_of_sels;i++)
{
    if (tabHeader->sels[i]->currentValue()!=IMPORT_TO_NONE)
    {
    count_set_tokens++;
    }
}*/
    //ofi << "INI-Import-Tokens= " << count_set_tokens << endl;
    ofi << "INI-Import-Tokens= " << imp_set.keys.length() << endl;
/*for (int i=0;i<tabHeader->nr_of_sels;i++)
{
    if (tabHeader->sels[i]->currentValue()!=IMPORT_TO_NONE)
    {
    ofi << tabHeader->keys.at(i).toLocal8Bit().constData() << " = \"" << ImportDestinationName[tabHeader->sels[i]->currentValue()] << "\"" << endl;
    }
}
*/

/*cout << "KEYS=" << imp_set.keys.length() << endl;
cout << "Channel Destinations=" << imp_set.import_channel_dest.length() << endl;
cout << "Destinations=" << imp_set.import_dest.length() << endl;*/

    for (int i=0;i<imp_set.keys.length();i++)
    {
    //cout << "imp_set.token_target[" << i << "]=#" << imp_set.token_target[i] << "# imp_set.import_dest=" << imp_set.import_dest.at(i) << endl;
    //ofi << imp_set.import_channel_dest.at(i) << " " << imp_set.keys.at(i).toLocal8Bit().constData() << " = \"" << ImportDestinationName[imp_set.token_target[i]] << "\"" << endl;
    ofi << imp_set.import_channel_dest.at(i) << " " << imp_set.keys.at(i).toLocal8Bit().constData() << " = \"" << ImportDestinationName[imp_set.import_dest.at(i)] << "\"" << endl;
    }
    ofi << "Data-Compression= " << imp_set.data_is_compressed << endl;
    ofi << "NrOfCounters= " << imp_set.nr_of_counters << endl;
    for (int i=0;i<imp_set.nr_of_counters;i++)
    {
    ofi << "Counter " << i << endl;
    ofi << "Type= " << imp_set.counterTypes.at(i) << endl;
    ofi << "Section= \"" << imp_set.counterSections.at(i).toLocal8Bit().constData() << "\"" << endl;
    ofi << "Text= \"" << imp_set.counterText.at(i).toLocal8Bit().constData() << "\"" << endl;
    ofi << "Set= " << imp_set.counterSets.at(i) << endl;
    ofi << "Target= \"" << ImportDestinationName[imp_set.counterTargets.at(i)] << "\"" << endl;
    }
    ofi << "NrOfPreprocessors= " << imp_set.nr_of_preprocessors << endl;
    for (int i=0;i<imp_set.nr_of_preprocessors;i++)
    {
    ofi << "Preprocessor " << i << endl;
    ofi << "Type= " << imp_set.preprocessingType.at(i) << endl;
    ofi << "Key= \"" << imp_set.preprocessingKey.at(i).toLocal8Bit().constData() << "\"" << endl;
    ofi << "Set= " << imp_set.preprocessingSet.at(i) << endl;
    ofi << "Target= \"" << ImportDestinationName[imp_set.preprocessingTarget.at(i)] << "\"" << endl;
    ofi << "CharA= \"" << imp_set.preprocessingCharA.at(i).toLocal8Bit().constData() << "\"" << endl;
    ofi << "CharB= \"" << imp_set.preprocessingCharB.at(i).toLocal8Bit().constData() << "\"" << endl;
    ofi << "MultA= " << imp_set.preprocessingMultipleA.at(i) << endl;
    ofi << "MultB= " << imp_set.preprocessingMultipleB.at(i) << endl;
    }
    ofi << "TriggerChannel= " << imp_set.trigger_channel << endl;
    ofi << "TriggerIsPercent= " << (imp_set.trigger_is_percent==true?1:0) << endl;
    ofi.close();

delete[] dummy;
}

/*void matchSchemeToHeader(char * fname,struct importSettings & imp_set,struct importSettings & imp_scheme)
{

}*/

void frmBinaryFormatInput::newFileEntry(void)
{
QStringList str;
QString tmp;
bool is_header;
bool header_reread=false;
int guessed_schema;
bool guessing_failed=false;
bin_file_nr_to_import=0;
//cout << "New File Entry" << endl;
    if (actautoguess->isChecked())//this means: guess format, complete data- and header-names and try reading the header
    {
    //qDebug() << "autoguessing" << lenDataFile->text();
        if (!lenDataFile->text().isEmpty())
        {
        readAndCompleteFileNames(0,guessed_schema,is_header);
            if (guessed_schema>=0 && is_header==true)//we guess, that the file is actually a header-file in the data-line
            {
            lenHeaderFile->blockSignals(true);
            lenHeaderFile->lenText->setText(lenDataFile->lenText->text());
            lenHeaderFile->blockSignals(false);
            readAndCompleteFileNames(1,guessed_schema,is_header);
                str=lenHeaderFile->text().split(QString(";"));
                //if (lenDataFile->text().isEmpty())
                lenDataFile->lenText->setText(datFileNames.join(QString(";")));
                cur_import_scheme=guessed_schema;//detectStdBinFormat(str.at(0));
            }
            else
            {
            str=lenDataFile->text().split(QString(";"));
            if (lenHeaderFile->text().isEmpty()) lenHeaderFile->lenText->setText(headerFileNames.join(QString(";")));
            cur_import_scheme=guessed_schema;//detectStdBinFormat(str.at(0));
            }
        }
        else if (!lenHeaderFile->text().isEmpty())
        {
        readAndCompleteFileNames(1,guessed_schema,is_header);
    //qDebug() << "guessed_schema=" << guessed_schema << "is_header=" << is_header << "datFiles=" << datFileNames;
            if (guessed_schema>=0 && is_header==false)//we guess, that the file is actually a data-file in the header-line
            {
            lenDataFile->blockSignals(true);
            lenDataFile->lenText->setText(lenHeaderFile->lenText->text());
            lenDataFile->blockSignals(false);
            readAndCompleteFileNames(0,guessed_schema,is_header);
    //qDebug() << "after switch: guessed_schema=" << guessed_schema << "is_header=" << is_header << "datFiles=" << datFileNames;
                str=lenDataFile->text().split(QString(";"));
                //if (lenHeaderFile->text().isEmpty())
                lenHeaderFile->lenText->setText(headerFileNames.join(QString(";")));
                cur_import_scheme=guessed_schema;//detectStdBinFormat(str.at(0));
            }
            else
            {
            str=lenHeaderFile->text().split(QString(";"));
            if (lenDataFile->text().isEmpty()) lenDataFile->lenText->setText(datFileNames.join(QString(";")));
            cur_import_scheme=guessed_schema;//detectStdBinFormat(str.at(0));
            }
        }
        else//header- and data-file-names are already set --> just read the set names
        {
        readAndCompleteFileNames(2,guessed_schema,is_header);
        }
    //qDebug() << "Guessed Schema=" << guessed_schema;
        if (guessed_schema<0) guessing_failed=true;
        else guessing_failed=false;
    }
    else//do not autoguess --> just read the file-entries
    {
    //cout << "no autoguessing" << endl;
        readAndCompleteFileNames(2,guessed_schema,is_header);
        guessing_failed=true;
    }
/// now we have set up the file-lists:
/// datFileNames
/// headerFileNames
/// and the bin_file_nr_to_import index to use for import

        if (cur_import_scheme>=0 || cur_import_scheme==-2)//a regular scheme --> we delete everything first, because we can copy everything back in later!
        initSettings(imp_scheme);

    //first: set the new filenames
    if (datFileNames.length()>0 && headerFileNames.length()>0)
    insert_filenames_in_settings(imp_set,imp_scheme,headerFileNames.at(0),datFileNames.at(0));
    else if (datFileNames.length()>0 && headerFileNames.length()<=0)
    insert_filenames_in_settings(imp_set,imp_scheme,QString(""),datFileNames.at(0));
    else if (datFileNames.length()<=0 && headerFileNames.length()>0)
    insert_filenames_in_settings(imp_set,imp_scheme,headerFileNames.at(0),QString(""));

    if (cur_import_scheme!=-1)//there already is an import schema --> we should try to load the header informations
    {
    //cout << "There have been settings before" << endl;
    //cout << "current data-file: " << datFileNames.at(bin_file_nr_to_import).toLocal8Bit().constData() << endl;
    //cout << "current header-file: " << headerFileNames.at(bin_file_nr_to_import).toLocal8Bit().constData() << endl;
        if (cur_import_scheme>=0)//one of the std-settings
        {
        copy_import_settings(std_bin_import_settings+cur_import_scheme,&imp_scheme);
        }
        else if (cur_import_scheme==-2)
        {
        QByteArray ba=FormatFileLastUsed.toLocal8Bit();
        char * files=new char[8+ba.length()];
        strcpy(files,ba.constData());
        LoadFileFormat(files,imp_scheme);///load the import settings in the scheme
        delete[] files;
        }
//qDebug() << "After Initiing Schema";
//qDebug() << "NrOfCounters=" << imp_scheme.nr_of_counters;
//qDebug() << "NrOfPreprocessors=" << imp_scheme.nr_of_preprocessors;
        //cout << "(Re)read header data from " << imp_set.HeaderFile.toLocal8Bit().constData() << endl;
            if (imp_scheme.header_format==1 || imp_scheme.header_format==2)///real binary header
            {
            read_BINARY_header(imp_set,imp_scheme);
            header_reread=true;
            }
            else if (imp_scheme.header_format==3)//ini header
            {
            read_INI_header(imp_set,imp_scheme);
            header_reread=true;
            }
            else if (imp_scheme.header_format==4)//ascii-header
            {
            read_ASCII_header(imp_set,imp_scheme);
            header_reread=true;
            }
            else if (imp_scheme.header_format==0)//manual header
            {
            copy_basic_scheme_data(imp_set,imp_scheme);
            }
        //cout << "finished reading Header" << endl;
    }

    if (cur_import_scheme==-1)
    {
    lblCurScheme->setText(tr("Current import scheme: None"));
    }
    else if (cur_import_scheme==-2)
    {
    lblCurScheme->setText(tr("Current import scheme: Manual"));
    }
    else
    {
    lblCurScheme->setText(tr("Current import scheme: ")+std_bin_import_settings[cur_import_scheme].name);
    }

/*qDebug() << "After Guessing Schema";
qDebug() << "NrOfCounters=" << imp_set.nr_of_counters;
qDebug() << "NrOfPreprocessors=" << imp_set.nr_of_preprocessors;
qDebug() << "ReadToEOF=" << imp_set.read_to_eof;
qDebug() << "Compression=" << imp_set.data_is_compressed;*/

    tabDataInfo->chkReadToEOF->setChecked(imp_set.read_to_eof);
    tabDataInfo->selDataCompressed->setMethod(imp_set.data_is_compressed);
    tabDataInfo->selTriggerSet->setCurrentIndex(imp_set.trigger_channel);
    tabDataInfo->selTriggerType->setCurrentValue(imp_set.trigger_type);
//qDebug() << "TriggerType=" << imp_set.trigger_type << "SetOrder" << imp_set.setorder;
    tabDataInfo->selOrder->setCurrentIndex(imp_set.setorder);
    tmp=QString::number(imp_set.triggervalue);
    if (imp_set.trigger_is_percent==true) tmp+=QString(" %");
    tabDataInfo->selTriggerValue->setText(tmp);
    tabImportInfo->selAutoscale->setCurrentValue(imp_set.autoscale);

        if (guessing_failed==false && (actautoguess->isChecked() || header_reread==true))// && (imp_set.header_format==1 || imp_set.header_format==2))
        {
        //cout << "transfer imported header values to gui" << endl;

        tabHeader->write_header_settings(imp_set);
        transmitInfos();

        }
}

void frmBinaryFormatInput::SelectDataFile(void)
{
QStringList str;
/*bool is_header;
int guessed_schema;*/

    if (!LoadDataPath.isEmpty())
    str=QFileDialog::getOpenFileNames(this,tr("Select Data File(s)"),LoadDataPath);
    else
    str=QFileDialog::getOpenFileNames(this,tr("Select Data File(s)"),QString(user_home_dir));

    if (str.length()>0)
    {
        bin_file_nr_to_import=0;
        datFileNames=str;
        headerFileNames=str;

        QString filesText=str.join(QString(";"));
        lenDataFile->lenText->setText(filesText);
        QFileInfo tmpInfo(str.at(0));
        LoadDataPath=tmpInfo.path();

        newFileEntry();

        /*if (chkAutoGuessFormat->isChecked())
        {
        readAndCompleteFileNames(0,guessed_schema,is_header);

        if (lenHeaderFile->text().isEmpty()) lenHeaderFile->lenText->setText(headerFileNames.join(QString(";")));

        //char * filename=new char[8+str.at(0).length()];
        //strcpy(filename,str.at(0).toLocal8Bit().constData());
        cur_import_scheme=detectStdBinFormat(str.at(0));
            if (cur_import_scheme==-1)
            {
            lblCurScheme->setText(tr("Current scheme: None"));
            }
            else
            {
            lblCurScheme->setText(tr("Current scheme: ")+std_bin_import_settings[cur_import_scheme].name);
            }
        //delete[] filename;
        }*/
    }
}

void frmBinaryFormatInput::SelectHeaderFile(void)
{
QStringList str;
/*bool is_header;
int guessed_schema;*/

    if (!LoadIniPath.isEmpty())
    str=QFileDialog::getOpenFileNames(this,tr("Select Header File(s)"),LoadIniPath);
    else
    str=QFileDialog::getOpenFileNames(this,tr("Select Header File(s)"),QString(user_home_dir));

    if (!str.isEmpty())
    {
        bin_file_nr_to_import=0;//we may have more than one, but we operate on the first one
        //datFileNames=str;
        headerFileNames=str;//the header Filenames (a list)

        QString filesText=str.join(QString(";"));//combine the separate files into one line of text (separated by ';')
        lenHeaderFile->lenText->setText(filesText);
        QFileInfo tmpInfo(str.at(0));
        LoadIniPath=tmpInfo.path();//so we can load the binary data from the same doirectory next time

        newFileEntry();

        /*if (chkAutoGuessFormat->isChecked())
        {
        readAndCompleteFileNames(1,guessed_schema,is_header);

        if (lenDataFile->text().isEmpty()) lenDataFile->lenText->setText(datFileNames.join(QString(";")));

        //char * filename=new char[8+str.at(0).length()];
        //strcpy(filename,str.at(0).toLocal8Bit().constData());
        cur_import_scheme=detectStdBinFormat(str.at(0));
            if (cur_import_scheme==-1)
            {
            lblCurScheme->setText(tr("Current scheme: None"));
            }
            else
            {
            lblCurScheme->setText(tr("Current scheme: ")+std_bin_import_settings[cur_import_scheme].name);
            }
        //delete[] filename;
        }*/
    }
}

int frmBinaryFormatInput::detectStdBinFormat(QString filen)
{
bool is_header_file;
int std_schema_nr=-1;
    //cout << "guess " << filen.toLocal8Bit().constData() << endl;
    if (guess_bin_format(filen.toLocal8Bit().constData(),std_schema_nr,is_header_file)==RETURN_SUCCESS)//look for a std binary format
    {
        initSettings(imp_set);
    if (std_bin_import_settings[std_schema_nr].header_format==1 || std_bin_import_settings[std_schema_nr].header_format==2)///real binary header
    {
    copy_import_settings(std_bin_import_settings+std_schema_nr,&imp_set);
    }
    else if (std_bin_import_settings[std_schema_nr].header_format==0)//manual header
    {
    copy_basic_scheme_data(imp_set,std_bin_import_settings[std_schema_nr]);
    }
        if (std_bin_import_settings[std_schema_nr].header_present)//there should be a header
        {
            if (is_header_file==false)
            {
            imp_set.DataFile=filen;
            imp_set.HeaderFile=imp_set.DataFile;
            replaceSuffix(imp_set.HeaderFile,std_bin_import_settings[std_schema_nr].HeaderSuffix);
            }
            else
            {
            imp_set.HeaderFile=filen;
            imp_set.DataFile=imp_set.HeaderFile;
            replaceSuffix(imp_set.DataFile,std_bin_import_settings[std_schema_nr].DataSuffix);
            }
            if (std_bin_import_settings[std_schema_nr].header_format==1)
            imp_set.HeaderFile=imp_set.DataFile;
        }
        else//no header
        {
        imp_set.DataFile=filen;
        imp_set.HeaderFile=QString("");
        }
    //cout << "read bin files:" << endl;
    //cout << "Header-File=#" << imp_set.HeaderFile.toLocal8Bit().constData() << "#" << endl;
    //cout << "Data - File=#" << imp_set.DataFile.toLocal8Bit().constData() << "#" << endl;
        if (lenDataFile->text().isEmpty())
        {
        lenDataFile->setText(imp_set.DataFile);
        }
        if (lenHeaderFile->text().isEmpty() && std_bin_import_settings[std_schema_nr].header_present && std_bin_import_settings[std_schema_nr].header_format>=2)
        {
        lenHeaderFile->setText(imp_set.HeaderFile);
        }
    if (std_bin_import_settings[std_schema_nr].header_format==3)
    {
        //cout << "Start reading reading INI header" << endl;
    read_INI_header(imp_set,std_bin_import_settings[std_schema_nr]);
        //cout << "Finished reading INI header" << endl;
    displaySettings(imp_set);
    qApp->processEvents();
    tabHeader->doReadIni();
    }
    else if (std_bin_import_settings[std_schema_nr].header_format==1 || std_bin_import_settings[std_schema_nr].header_format==2)
    {
        //cout << "Start reading reading BIN header" << endl;
    read_BINARY_header(imp_set,std_bin_import_settings[std_schema_nr]);
        //cout << "Finished reading BIN header" << endl << endl;
    displaySettings(imp_set);
    qApp->processEvents();
    /// tabHeader->doTestLoad();
    }
    /// TODO: Format pruefen!
    //tabHeader->write_header_settings(imp_set);//scheint ok
    //displaySettings(imp_set);
    tabDataInfo->writeDataSettings(imp_set);//copy the settings into the gui
    tabImportInfo->write_settings(imp_set);
    return std_schema_nr;
    }
    else return -1;
}

void frmBinaryFormatInput::formatSourceChanged(int i)
{
    //tabHeader->changeRepresentation(i);
    HeaderFormatChanged(i);
    /*
    if (i==0 || i==1)
    {
        //lblHeaderFile->setEnabled(false);
        lenHeaderFile->setEnabled(false);
        lblHeaderFileFormat->setEnabled(false);
        cmbHeaderFileFormat->setEnabled(false);
        if (cmbHeaderFileFormat->currentIndex()==1)
            cmbHeaderFileFormat->setCurrentIndex(0);
        cmdSelectHeaderFile->setEnabled(false);
        chkMultiHeaders->setVisible(false);
    }
    else if (i==2)
    {
        //lblHeaderFile->setEnabled(true);
        lenHeaderFile->setEnabled(true);
        lblHeaderFileFormat->setEnabled(true);
        cmbHeaderFileFormat->setEnabled(true);
        cmdSelectHeaderFile->setEnabled(true);
        chkMultiHeaders->setVisible(true);
    }*/
}

void frmBinaryFormatInput::CreateActions(void)
{
actLoadSettings=new QAction(tr("Load Import Settings"),this);
actLoadSettings->setStatusTip(tr("Load import settings from file"));
connect(actLoadSettings, SIGNAL(triggered()), this, SLOT(doLoadFileFormat()));
actSaveSettings=new QAction(tr("Save Import Settings"),this);
actSaveSettings->setStatusTip(tr("Save import settings to file"));
connect(actSaveSettings, SIGNAL(triggered()), this, SLOT(doSaveFileFormat()));
actLoadStdSettings=new QAction(tr("Load Std. Import Settings"),this);
actLoadStdSettings->setStatusTip(tr("Load automatic import settings from std. file"));
connect(actLoadStdSettings, SIGNAL(triggered()), this, SLOT(doLoadStdFormat()));
actSaveStdSettings=new QAction(tr("Save Std. Import Settings"),this);
actSaveStdSettings->setStatusTip(tr("Save automatic import settings to std. file"));
connect(actSaveStdSettings, SIGNAL(triggered()), this, SLOT(doSaveStdFormat()));
actDeleteSettings=new QAction(tr("Clear current import scheme"),this);
actDeleteSettings->setStatusTip(tr("Clear current import setting scheme"));
connect(actDeleteSettings, SIGNAL(triggered()), this, SLOT(doClearCurrentScheme()));
actClose=new QAction(tr("Close"),this);
actClose->setStatusTip(tr("Close dialog"));
connect(actClose, SIGNAL(triggered()), this, SLOT(doClose()));
actautoguess=new QAction(tr("Auto-guess binary file format"),this);
actautoguess->setStatusTip(tr("Try to guess the file format by comparing the suffix with the std. import settings"));
actautoguess->setCheckable(true);

actLoadDataFile=new QAction(tr("Select binary data file(s)"),this);
actLoadDataFile->setStatusTip(tr("Browse for binary data file(s) to import"));
connect(actLoadDataFile, SIGNAL(triggered()), this, SLOT(SelectDataFile()));
actLoadHeaderFile=new QAction(tr("Select header file(s)"),this);
actLoadHeaderFile->setStatusTip(tr("Browse for header file(s) with import informations"));
connect(actLoadHeaderFile, SIGNAL(triggered()), this, SLOT(SelectHeaderFile()));
}

void frmBinaryFormatInput::init(void)
{
    //QLocale newLocale=(DecimalPointToUse=='.')?(*dot_locale):(*comma_locale);
    //tabDataInfo->selTriggerValue->spnLineWidth->setLocale(newLocale);
    tabDataInfo->selTriggerValue->ReplaceNumberContents();
    update_all();
    int nr=1,*sel=new int[2];
    sel[0]=get_cg();
    tabImportInfo->importGraph->set_new_selection(nr,sel);
}

void frmBinaryFormatInput::doOK(void)
{
ApplyError=false;
int schema_nr_dummy;
bool header_dummy;
bool sav_autoguess=actautoguess->isChecked();
actautoguess->setChecked(false);
/*int nr_of_new_sets=0;
int *n_snos=NULL,*n_gnos=NULL;
int gen_nr_of_new_sets=0;
int *gen_n_snos=NULL,*gen_n_gnos=NULL;*/
//ifstream ifi;
if (lenDataFile->text().isEmpty())
{
errmsg(QObject::tr("Please select at least one binary file to read!").toLocal8Bit().constData());
actautoguess->setChecked(sav_autoguess);
return;
}
set_wait_cursor();
//read the file-names set
readAndCompleteFileNames(2,schema_nr_dummy,header_dummy);
/// check for multiple headers (yes/no)
/// --> if multiple headers selected: the number of header files have to match the number of data files
/// --> if no multiple headers: only the first header will be used for all files
/// BEACHTE: option header present=false oder headerformat=manuel --> ignoriere header

/*cout << "OK: we have read the header- and data-files: headers nr=" << datFileNames.length() << " datas nr=" << headerFileNames.length() << endl;
for (int i=0;i<datFileNames.length();i++)
{
qDebug() << datFileNames.at(i);
}*/
//cout << "now we have to read the schema from the gui" << endl;
readSettings(imp_scheme,3);
//cout << "apply the schema to loading every file" << endl;

for (int i=0;i<datFileNames.length();i++)
{
copy_bin_settings_to_current_bin_import(datFileNames.at(i),false,&imp_scheme);
insert_filenames_in_settings(current_bin_import_settings,imp_scheme,headerFileNames.at(i),datFileNames.at(i));
readHeaderData(current_bin_import_settings,imp_scheme);

/// for debugging
//SaveFileFormat("/Users/andreaswinter/akt_bin_settings.fmt",current_bin_import_settings);/// just save for testing
/// end debugging

    if (i==datFileNames.length()-1)
    read_bin_file_by_current_settings(false);
    else
    read_bin_file_by_current_settings(true);

/// binary_load_Phase1(headerFileNames.at(i),datFileNames.at(i),imp_set,imp_scheme);//initialize and load header to imp_set
//insert_filenames_in_settings(imp_set,imp_scheme,headerFileNames.at(i),datFileNames.at(i));
/// copy_import_settings(&imp_scheme,&imp_set);
//CopyBinaryImportSettings(imp_scheme,imp_set);
/// ifi.open(imp_set.DataFile.toLocal8Bit().constData(),ios::binary);
/// readBinaryFromFile(ifi,imp_set,&imp_set.first_data);
/// ifi.close();
/// cout << "Postprocessing: " << postprocess_bin_import_data(imp_set,nr_of_new_sets,&n_gnos,&n_snos) << endl;
/// append_to_storage2(&gen_nr_of_new_sets,&gen_n_snos,&gen_n_gnos,nr_of_new_sets,n_gnos,n_snos);
}
actautoguess->setChecked(sav_autoguess);
unset_wait_cursor();
}

void frmBinaryFormatInput::doClose(void)
{
    hide();
}

void frmBinaryFormatInput::doAccept(void)
{
    doOK();
    if (ApplyError==false)
        doClose();
}

/*void frmBinaryFormatInput::binary_load_Phase0(int stage,struct importSettings & imp_scheme)
{
    switch (stage)
    {
    case 0:
    break;
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    }
}*/

void frmBinaryFormatInput::getDatFilesFromString(QString * origin,QStringList * lst)
{
    (*lst).clear();
    (*lst)=origin->split(QString(";"));
    if (lst->length()>0)
    {
        QString dummy;
        QChar sep=QDir::separator();
        QString dir=lst->at(0).left(lst->at(0).lastIndexOf(sep));
        //cout << "dir=#" << dir.toLocal8Bit().constData() << "#" << endl;
        for (int i=1;i<lst->length();i++)
        {
            if (lst->at(i).contains(sep)==false)
            {
                dummy=lst->at(i);
                lst->replace(i,dir+sep+dummy);
            }
        }
    }
    //cout << lst->at(0).toLocal8Bit().constData() << endl;
}

void frmBinaryFormatInput::readAndCompleteFileNames(int dat_header,int & std_schema_nr,bool & is_header_file)
{
std_schema_nr=-1;
QStringList str;
QString t_str;
QStringList matchList;
int ret_val;

if (dat_header==0)//read from dat-files-line and complete header-filename(s) if possible
{
str=lenDataFile->text().split(";");
datFileNames=str;
headerFileNames.clear();
    for (int i=0;i<str.length();i++)
    {
        t_str=str.at(i);
    //cout << "Data: guess " << str.at(i).toLocal8Bit().constData() << endl;
    ret_val=find_std_format_and_matching_files(str.at(i),std_schema_nr,matchList,is_header_file);
        //if (guess_bin_format(str.at(i).toLocal8Bit().constData(),std_schema_nr,is_header_file)==RETURN_SUCCESS)//look for a std binary format
    //qDebug() << "guessing: ret_val=" << ret_val << "std_schema_nr=" << std_schema_nr << "is_header_file=" << is_header_file << "matchList=" << matchList;
        if (ret_val==RETURN_SUCCESS && matchList.length()>0)
        {
        //cout << "guessed=" << std_schema_nr << " is_header_file=" << is_header_file << endl;
            /*if (std_bin_import_settings[std_schema_nr].HeaderSuffix==QString("-"))
            replaceSuffix(t_str,std_bin_import_settings[std_schema_nr].DataSuffix);
            else
            replaceSuffix(t_str,std_bin_import_settings[std_schema_nr].HeaderSuffix);*/
        t_str=matchList.at(0);
        headerFileNames << t_str;
        }
        else if (ret_val==RETURN_SUCCESS && std_bin_import_settings[std_schema_nr].header_present==true && std_bin_import_settings[std_schema_nr].header_format==1)
        {
        headerFileNames << str.at(i);
        }
        else
        {
        errmsg(QObject::tr("Could not guess format.").toLocal8Bit().constData());
        //cout <<  << endl;
        }
            if (i==0 && chkMultiHeaders->isChecked()==false)
            break;
    }
    //qDebug() << "Guessed Header-Files=" << headerFileNames;
    //we just have data-file(s) with header included --> transfer data-file-names into header-file-section
    if (ret_val==RETURN_SUCCESS && std_bin_import_settings[std_schema_nr].header_present==true && std_bin_import_settings[std_schema_nr].header_format==1)
    {
    lenHeaderFile->blockSignals(true);
    lenHeaderFile->setText(lenDataFile->text());
    lenHeaderFile->blockSignals(false);
    }
    else if (ret_val==RETURN_SUCCESS && headerFileNames.length()>0)
    {
    lenHeaderFile->blockSignals(true);
    lenHeaderFile->lenText->setText(headerFileNames.join(QString(";")));
    lenHeaderFile->blockSignals(false);
    }

}
else if (dat_header==1)//read from header-files-line and complete data-filename(s) if possible
{
str=lenHeaderFile->text().split(";");
headerFileNames=str;
datFileNames.clear();
    for (int i=0;i<str.length();i++)
    {
        t_str=str.at(i);
        ret_val=find_std_format_and_matching_files(str.at(i),std_schema_nr,matchList,is_header_file);
    //qDebug() << "Header: guess " << str.at(i).toLocal8Bit().constData() << "matchList=" << matchList << endl;
        //if (guess_bin_format(str.at(i).toLocal8Bit().constData(),std_schema_nr,is_header_file)==RETURN_SUCCESS)//look for a std binary format
        if (ret_val==RETURN_SUCCESS)
        {
        //cout << "guessed=" << std_schema_nr << " is_header_file=" << is_header_file << endl;
        //replaceSuffix(t_str,std_bin_import_settings[std_schema_nr].DataSuffix);
        //datFileNames << t_str;
            for (int k=0;k<matchList.length();k++)
            datFileNames << matchList.at(k);
        }
        else
        {
        errmsg(QObject::tr("Could not guess format.").toLocal8Bit().constData());
        }
    }
//qDebug() << "datFileNames=" << datFileNames;
}
else//read both header- and dat-file-line
{
str=lenDataFile->text().split(";");
datFileNames=str;
str=lenHeaderFile->text().split(";");
headerFileNames=str;
}

if (datFileNames.length() != headerFileNames.length())
{
    if (chkMultiHeaders->isChecked()==true)//a separate file for every datfile is requested
    {
        if (headerFileNames.length()==1)
        {
        while (headerFileNames.length()<datFileNames.length()) headerFileNames << headerFileNames.at(0);
        }
        else if (headerFileNames.length()>0)
        {
        errmsg(tr("Number of header-files does not match number of data-files.").toLocal8Bit().constData());
        }
    }
    else if (headerFileNames.length()>0)
    {
        while (headerFileNames.length()<datFileNames.length()) headerFileNames << headerFileNames.at(0);
    }
}

bin_file_nr_to_import=0;//set current file name to first in the list
}

void frmBinaryFormatInput::CheckHeadersAndDatFiles(void)
{
//cout << "Checking Headers and DataFiles" << endl;
int nr_of_datafiles=datFileNames.length();
//cout << "nr_of_datafiles=" << nr_of_datafiles << endl;
int nr_of_headerfiles=headerFileNames.length();
//cout << "nr_of_headerfiles=" << nr_of_headerfiles << endl;
HeaderSuffix.clear();
Data_Suffix.clear();
HeaderPath.clear();
Data_Path.clear();
    if (nr_of_datafiles>0)
    {
    QFileInfo fi(datFileNames.at(0));
    Data_Suffix=fi.suffix();
    Data_Path=fi.absolutePath()+QDir::separator();
    //strcpy(datFileName,datFileNames.at(0).toLocal8Bit().constData());
    }

    if (nr_of_headerfiles>0)
    {
    QFileInfo fi(headerFileNames.at(0));
    HeaderSuffix=fi.suffix();
    HeaderPath=fi.absolutePath()+QDir::separator();
    //strcpy(headerFileName,headerFileNames.at(0).toLocal8Bit().constData());
    }
    else//no header file set - but maybe there should be one
    {
    HeaderSuffix.clear();
    HeaderPath.clear();
    //strcpy(headerFileName,"");
        if (imp_set.header_present==true && imp_set.header_format>=2)//no headers, but there should be one in a separate file
        {
            HeaderPath=Data_Path;
            HeaderSuffix=imp_set.HeaderSuffix;
        }
    }

/*cout << "HeaderSuffix = " << HeaderSuffix.toLocal8Bit().constData() << endl;
cout << "HeaderPath   = " << HeaderPath.toLocal8Bit().constData() << endl;
cout << "DataSuffix   = " << Data_Suffix.toLocal8Bit().constData() << endl;
cout << "DataPath     = " << Data_Path.toLocal8Bit().constData() << endl;*/

//datFileNames.clear();
//headerFileNames.clear();
        imp_set.HeaderSuffix=HeaderSuffix;
        imp_set.DataSuffix=Data_Suffix;
    if (nr_of_headerfiles!=nr_of_datafiles && imp_set.multiple_header_files==true)//not matching number of headerfiles, but there should be as many headers as data files
    {
        if (imp_set.header_format==HEADER_FORMAT_DATA_FILE || imp_set.header_format==HEADER_FORMAT_MANUAL)//header in data file or no header at all
        {
            HeaderSuffix.clear();
            HeaderPath.clear();
            //strcpy(headerFileName,"");
            headerFileNames.clear();
        }
        else if (imp_set.header_format==HEADER_FORMAT_BIN_FILE || imp_set.header_format==HEADER_FORMAT_INI_FILE || imp_set.header_format==HEADER_FORMAT_ASCII_FILE)//separate bin-, ini-file or ascii-file
        {
            headerFileNames.clear();
            for (int i=0;i<nr_of_datafiles;i++)
            {
            QFileInfo fi(datFileNames.at(i));
            if (HeaderSuffix==QString("-"))
            headerFileNames << HeaderPath+fi.completeBaseName()+QString(".")+Data_Suffix;
            else
            headerFileNames << HeaderPath+fi.completeBaseName()+QString(".")+HeaderSuffix;
            //cout << "newHeader=" << headerFileNames.at(i).toLocal8Bit().constData() << endl;
            }
        }
    }
    else if (imp_set.multiple_header_files==false)//we make the number of headers match the number of data files by just copying the same header name again and again
    {
        if (nr_of_headerfiles<=0)
        {
        headerFileNames.clear();
        QFileInfo fi(datFileNames.at(0));
        if (HeaderSuffix==QString("-"))
        headerFileNames << HeaderPath+fi.completeBaseName()+QString(".")+Data_Suffix;
        else
        headerFileNames << HeaderPath+fi.completeBaseName()+QString(".")+HeaderSuffix;
        }
        for (int i=1;i<nr_of_datafiles;i++)
        {
        headerFileNames.replace(i,headerFileNames.at(0));
        }
    }
}

void frmBinaryFormatInput::readHeader(void)
{
if (imp_scheme.header_present)
{
    if (imp_scheme.header_format==1 || imp_scheme.header_format==2)//bin-header in data-file or separate bin-file
    {
        //cout << "reading binary header from file" << endl;
    read_BINARY_header(imp_set,imp_scheme);
        //cout << "nach reading binary header" << endl;
    }
    else if (imp_scheme.header_format==3)//ini-header in separate file
    {
    read_INI_header(imp_set,imp_scheme);
    }
    else if (imp_scheme.header_format==4)//ascii-header in separate file
    {
    read_ASCII_header(imp_set,imp_scheme);
    }
}
//else: no header present, all settings should be in the scheme
}

void frmBinaryFormatInput::headerToggled(bool t)
{
    if (t)
    {
        //cmbFormatSource->setCurrentIndex(1);
        tabHeader->setEnabled(true);
        //lblHeaderFile->setVisible(true);
        lenHeaderFile->setVisible(true);
        cmdSelectHeaderFile->setVisible(true);
        cmbHeaderFileFormat->setVisible(true);
        lblHeaderFileFormat->setVisible(true);
    }
    else
    {
        //cmbFormatSource->setCurrentIndex(0);
        tabHeader->setEnabled(false);
        //lblHeaderFile->setVisible(false);
        lenHeaderFile->setVisible(false);
        cmdSelectHeaderFile->setVisible(false);
        cmbHeaderFileFormat->setVisible(false);
        lblHeaderFileFormat->setVisible(false);
    }
}

void frmBinaryFormatInput::updateSuffixes(void)
{
    QString d_inp=lenDataFile->text();
    QStringList l_inp=d_inp.split(";");
//qDebug() << "Data l_inp.length=" << l_inp.length();
    if (l_inp.length()>0)
    {
    QFileInfo fi1(l_inp.at(0));
    Data_Suffix=fi1.suffix();
    }
    else// if (imp_set.DataSuffix.isEmpty())
    {
    Data_Suffix=QString("-");
    }
//cout << "Data-suffix=#" << Data_Suffix.toLocal8Bit().constData() << "#" << endl;
    d_inp=lenHeaderFile->text();
    l_inp=d_inp.split(";");
//cout << "Header l_inp.length=" << l_inp.length() << endl;
    if (l_inp.length()>0)
    {
    QFileInfo fi1(l_inp.at(0));
    HeaderSuffix=fi1.suffix();
    }
    else// if (imp_set.HeaderSuffix.isEmpty())
    {
    HeaderSuffix=QString("-");
    }
//cout << "Header-suffix=#" << HeaderSuffix.toLocal8Bit().constData() << "#" << endl;
}

int find_std_format_and_matching_files(QString filename,int & std_format_nr, QStringList & list, bool & is_header)
{
list.clear();
std_format_nr=-1;
QList<int> def_format_match;
QList<bool> def_format_match_header;
QList<bool> def_format_match_incomplete;
def_format_match_header.clear();
def_format_match.clear();
def_format_match_incomplete.clear();
QFileInfo fi(filename);
QString t_suffix=fi.suffix();
//qDebug() << "t_suffix=" << t_suffix;
//first: we find every binary-format that MAY match the filename (or its suffix)
for (int i=0;i<nr_of_std_bin_import_settings;i++)
{
    //qDebug() << "Nr=" << i << "stdFormat=" << std_bin_import_settings[i].name;
    //qDebug() << "HeaderPresent=" << std_bin_import_settings[i].header_present << "HeaderType=" << std_bin_import_settings[i].header_format;
    //qDebug() << "Data=" << std_bin_import_settings[i].DataSuffix << "Header=" << std_bin_import_settings[i].HeaderSuffix;
    //qDebug() << "Counter=" << std_bin_import_settings[i].nr_of_counters;
    if (std_bin_import_settings[i].HeaderSuffix==t_suffix && std_bin_import_settings[i].header_present && std_bin_import_settings[i].header_format>1)//separate header-file searched and present
    {
    def_format_match << i;
    def_format_match_header << true;
    def_format_match_incomplete << true;
    }
    if (std_bin_import_settings[i].DataSuffix==t_suffix)
    {
    def_format_match << i;
    def_format_match_header << false;
        if (std_bin_import_settings[i].header_present && std_bin_import_settings[i].header_format>1)//this is a data-file and we also need a separate header file
        def_format_match_incomplete << true;
        else
        def_format_match_incomplete << false;
    }
}
if (def_format_match.length()<=0) return RETURN_FAILURE;//no match found
//second: we try to find missing/matching files if needed
struct importSettings imp_set;
initSettings(imp_set,false);
int ret,match_type;
QList<QStringList> matching_files;
QList<int> match_result,match_types;
QStringList single_match_files;
for (int i=0;i<def_format_match.length();i++)
{
    single_match_files.clear();
    ret=RETURN_FAILURE;
    match_type=MATCH_TYPE_NONE;
    if (def_format_match_incomplete.at(i))
    {
    copy_import_settings(std_bin_import_settings+def_format_match.at(i),&imp_set);
        if (def_format_match_header.at(i))
        {
        imp_set.HeaderFile=filename;
        }
        else
        {
        imp_set.DataFile=filename;
        }
    ret=find_matching_files(imp_set,!(def_format_match_header.at(i)),single_match_files,match_type);
    }
    matching_files << single_match_files;
    match_result << ret;
    match_types << match_type;
}
//qDebug() << "matchingFiles=" << matching_files;
//now we may have matching files and match-results for every possible match - we have to find the most suitable
//third: find the one match that is most suitable
//suitable means: match for a data file that does not need an external header or a binary file that has matching files (header or data) - one-to-one-match prefered
int best_match=-1;//no best match so far
for (int i=0;i<def_format_match.length();i++)
{
    if (def_format_match_incomplete.at(i)==false || (def_format_match_incomplete.at(i)==true && match_result.at(i)==RETURN_SUCCESS))
    {
        if (best_match<0)
        {
        best_match=i;
        }
        else//we already have a good match --> check whether the new one might be better
        {
            if (def_format_match_incomplete.at(i)==false)//a match that does not need other files is the best one
            {
            best_match=i;
            }
            else if (match_types.at(best_match)<match_types.at(i) && (match_types.at(i)>0 || match_types.at(best_match)<1))
            {
            best_match=i;
            }
        }
    }
}
if (best_match<0) return RETURN_FAILURE;
std_format_nr=def_format_match.at(best_match);
list=matching_files.at(best_match);
//qDebug() << "format_suffix=" << std_bin_import_settings[std_format_nr].HeaderSuffix;
    if (std_bin_import_settings[std_format_nr].HeaderSuffix==t_suffix)
    {
    is_header=true;
    }
    else
    {
    is_header=false;
    }
return RETURN_SUCCESS;
}

int find_matching_files(struct importSettings & imp_set, bool find_header, QStringList & list, int & match_type)
{
list.clear();
match_type=MATCH_TYPE_NONE;
QString search_extension;
QString search_name;
QString search_dir_name;
QFileInfo fi,fi2;
    if (find_header==true)
    {
    search_extension=imp_set.HeaderSuffix;
    fi.setFile(imp_set.DataFile);
    }
    else
    {
    search_extension=imp_set.DataSuffix;
    fi.setFile(imp_set.HeaderFile);
    }
    search_name=fi.baseName();
    search_dir_name=fi.canonicalPath();
    if (search_extension.isEmpty())
    {
    errmsg(QObject::tr("No suitable suffix to search matching files by.").toLocal8Bit().constData());
    return RETURN_FAILURE;
    }
search_extension=QString("*.")+search_extension;
//qDebug() << "Match Files: Search for extension=" << search_extension;
//qDebug() << "Search-Name=" << search_name << endl << "Search-Dir=" << search_dir_name;
QDir search_dir(search_dir_name);
QStringList NameFilters;
NameFilters.clear();
NameFilters << search_extension;
QStringList extension_list=search_dir.entryList(NameFilters,QDir::Files,QDir::Name);
if (extension_list.length()<=0 || extension_list.isEmpty()) return RETURN_FAILURE;
//now we should have a non-empty list of files that match the desired extension in the directory
//now we have to see whether we can find a single file that also matches the name
/// list
//test:
//qDebug() << "Extension-list(" << extension_list.length() << ")=" << endl << extension_list;
    for (int i=0;i<extension_list.length();i++)
    {
    fi2.setFile(search_dir_name + QDir::separator() + extension_list.at(i));
        if (fi2.completeBaseName()==search_name)
        {
        list << fi2.canonicalFilePath();
        }
    }
if (list.length()<=0)//no matching file-name found yet maybe there is only one file that has a different name
{
    if (find_header==true && extension_list.length()==1)
    {
    fi2.setFile(search_dir_name + QDir::separator() + extension_list.at(0));
    list << fi2.canonicalFilePath();
    }
    else if (find_header==false && extension_list.length()>=1)
    {
        for (int i=0;i<extension_list.length();i++)
        {
        fi2.setFile(search_dir_name + QDir::separator() + extension_list.at(i));
        list << fi2.canonicalFilePath();
        }
    }
if (list.length()>0) match_type=MATCH_TYPE_RESIDUAL;
}
else
match_type=MATCH_TYPE_EXACT;

// special case: we look for a header suitable for a single file, but we find more than one --> error (we do not know which one)
if (find_header==true && list.length()>1) return RETURN_FAILURE;
else
return RETURN_SUCCESS;
}

int guess_bin_channel_import_format(int bytesize)
{
for (int i=0;i<NUMBER_OF_COLUMN_FORMATS;i++)//we look for a format that has the suitable number of bytes
{
    if (binaryImportFormat[i].size==bytesize)
    {
    return i;
    }
}
return -1;
}

void prepare_imp_settings_for_header_import(struct importSettings & imp_set)
{
    //imp_set.channel_format_known=false;
    imp_set.x0set=false;
    imp_set.deltaxset=false;
    imp_set.fset=false;
        for (int i=0;i<7;i++)
        {
        imp_set.factors[i]=1.0;
        imp_set.offsets[i]=0.0;
        }
        for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
        {
        imp_set.channel_factors[i]=1.0;
        imp_set.channel_offsets[i]=0.0;
        }
    imp_set.channels=imp_set.points=-1;
    imp_set.bitsize=imp_set.bytesize=-1;
    imp_set.whole_size=imp_set.single_size=-1;
    imp_set.headersize=0;
    for (int i=0;i<imp_set.nr_of_header_values;i++)
    {
        if (imp_set.header_value_size[i]<=0)
        {
        imp_set.header_value_size[i]=binaryImportFormat[imp_set.header_value_format[i]].size;
        }
    imp_set.headersize+=imp_set.header_value_size[i];
    }
}

void complete_channel_settings(struct importSettings & imp_set)
{
for (int j=0;j<=3;j++)//we do this more than once to get everything as complete as possible
{
        if (imp_set.bitsize==-1 && imp_set.bytesize>0) imp_set.bitsize=imp_set.bytesize*8;
        if (imp_set.bitsize>0 && imp_set.bytesize==-1) imp_set.bytesize=imp_set.bitsize/8;
        if (imp_set.bytesize>0 && imp_set.single_size>0 && imp_set.channels==-1) imp_set.channels=imp_set.single_size/imp_set.bytesize;
    if (imp_set.channels>0)
    {
        if (imp_set.points>0 && imp_set.whole_size>0 && imp_set.bytesize==-1) imp_set.bytesize=imp_set.whole_size/(imp_set.channels*imp_set.points);
        if (imp_set.single_size>0 && imp_set.bytesize==-1) imp_set.bytesize=imp_set.single_size/(imp_set.channels);
        if (imp_set.bytesize>0 && imp_set.single_size==-1) imp_set.single_size=imp_set.bytesize*imp_set.channels;
        if (imp_set.points==-1 && imp_set.whole_size>0 && imp_set.bytesize>0) imp_set.points=imp_set.whole_size/(imp_set.bytesize*imp_set.channels);
    }
    if (imp_set.points>0)
    {
        if (imp_set.whole_size==-1 && imp_set.single_size>0) imp_set.whole_size=imp_set.single_size*imp_set.points;
        if (imp_set.whole_size>0 && imp_set.single_size==-1) imp_set.single_size=imp_set.whole_size/imp_set.points;
    }
}
}

void readHeaderData(struct importSettings & imp_set,struct importSettings & imp_scheme)
{
if (imp_scheme.header_present)//at this point only the scheme should contain suitable data (imp_set is empty here)
{
///when reading from the headers
    if (imp_scheme.header_format==1 || imp_scheme.header_format==2)//bin-header in data-file or separate bin-file
    {
    read_BINARY_header(imp_set,imp_scheme);
    }
    else if (imp_scheme.header_format==3)//ini-header in separate file
    {
    read_INI_header(imp_set,imp_scheme);
    }
    else if (imp_scheme.header_format==4)//ascii-header in separate file
    {
    read_ASCII_header(imp_set,imp_scheme);
    }
    else if (imp_scheme.header_format==0)//manual header
    {
    copy_basic_scheme_data(imp_set,imp_scheme);
    copy_manual_header_data(imp_set,imp_scheme);
    }
    imp_set.valid_status=1;
}
else//no header present, all settings should be in the scheme
{
    copy_basic_scheme_data(imp_set,imp_scheme);
    //we also have to copy the data-import-settings! Usually we take them from the header, but here is no header
    imp_set.channels=imp_scheme.channels;
    imp_set.points=imp_scheme.points;
    if (imp_set.channel_format!=NULL) delete[] imp_set.channel_format;
    if (imp_set.channel_size!=NULL) delete[] imp_set.channel_size;
    if (imp_set.channel_target!=NULL) delete[] imp_set.channel_target;
    memcpy(imp_set.channel_format,imp_scheme.channel_format,sizeof(int)*imp_set.channels);
    memcpy(imp_set.channel_size,imp_scheme.channel_size,sizeof(int)*imp_set.channels);
    memcpy(imp_set.channel_target,imp_scheme.channel_target,sizeof(int)*imp_set.channels);
    imp_set.valid_status=1;
}
}

void copy_basic_scheme_data(struct importSettings & imp_set,struct importSettings & imp_schema)
{//copies some basic settings from the scheme to imp_set
    imp_set.header_present=imp_schema.header_present;
    imp_set.header_format=imp_schema.header_format;
    imp_set.multiple_header_files=imp_schema.multiple_header_files;
    imp_set.read_to_eof=imp_schema.read_to_eof;
    //imp_set.keep_trigger=imp_schema.keep_trigger;
    imp_set.trigger_channel=imp_schema.trigger_channel;
    imp_set.trigger_type=imp_schema.trigger_type;
    imp_set.trigger_is_percent=imp_schema.trigger_is_percent;
    imp_set.triggervalue=imp_schema.triggervalue;
    imp_set.autoscale=imp_schema.autoscale;
    imp_set.setorder=imp_schema.setorder;
    imp_set.set_type=imp_schema.set_type;
    imp_set.string_end_char=imp_schema.string_end_char;
    imp_set.target_gno=get_cg();//we assume to import to the current graph - we do not take settings from a scheme here (this has to be overwritten in the dialog, but not in the automatic binary import)
    imp_set.data_is_compressed=imp_schema.data_is_compressed;
}

void copy_scheme_counters_preprocessors(struct importSettings & imp_set,struct importSettings & imp_schema)
{
    imp_set.nr_of_counters=imp_schema.nr_of_counters;
    imp_set.counterTypes=imp_schema.counterTypes;
    imp_set.counterTargets=imp_schema.counterTargets;
    imp_set.counterSections=imp_schema.counterSections;
    imp_set.counterValues=imp_schema.counterValues;
    imp_set.counterText=imp_schema.counterText;
    imp_set.counterSets=imp_schema.counterSets;

    imp_set.nr_of_preprocessors=imp_schema.nr_of_preprocessors;
    imp_set.preprocessingValue=imp_schema.preprocessingValue;
    imp_set.preprocessingString=imp_schema.preprocessingString;
    imp_set.preprocessingType=imp_schema.preprocessingType;
    imp_set.preprocessingSet=imp_schema.preprocessingSet;
    imp_set.preprocessingTarget=imp_schema.preprocessingTarget;
    imp_set.preprocessingKey=imp_schema.preprocessingKey;
    imp_set.preprocessingCharA=imp_schema.preprocessingCharA;
    imp_set.preprocessingCharB=imp_schema.preprocessingCharB;
    imp_set.preprocessingMultipleA=imp_schema.preprocessingMultipleA;
    imp_set.preprocessingMultipleB=imp_schema.preprocessingMultipleB;
}

void copy_manual_header_data(struct importSettings & imp_set,struct importSettings & imp_schema)
{
    imp_set.x0=imp_schema.x0;
    imp_set.x0set=imp_schema.x0set;
    imp_set.f=imp_schema.f;
    imp_set.fset=imp_schema.fset;
    imp_set.deltax=imp_schema.deltax;
    imp_set.deltaxset=imp_schema.deltaxset;
    imp_set.whole_size=imp_schema.whole_size;
    for (int i=0;i<7;i++)
    {
    imp_set.offsets[i]=imp_schema.offsets[i];
    imp_set.factors[i]=imp_schema.factors[i];
    }
    for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
    {
    imp_set.channel_offsets[i]=imp_schema.channel_offsets[i];
    imp_set.channel_factors[i]=imp_schema.channel_factors[i];
        if (imp_set.set_title[i]!=NULL) delete[] imp_set.set_title[i];
        if (imp_schema.set_title[i]==NULL) imp_set.set_title[i]=NULL;
        else strcpy(imp_set.set_title[i],imp_schema.set_title[i]);
    }
        if (imp_set.title!=NULL) delete[] imp_set.title;
            if (imp_schema.title==NULL) imp_set.title=NULL;
            else strcpy(imp_set.title,imp_schema.title);
        if (imp_set.subtitle!=NULL) delete[] imp_set.subtitle;
            if (imp_schema.subtitle==NULL) imp_set.subtitle=NULL;
            else strcpy(imp_set.subtitle,imp_schema.subtitle);
        if (imp_set.x_title!=NULL) delete[] imp_set.x_title;
            if (imp_schema.x_title==NULL) imp_set.x_title=NULL;
            else strcpy(imp_set.x_title,imp_schema.x_title);
        if (imp_set.y_title!=NULL) delete[] imp_set.y_title;
            if (imp_schema.y_title==NULL) imp_set.y_title=NULL;
            else strcpy(imp_set.y_title,imp_schema.y_title);
}

//this function is very important to make sure the file names are inserted properly
void insert_filenames_in_settings(struct importSettings & imp_set,struct importSettings & imp_schema,QString headerfilename,QString datafilename)
{
imp_schema.HeaderFile=imp_set.HeaderFile=headerfilename;
imp_schema.DataFile=imp_set.DataFile=datafilename;
}

void read_BINARY_header(struct importSettings & imp_set,struct importSettings & imp_schema)//imp_set should contain the header-file-name
{
char dummy[1024];
bool integer_type;
char buffer[16];
char * stringText=new char[2];
int size,readbytes,global_size=0;
// 0) set some basics from the imp_schema
//basic settings
copy_basic_scheme_data(imp_set,imp_schema);
imp_set.nr_of_counters=imp_set.nr_of_preprocessors=0;
//binary header settings
imp_set.nr_of_header_values=imp_schema.nr_of_header_values;
//allocate Data for binary-header-import
long * headerDatas=new long[imp_set.nr_of_header_values];
long double * ldHeaderDatas=new long double[imp_set.nr_of_header_values];

if (imp_set.header_value_format!=NULL) delete[] imp_set.header_value_format;
imp_set.header_value_format=new int[imp_set.nr_of_header_values];
if (imp_set.header_value_import!=NULL) delete[] imp_set.header_value_import;
imp_set.header_value_import=new int[imp_set.nr_of_header_values];
if (imp_set.header_value_size!=NULL) delete[] imp_set.header_value_size;
imp_set.header_value_size=new int[imp_set.nr_of_header_values];
memcpy(imp_set.header_value_size,imp_schema.header_value_size,sizeof(int)*imp_set.nr_of_header_values);
memcpy(imp_set.header_value_import,imp_schema.header_value_import,sizeof(int)*imp_set.nr_of_header_values);
memcpy(imp_set.header_value_format,imp_schema.header_value_format,sizeof(int)*imp_set.nr_of_header_values);

//cout << "read Header: " << imp_set.HeaderFile.toLocal8Bit().constData() << endl;
//cout << "HEADER IN A BIN-DATA FILE, header_values=" << imp_set.nr_of_header_values << endl;

// 1) prepare the control variables in the imp_set
prepare_imp_settings_for_header_import(imp_set);

// 2) read the header-data from the binary file
ifstream ifi;
ifi.open(imp_set.HeaderFile.toLocal8Bit().constData(),ios::binary);
    for (int i=0;i<imp_set.nr_of_header_values;i++)
    {
//qDebug() << i << ": format=" << imp_set.header_value_format[i] << " size=" << imp_set.header_value_size[i] << " import_to=" << imp_set.header_value_import[i];
        size=imp_set.header_value_size[i];
        global_size+=size;
        if (imp_set.header_value_format[i]!=COLUMN_OFFSET && imp_set.header_value_format[i]!=COLUMN_STRING)
        {
            ifi.read(buffer,size);
            readbytes=(int)(ifi.gcount());
            if (readbytes!=size)
            {
                sprintf(dummy,"[Information] Stopped reading header item after import of %d Bytes (of %d bytes).",readbytes,size);
                stufftext(dummy);
            }
        }
        switch (imp_set.header_value_format[i])
        {
        case COLUMN_OFFSET:
        default:
            integer_type=false;
            for (int j=0;j<size;j++)
                ifi.read(buffer,1);//read byte after byte into the same buffer (we dont need it)
            break;
        case COLUMN_SIG_CHAR:
            integer_type=true;
            headerDatas[i]=(long)(*((signed char*)((void*)buffer)));
            break;
        case COLUMN_USIG_CHAR:
            integer_type=true;
            headerDatas[i]=(long)(*((unsigned char*)((void*)buffer)));
            break;
        case COLUMN_SIG_SHORT:
            integer_type=true;
            headerDatas[i]=(long)(*((signed short*)((void*)buffer)));
            break;
        case COLUMN_USIG_SHORT:
            integer_type=true;
            headerDatas[i]=(long)(*((unsigned short*)((void*)buffer)));
            break;
        case COLUMN_SIG_INT:
            integer_type=true;
            headerDatas[i]=(long)(*((signed int*)((void*)buffer)));
            break;
        case COLUMN_USIG_INT:
            integer_type=true;
            headerDatas[i]=(long)(*((unsigned int*)((void*)buffer)));
            break;
        case COLUMN_SIG_LONG:
            integer_type=true;
            headerDatas[i]=(long)(*((signed long*)((void*)buffer)));
            break;
        case COLUMN_USIG_LONG:
            integer_type=true;
            headerDatas[i]=(long)(*((unsigned long*)((void*)buffer)));
            break;
        case COLUMN_FLOAT:
            integer_type=false;
            ldHeaderDatas[i]=(long double)(*((float*)((void*)buffer)));
            break;
        case COLUMN_DOUBLE:
            integer_type=false;
            ldHeaderDatas[i]=(long double)(*((double*)((void*)buffer)));
            break;
        case COLUMN_LONG_DOUBLE:
            integer_type=false;
            ldHeaderDatas[i]=(long double)(*((long double*)((void*)buffer)));
            break;
        case COLUMN_STRING:
            integer_type=false;
            if (imp_set.determine_string_size==true)
            {
                int res=16;
                int read_s=0;
                char * targ=new char[res+1];
                char read_c=imp_set.string_end_char-1;
                while (read_c!=imp_set.string_end_char)
                {
                    ifi.read(&read_c,1);
                    targ[read_s]=read_c;
                    read_s++;
                    if (read_s==res)
                    {
                        char * targ2=new char[res+17];
                        memcpy(targ2,targ,sizeof(char)*read_s);
                        delete[] targ;
                        targ=targ2;
                        res+=16;
                    }
                }
                targ[read_s]='\0';
                global_size-=size;
                size=read_s;
                /// tabHeader->inFormats[i]->spnSize->setValue(size);
                global_size+=size;
                delete[] stringText;
                stringText=new char[size+2];
                strcpy(stringText,targ);
            }
            else
            {
                delete[] stringText;
                stringText=new char[size+2];
                ifi.read(stringText,size);
                stringText[size]='\0';
                readbytes=(int)(ifi.gcount());
                if (readbytes!=size)
                {
                    sprintf(dummy,"[Information] Stopped reading header item after import of %d Bytes (of %d bytes).",readbytes,size);
                    stufftext(dummy);
                }
            }
            break;
        }//end switch-block
//qDebug() << "B i=" << i;
            switch (imp_set.header_value_import[i])
            {
            case IMPORT_TO_NONE:
                break;
            case IMPORT_TO_TITLE:
                delete[] imp_set.title;
                imp_set.title=new char[size+1];
                strcpy(imp_set.title,stringText);
                break;
            case IMPORT_TO_SET_LEGEND:
                if (imp_set.set_title[imp_set.import_dest.at(i)]!=NULL)
                    delete[] imp_set.set_title[imp_set.import_dest.at(i)];
                imp_set.set_title[imp_set.import_dest.at(i)]=new char[size+1];
                strcpy(imp_set.set_title[imp_set.import_dest.at(i)],stringText);
                break;
            case IMPORT_TO_X0:
                if (integer_type)
                    imp_set.x0=headerDatas[i];
                else
                    imp_set.x0=ldHeaderDatas[i];
                imp_set.x0set=true;
                break;
            case IMPORT_TO_DELTAX:
                if (integer_type)
                    imp_set.deltax=headerDatas[i];
                else
                    imp_set.deltax=ldHeaderDatas[i];
                imp_set.deltaxset=true;
                break;
            case IMPORT_TO_XTITLE:
                if (imp_set.x_title!=NULL)
                    delete[] imp_set.x_title;
                imp_set.x_title=new char[size+1];
                strcpy(imp_set.x_title,stringText);
                break;
            case IMPORT_TO_YTITLE:
                if (imp_set.y_title!=NULL)
                    delete[] imp_set.y_title;
                imp_set.y_title=new char[size+1];
                strcpy(imp_set.y_title,stringText);
                break;
            case IMPORT_TO_XFACTOR:
                if (integer_type)
                    imp_set.factors[0]*=headerDatas[i];
                else
                    imp_set.factors[0]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_YFACTOR:
                if (integer_type)
                    imp_set.factors[1]*=headerDatas[i];
                else
                    imp_set.factors[1]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y1FACTOR:
                if (integer_type)
                    imp_set.factors[2]*=headerDatas[i];
                else
                    imp_set.factors[2]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y2FACTOR:
                if (integer_type)
                    imp_set.factors[3]*=headerDatas[i];
                else
                    imp_set.factors[3]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y3FACTOR:
                if (integer_type)
                    imp_set.factors[4]*=headerDatas[i];
                else
                    imp_set.factors[4]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y4FACTOR:
                if (integer_type)
                    imp_set.factors[5]*=headerDatas[i];
                else
                    imp_set.factors[5]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y_OFFSET:
                if (integer_type)
                    imp_set.offsets[1]*=headerDatas[i];
                else
                    imp_set.offsets[1]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y1_OFFSET:
                if (integer_type)
                    imp_set.offsets[2]*=headerDatas[i];
                else
                    imp_set.offsets[2]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y2_OFFSET:
                if (integer_type)
                    imp_set.offsets[3]*=headerDatas[i];
                else
                    imp_set.offsets[3]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y3_OFFSET:
                if (integer_type)
                    imp_set.offsets[4]*=headerDatas[i];
                else
                    imp_set.offsets[4]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y4_OFFSET:
                if (integer_type)
                    imp_set.offsets[5]*=headerDatas[i];
                else
                    imp_set.offsets[5]*=ldHeaderDatas[i];
                break;
            /*case IMPORT_TO_TRIGGER_FACTOR:
                if (integer_type)
                    imp_set.factors[6]*=headerDatas[i];
                else
                    imp_set.factors[6]*=ldHeaderDatas[i];
                break;*/
            case IMPORT_TO_SUBTITLE:
                delete[] imp_set.subtitle;
                imp_set.subtitle=new char[size+1];
                strcpy(imp_set.subtitle,stringText);
                break;
            case IMPORT_TO_NUMBER_OF_DATA:
                imp_set.points=headerDatas[i];
                break;
            case IMPORT_TO_NUMBER_OF_CHANNELS:
                imp_set.channels=headerDatas[i];
                break;
            case IMPORT_TO_DATA_SIZE:
                imp_set.bytesize=headerDatas[i];
                break;
            case IMPORT_TO_DATA_SIZE_BIT:
                imp_set.bitsize=headerDatas[i];
                break;
            case IMPORT_TO_DATA_SAMPLING_RATE:
                if (integer_type)
                    imp_set.f=headerDatas[i];
                else
                    imp_set.f=ldHeaderDatas[i];
                imp_set.fset=true;
                break;
            case IMPORT_TO_WHOLE_DATA_BLOCK_SIZE:
                imp_set.whole_size=headerDatas[i];
                break;
            case IMPORT_TO_SINGLE_DATA_BLOCK_SIZE:
                imp_set.single_size=headerDatas[i];
                break;
            }
    }//end loop through lines
ifi.close();
// 3) postprocess to get clean settings
if (imp_set.header_format==HEADER_FORMAT_DATA_FILE)//header in binary data file
{
imp_set.headersize=global_size;
}
else
{
imp_set.headersize=0;//we have to set this to zero to start reading the data file at the beginning
}

/*qDebug() << "Global size=" << global_size << " header_size=" << imp_set.headersize;

qDebug() << "before postprocessing:";
qDebug() << "imp_set.channels=" << imp_set.channels;
qDebug() << "imp_set.points=" << imp_set.points;
qDebug() << "imp_set.bitsize=" << imp_set.bitsize;
qDebug() << "imp_set.bytesize=" << imp_set.bytesize;
qDebug() << "imp_set.whole_size=" << imp_set.whole_size;
qDebug() << "imp_set.single_size=" << imp_set.single_size;*/

if (imp_set.whole_size<0 && imp_set.channels>0 && imp_set.points>0)//a special case: we know the number of channels and data points, but not the whole data-block-size --> try to guess point-sizes by file-size
{
QFileInfo fi1(imp_set.DataFile);
imp_set.whole_size=fi1.size()-imp_set.headersize;
}

complete_channel_settings(imp_set);

/*qDebug() << "after postprocessing:";
qDebug() << "imp_set.channels=" << imp_set.channels;
qDebug() << "imp_set.points=" << imp_set.points;
qDebug() << "imp_set.bitsize=" << imp_set.bitsize;
qDebug() << "imp_set.bytesize=" << imp_set.bytesize;
qDebug() << "imp_set.whole_size=" << imp_set.whole_size;
qDebug() << "imp_set.single_size=" << imp_set.single_size;*/

// 4) set the channel formats according to the schema
if (imp_set.format_suggestion!=NULL) delete[] imp_set.format_suggestion;
imp_set.format_suggestion=new int[imp_set.channels+1];
if (imp_set.channel_format!=NULL) delete[] imp_set.channel_format;
imp_set.channel_format=new int[imp_set.channels+1];
if (imp_set.channel_size!=NULL) delete[] imp_set.channel_size;
imp_set.channel_size=new int[imp_set.channels+1];
if (imp_set.channel_target!=NULL) delete[] imp_set.channel_target;
imp_set.channel_target=new int[imp_set.channels+1];
    for (int i=0;i<imp_set.channels;i++)
    {
    imp_set.channel_target[i]=IMPORT_TO_Y;//binary-header->choose y for all channels (as default)
        if (imp_schema.channels>=i)
        {
            if (imp_schema.channel_size[i]==imp_set.bytesize)
            {
            imp_set.channel_size[i]=imp_schema.channel_size[i];
            imp_set.channel_format[i]=imp_schema.channel_format[i];
            }
            else
            {
            imp_set.channel_size[i]=imp_set.bytesize;
            imp_set.channel_format[i]=guess_bin_channel_import_format(imp_set.bytesize);
            }
        imp_set.format_suggestion[i]=imp_set.channel_format[i];
        imp_set.channel_target[i]=imp_schema.channel_target[i];//if there is a target - use it
        }
        else
        {
        imp_set.channel_size[i]=imp_set.bytesize;
        imp_set.channel_format[i]=guess_bin_channel_import_format(imp_set.bytesize);
            if (imp_schema.channels-1>=0)
            imp_set.format_suggestion[i]=imp_set.format_suggestion[imp_schema.channels-1];
            else
            imp_set.format_suggestion[i]=imp_set.channel_format[i];
        }
//qDebug() << "target=" << imp_set.channel_target[i] << " size=" << imp_set.channel_size[i] << " format=" << imp_set.channel_format[i];
    }
    imp_set.ReadFromHeader=imp_set.HeaderFile;
delete [] headerDatas;
delete [] ldHeaderDatas;
}

void read_ASCII_header(struct importSettings & imp_set,struct importSettings & imp_schema)//imp_set should contain the header-file-name
{
// 0) set some basics from the imp_schema
//basic settings
copy_basic_scheme_data(imp_set,imp_schema);


imp_set.ReadFromHeader=imp_set.HeaderFile;
}

void compare_INI_settings_with_schema(struct importSettings & imp_set,struct importSettings & imp_schema)
{
//look for the imp_set-settings in the schema to match it with the import-destinations
    imp_set.import_dest.clear();
    imp_set.import_channel_dest.clear();
    int destination,pos,destination_channel;
    char tmp_target_name[1024];
    if (imp_set.token_target!=NULL) delete[] imp_set.token_target;
    imp_set.token_target=new int[1+imp_set.keys.length()];
    for (int i=0;i<imp_set.keys.length();i++)
    {
        pos=imp_schema.keys.indexOf(imp_set.keys.at(i));
        //cout << "Looking for " << imp_set.keys.at(i).toLocal8Bit().constData() << " found=" << imp_schema.keys.at(pos).toLocal8Bit().constData() << endl;
        destination=IMPORT_TO_NONE;
            if (pos>=0)
            {
            strcpy(tmp_target_name,imp_schema.vals.at(pos).toLocal8Bit().constData());
            destination = find_import_destination(tmp_target_name,1);//'1' means look only for data read from header
            destination_channel = imp_schema.import_channel_dest.at(pos);
            }
        if (pos<0 || destination<0)//not found
        {
            //cout << "Destination NOT found" << endl;
        imp_set.import_dest << IMPORT_TO_NONE;
        imp_set.import_channel_dest << -1;
        }
        else
        {
            //cout << "Destination found: " << imp_set.keys.at(i).toLocal8Bit().constData() << " --> channel=" << destination_channel << " to " << ImportDestinationName[destination] << endl;
        imp_set.import_dest << destination;
        imp_set.import_channel_dest << destination_channel;
        }
        imp_set.token_target[i]=imp_set.import_dest.last();
    }
}

int guess_suitable_import_format(int suggestion,int actualsize)//guess the most suitable import format if the size in bytes does not match the type-suggestion --> will return the suggestion, if nothing better is found
{
int ret=suggestion;
switch (suggestion)
{
case COLUMN_SIG_CHAR:
case COLUMN_SIG_SHORT:
case COLUMN_SIG_INT:
case COLUMN_SIG_LONG:
    if (binaryImportFormat[COLUMN_SIG_CHAR].size==actualsize)
    {
    ret=COLUMN_SIG_CHAR;
    }
    else if (binaryImportFormat[COLUMN_SIG_SHORT].size==actualsize)
    {
    ret=COLUMN_SIG_SHORT;
    }
    else if (binaryImportFormat[COLUMN_SIG_INT].size==actualsize)
    {
    ret=COLUMN_SIG_INT;
    }
    else if (binaryImportFormat[COLUMN_SIG_LONG].size==actualsize)
    {
    ret=COLUMN_SIG_LONG;
    }
break;
case COLUMN_USIG_CHAR:
case COLUMN_USIG_SHORT:
case COLUMN_USIG_INT:
case COLUMN_USIG_LONG:
    if (binaryImportFormat[COLUMN_USIG_CHAR].size==actualsize)
    {
    ret=COLUMN_USIG_CHAR;
    }
    else if (binaryImportFormat[COLUMN_USIG_SHORT].size==actualsize)
    {
    ret=COLUMN_USIG_SHORT;
    }
    else if (binaryImportFormat[COLUMN_USIG_INT].size==actualsize)
    {
    ret=COLUMN_USIG_INT;
    }
    else if (binaryImportFormat[COLUMN_USIG_LONG].size==actualsize)
    {
    ret=COLUMN_USIG_LONG;
    }
break;
case COLUMN_FLOAT:
case COLUMN_DOUBLE:
case COLUMN_LONG_DOUBLE:
    if (binaryImportFormat[COLUMN_FLOAT].size==actualsize)
    {
    ret=COLUMN_FLOAT;
    }
    else if (binaryImportFormat[COLUMN_DOUBLE].size==actualsize)
    {
    ret=COLUMN_DOUBLE;
    }
    else if (binaryImportFormat[COLUMN_LONG_DOUBLE].size==actualsize)
    {
    ret=COLUMN_LONG_DOUBLE;
    }
break;
}
return ret;
}

void read_INI_header(struct importSettings & imp_set,struct importSettings & imp_schema)//imp_set should contain the header-file-name
{
///qDebug() << "read INI-Header-File:" << imp_set.HeaderFile << endl;
// 0) set some basics from the imp_schema
//basic settings
copy_basic_scheme_data(imp_set,imp_schema);
imp_set.nr_of_counters=imp_set.nr_of_preprocessors=0;
// 1) read all the ini-tokens from the header
get_all_settings_from_ini_file(imp_set.HeaderFile,imp_set.keys,imp_set.vals,imp_set.import_channel_dest);
imp_set.nr_of_import_tokens=imp_set.keys.length();
imp_schema.valid_status=imp_set.valid_status=0;
///qDebug() << "nr of keys read:" << imp_set.keys.length();
// 2) compare the tokens with the schema and set the targets (where to put the data read from the header)
// the tokens we have to look for are in the imp_schema; any import-key in imp_set that is not part of imp_schema will be marked with a 0 (IMPORT_TO_NONE)

/*
cout << "schema data:" << endl;
for (int i=0;i<imp_schema.keys.length();i++)
{
cout << "#" << imp_schema.keys.at(i).toLocal8Bit().constData() << "#-->#" << imp_schema.vals.at(i).toLocal8Bit().constData() << "#" << endl;
}*/
imp_set.import_channel_dest.clear();
imp_set.import_dest.clear();
//cout << "imported data:" << endl;
for (int i=0;i<imp_set.keys.length();i++)
{
//cout << "#" << imp_set.keys.at(i).toLocal8Bit().constData() << "#-->#" << imp_set.vals.at(i).toLocal8Bit().constData() << "#" << endl;
imp_set.import_channel_dest << -1;
imp_set.import_dest << IMPORT_TO_NONE;
}

prepare_imp_settings_for_header_import(imp_set);

//qDebug() << "valid_status=" << imp_schema.valid_status;
if (imp_schema.valid_status!=-1)
{
//qDebug() << "START comparing";
compare_INI_settings_with_schema(imp_set,imp_schema);
//qDebug() << "STOP comparing";
}
else
{
//qDebug() << "just read";
return;//invalid schema-->do not try anything more
}

char tmp_target_name[1024];

// 3) prepare the control variables in the imp_set
/*qDebug() << "A) 16-channel_factors=";
    for (int i=0;i<16;i++)
    {
    qDebug()  << imp_set.channel_offsets[i] << " | " << imp_set.channel_factors[i];
    }*/

//prepare counters and preprocessors
copy_scheme_counters_preprocessors(imp_set,imp_schema);
// 4) put the data read where it belongs!
double d_value;
int i_value;
QString tmp_string;
// 4a) counters
evaluateCounters(imp_set);
for (int c=0;c<imp_set.nr_of_counters;c++)
{
//qDebug() << "Counter" << c << "Value=" << imp_set.counterValues.at(c) << "ImportTo" << imp_set.counterTargets.at(c);
if (imp_set.counterTargets.at(c)==IMPORT_TO_NONE) continue;
d_value=(double)imp_set.counterValues.at(c);
tmp_string=QString::number(imp_set.counterValues.at(c));
    switch (imp_set.counterTargets.at(c))
    {
    case IMPORT_TO_X0:
        imp_set.x0=d_value;
        imp_set.x0set=true;
        break;
    case IMPORT_TO_DELTAX:
        imp_set.deltax=d_value;
        imp_set.deltaxset=true;
        break;
    case IMPORT_TO_DATA_SAMPLING_RATE:
        imp_set.f=d_value;
        imp_set.fset=true;
        break;
    case IMPORT_TO_NUMBER_OF_DATA:
        imp_set.points=imp_set.counterValues.at(c);
        break;
    case IMPORT_TO_NUMBER_OF_CHANNELS:
        imp_set.channels=imp_set.counterValues.at(c);
        break;
    case IMPORT_TO_DATA_SIZE:
        imp_set.bytesize=imp_set.counterValues.at(c);
        break;
    case IMPORT_TO_DATA_SIZE_BIT:
        imp_set.bitsize=imp_set.counterValues.at(c);
        break;
    case IMPORT_TO_WHOLE_DATA_BLOCK_SIZE:
        imp_set.whole_size=imp_set.counterValues.at(c);
        break;
    case IMPORT_TO_SINGLE_DATA_BLOCK_SIZE:
        imp_set.single_size=imp_set.counterValues.at(c);
        break;
    case IMPORT_TO_TITLE:
        if (imp_set.title!=NULL)
            delete[] imp_set.title;
        imp_set.title=new char[tmp_string.toLocal8Bit().length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.title,tmp_string.toLocal8Bit().constData());
        break;
    case IMPORT_TO_SET_LEGEND:
        if (imp_set.counterSets.at(c)==-1)//all
        {
            for (int k=0;k<MAX_BIN_IMPORT_CHANNELS;k++)
            {
                if (imp_set.set_title[k]!=NULL)
                    delete[] imp_set.set_title[k];
                imp_set.set_title[k]=new char[tmp_string.length()+1];//tabHeader->readValues[i].length()+1];
                strcpy(imp_set.set_title[k],tmp_string.toLocal8Bit().constData());
            }
        }
        else
        {
        if (imp_set.set_title[imp_set.counterSets.at(c)]!=NULL)
            delete[] imp_set.set_title[imp_set.counterSets.at(c)];
        imp_set.set_title[imp_set.counterSets.at(c)]=new char[tmp_string.length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.set_title[imp_set.counterSets.at(c)],tmp_string.toLocal8Bit().constData());
        }
        break;
    case IMPORT_TO_XTITLE:
        if (imp_set.x_title!=NULL)
            delete[] imp_set.x_title;
        imp_set.x_title=new char[tmp_string.toLocal8Bit().length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.x_title,tmp_string.toLocal8Bit().constData());
        break;
    case IMPORT_TO_YTITLE:
        if (imp_set.y_title!=NULL)
            delete[] imp_set.y_title;
        imp_set.y_title=new char[tmp_string.toLocal8Bit().length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.y_title,tmp_string.toLocal8Bit().constData());
        break;
    case IMPORT_TO_SUBTITLE:
        if (imp_set.subtitle!=NULL)
            delete[] imp_set.subtitle;
        imp_set.subtitle=new char[tmp_string.toLocal8Bit().length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.subtitle,tmp_string.toLocal8Bit().constData());
        break;
    /*case IMPORT_TO_TRIGGER_FACTOR:
        imp_set.factors[6]*=d_value;
        break;*/
    }
    if (imp_set.counterTargets.at(c)>=IMPORT_TO_XFACTOR && imp_set.counterTargets.at(c)<=IMPORT_TO_Y4FACTOR)
    {
        if (imp_set.counterSets.at(c)==-1)//all
        imp_set.factors[imp_set.counterTargets.at(c)-IMPORT_TO_XFACTOR]*=d_value;
        else//just one channel
        imp_set.channel_factors[imp_set.counterSets.at(c)]*=d_value;
    }
    else if (imp_set.counterTargets.at(c)>=IMPORT_TO_Y_OFFSET && imp_set.counterTargets.at(c)<=IMPORT_TO_Y4_OFFSET)
    {
        if (imp_set.counterSets.at(c)==-1)//all
        imp_set.offsets[imp_set.counterTargets.at(c)-IMPORT_TO_Y_OFFSET]+=d_value;
        else//just one channel
        imp_set.channel_offsets[imp_set.counterSets.at(c)]+=d_value;
    }
}//end counters
// 4b) Preprocessors
evaluatePreprocessors(imp_set);
for (int c=0;c<imp_set.nr_of_preprocessors;c++)
{
if (imp_set.preprocessingTarget.at(c)==IMPORT_TO_NONE) continue;
d_value=imp_set.preprocessingValue.at(c);
i_value=(int)d_value;
//tmp_string=QString::number(imp_set.preprocessingValue.at(c));
tmp_string=imp_set.preprocessingString.at(c);
//qDebug() << "preprocessor"<< c << "d_value=" << d_value << "Target=" << imp_set.preprocessingTarget.at(c) << "Set=" << imp_set.preprocessingSet.at(c);
    switch (imp_set.preprocessingTarget.at(c))
    {
    case IMPORT_TO_X0:
        imp_set.x0=d_value;
        imp_set.x0set=true;
        break;
    case IMPORT_TO_DELTAX:
        imp_set.deltax=d_value;
        imp_set.deltaxset=true;
        break;
    case IMPORT_TO_DATA_SAMPLING_RATE:
        imp_set.f=d_value;
        imp_set.fset=true;
        break;
    case IMPORT_TO_NUMBER_OF_DATA:
        imp_set.points=i_value;
        break;
    case IMPORT_TO_NUMBER_OF_CHANNELS:
        imp_set.channels=i_value;
        break;
    case IMPORT_TO_DATA_SIZE:
        imp_set.bytesize=i_value;
        break;
    case IMPORT_TO_DATA_SIZE_BIT:
        imp_set.bitsize=i_value;
        break;
    case IMPORT_TO_WHOLE_DATA_BLOCK_SIZE:
        imp_set.whole_size=i_value;
        break;
    case IMPORT_TO_SINGLE_DATA_BLOCK_SIZE:
        imp_set.single_size=i_value;
        break;
    case IMPORT_TO_TITLE:
        if (imp_set.title!=NULL)
            delete[] imp_set.title;
        imp_set.title=new char[tmp_string.toLocal8Bit().length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.title,tmp_string.toLocal8Bit().constData());
        break;
    case IMPORT_TO_SET_LEGEND:
        if (imp_set.preprocessingSet.at(c)==-1)//all
        {
            for (int k=0;k<MAX_BIN_IMPORT_CHANNELS;k++)
            {
                if (imp_set.set_title[k]!=NULL)
                    delete[] imp_set.set_title[k];
                imp_set.set_title[k]=new char[tmp_string.length()+1];//tabHeader->readValues[i].length()+1];
                strcpy(imp_set.set_title[k],tmp_string.toLocal8Bit().constData());
            }
        }
        else
        {
        if (imp_set.set_title[imp_set.preprocessingSet.at(c)]!=NULL)
            delete[] imp_set.set_title[imp_set.preprocessingSet.at(c)];
        imp_set.set_title[imp_set.preprocessingSet.at(c)]=new char[tmp_string.length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.set_title[imp_set.preprocessingSet.at(c)],tmp_string.toLocal8Bit().constData());
        }
        break;
    case IMPORT_TO_XTITLE:
        if (imp_set.x_title!=NULL)
            delete[] imp_set.x_title;
        imp_set.x_title=new char[tmp_string.toLocal8Bit().length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.x_title,tmp_string.toLocal8Bit().constData());
        break;
    case IMPORT_TO_YTITLE:
        if (imp_set.y_title!=NULL)
            delete[] imp_set.y_title;
        imp_set.y_title=new char[tmp_string.toLocal8Bit().length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.y_title,tmp_string.toLocal8Bit().constData());
        break;
    case IMPORT_TO_SUBTITLE:
        if (imp_set.subtitle!=NULL)
            delete[] imp_set.subtitle;
        imp_set.subtitle=new char[tmp_string.toLocal8Bit().length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.subtitle,tmp_string.toLocal8Bit().constData());
        break;
    /*case IMPORT_TO_TRIGGER_FACTOR:
        imp_set.factors[6]*=d_value;
        break;*/
    }
    if (imp_set.preprocessingTarget.at(c)>=IMPORT_TO_XFACTOR && imp_set.preprocessingTarget.at(c)<=IMPORT_TO_Y4FACTOR)
    {
        if (imp_set.preprocessingSet.at(c)==-1)//all
        imp_set.factors[imp_set.preprocessingTarget.at(c)-IMPORT_TO_XFACTOR]*=d_value;
        else//just one channel
        imp_set.channel_factors[imp_set.preprocessingSet.at(c)]*=d_value;
    }
    else if (imp_set.preprocessingTarget.at(c)>=IMPORT_TO_Y_OFFSET && imp_set.preprocessingTarget.at(c)<=IMPORT_TO_Y4_OFFSET)
    {
        if (imp_set.preprocessingSet.at(c)==-1)//all
        imp_set.offsets[imp_set.preprocessingTarget.at(c)-IMPORT_TO_Y_OFFSET]+=d_value;
        else//just one channel
        imp_set.channel_offsets[imp_set.preprocessingSet.at(c)]+=d_value;
    }
}//end preprocessors

/*qDebug() << "B) 16-channel_factors=";
for (int i=0;i<16;i++)
{
qDebug()<< imp_set.channel_offsets[i] << " | " << imp_set.channel_factors[i];
}*/

// 4c) the usual data
///bool x_axis_implicit=false;//is true, if x0, dx or f is set, false means: set first channel to x
for (int i=0;i<imp_set.keys.length();i++)
{
if (imp_set.import_dest.at(i)==IMPORT_TO_NONE) continue;
    strcpy(tmp_target_name,imp_set.vals.at(i).toLocal8Bit().constData());//tabHeader->readValues[i].toLocal8Bit());
    d_value=atof(tmp_target_name);
//cout << "val=" << tmp_target_name << " --> atof=" << d_value << " imp_dest=" << imp_set.import_dest.at(i) << endl;
    switch (imp_set.import_dest.at(i))
    {
    case IMPORT_TO_X0:
        imp_set.x0=d_value;
        imp_set.x0set=true;
        break;
    case IMPORT_TO_DELTAX:
        imp_set.deltax=d_value;
        imp_set.deltaxset=true;
        break;
    case IMPORT_TO_DATA_SAMPLING_RATE:
        imp_set.f=d_value;
        imp_set.fset=true;
        break;
    case IMPORT_TO_NUMBER_OF_DATA:
        imp_set.points=atoi(tmp_target_name);
        break;
    case IMPORT_TO_NUMBER_OF_CHANNELS:
        imp_set.channels=atoi(tmp_target_name);
        break;
    case IMPORT_TO_DATA_SIZE:
        imp_set.bytesize=atoi(tmp_target_name);
        break;
    case IMPORT_TO_DATA_SIZE_BIT:
        imp_set.bitsize=atoi(tmp_target_name);
        break;
    case IMPORT_TO_WHOLE_DATA_BLOCK_SIZE:
        imp_set.whole_size=atoi(tmp_target_name);
        break;
    case IMPORT_TO_SINGLE_DATA_BLOCK_SIZE:
        imp_set.single_size=atoi(tmp_target_name);
        break;
    case IMPORT_TO_TITLE:
        if (imp_set.title!=NULL)
            delete[] imp_set.title;
        imp_set.title=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.title,tmp_target_name);
        break;
    case IMPORT_TO_SET_LEGEND:
        if (imp_set.import_channel_dest.at(i)==-1)//all
        {
            for (int k=0;k<MAX_BIN_IMPORT_CHANNELS;k++)
            {
                if (imp_set.set_title[k]!=NULL)
                    delete[] imp_set.set_title[k];
                imp_set.set_title[k]=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
                strcpy(imp_set.set_title[k],tmp_target_name);
            }
        }
        else
        {
        if (imp_set.set_title[imp_set.import_channel_dest.at(i)]!=NULL)
            delete[] imp_set.set_title[imp_set.import_channel_dest.at(i)];
        imp_set.set_title[imp_set.import_channel_dest.at(i)]=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.set_title[imp_set.import_channel_dest.at(i)],tmp_target_name);
        }
        break;
    case IMPORT_TO_XTITLE:
        if (imp_set.x_title!=NULL)
            delete[] imp_set.x_title;
        imp_set.x_title=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.x_title,tmp_target_name);
        break;
    case IMPORT_TO_YTITLE:
        if (imp_set.y_title!=NULL)
            delete[] imp_set.y_title;
        imp_set.y_title=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.y_title,tmp_target_name);
        break;
    case IMPORT_TO_SUBTITLE:
        if (imp_set.subtitle!=NULL)
            delete[] imp_set.subtitle;
        imp_set.subtitle=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.subtitle,tmp_target_name);
        break;
    /*case IMPORT_TO_TRIGGER_FACTOR:
        imp_set.factors[6]*=d_value;
        break;*/
    }
    if (imp_set.import_dest.at(i)>=IMPORT_TO_XFACTOR && imp_set.import_dest.at(i)<=IMPORT_TO_Y4FACTOR)
    {
    //imp_set.factors[imp_set.import_dest.at(i)-IMPORT_TO_XFACTOR]*=d_value;
        if (imp_set.import_channel_dest.at(i)==-1)//all
        imp_set.factors[imp_set.import_dest.at(i)-IMPORT_TO_XFACTOR]*=d_value;
        else//just one channel
        imp_set.channel_factors[imp_set.import_channel_dest.at(i)]*=d_value;
    }
    else if (imp_set.import_dest.at(i)>=IMPORT_TO_Y_OFFSET && imp_set.import_dest.at(i)<=IMPORT_TO_Y4_OFFSET)
    {
        if (imp_set.import_channel_dest.at(i)==-1)//all
        imp_set.offsets[imp_set.import_dest.at(i)-IMPORT_TO_Y_OFFSET]+=d_value;
        else//just one channel
        imp_set.channel_offsets[imp_set.import_channel_dest.at(i)]+=d_value;
    }

    /*
    else if (imp_set.import_dest.at(i)>=IMPORT_TO_CHANNEL0_FACTOR && imp_set.import_dest.at(i)<=IMPORT_TO_CHANNEL15_FACTOR)
    {
    imp_set.channel_factors[imp_set.import_dest.at(i)-IMPORT_TO_CHANNEL0_FACTOR]*=d_value;
    }
    else if (imp_set.import_dest.at(i)>=IMPORT_TO_CHANNEL0_OFFSET && imp_set.import_dest.at(i)<=IMPORT_TO_CHANNEL15_OFFSET)
    {
    imp_set.channel_offsets[imp_set.import_dest.at(i)-IMPORT_TO_CHANNEL0_OFFSET]+=d_value;
    }*/
    //cout << "0-factor=" << imp_set.channel_factors[0] << endl;
}
/*
qDebug() << "C) 16-channel_factors=";
for (int i=0;i<16;i++)
{
qDebug()<< imp_set.channel_offsets[i] << " | " << imp_set.channel_factors[i];
}
qDebug() << "INI Before: Bit=" << imp_set.bitsize << "Byte=" <<  imp_set.bytesize << "Channels=" << imp_set.channels << "Single=" << imp_set.single_size << "Points=" << imp_set.points << "Whole=" << imp_set.whole_size;
*/
complete_channel_settings(imp_set);
/*
qDebug() << "INI After: Bit=" << imp_set.bitsize << "Byte=" <<  imp_set.bytesize << "Channels=" << imp_set.channels << "Single=" << imp_set.single_size << "Points=" << imp_set.points << "Whole=" << imp_set.whole_size;
qDebug() << "imp_set.x0set=" << imp_set.x0set << "imp_set.deltaxset=" << imp_set.deltaxset;
qDebug() << "imp_set.x0=" << imp_set.x0 << "imp_set.deltax=" << imp_set.deltax;
*/
// 5) postprocess header information: crosscheck for completeness, guess cokumn-formats
if (imp_set.deltaxset==true || (imp_set.fset==true && imp_set.f!=0.0))//we have an iplicit x-axis --> we do not need a x-channel
{
    if (imp_set.x0set==false)
    {
    imp_set.x0=0.0;
    }
    if (imp_set.deltaxset==false)
    {
    imp_set.deltax=1.0/imp_set.f;
    }
    ///x_axis_implicit=true;
}

if (imp_set.channels<=0)
{
    errmsg(QObject::tr("Nr of channels not found in ini-file, setting channel count to 1").toLocal8Bit().constData());
    imp_set.channels=1;
}
int bsize;//only one byte-size for all channels
if (imp_set.bitsize!=-1)
{
bsize=imp_set.bitsize/8;
    if(bsize*8!=imp_set.bitsize)
    {
    errmsg(QObject::tr("size in bits no power of 8, bitsize increased to next power of 8").toLocal8Bit().constData());
    bsize++;
    imp_set.bytesize=bsize;
    imp_set.bitsize=imp_set.bytesize*8;
    }
imp_set.bytesize=bsize;
}
else if (imp_set.bytesize!=-1)
{
bsize=imp_set.bytesize;
imp_set.bitsize=imp_set.bytesize*8;
imp_set.bytesize=bsize;
}
else
bsize=-1;//invalid --> we look in the schema

//imp_set.first_suggestion=guess_bin_channel_import_format(bsize);
imp_set.contains_trigger=false;

//the actual import format for all channels
if (imp_set.format_suggestion!=NULL)delete[] imp_set.format_suggestion;
if (imp_set.channel_format!=NULL) delete[] imp_set.channel_format;
if (imp_set.channel_size!=NULL) delete[] imp_set.channel_size;
if (imp_set.channel_target!=NULL) delete[] imp_set.channel_target;
imp_set.format_suggestion=new int[1+imp_set.channels];
imp_set.channel_format=new int[1+imp_set.channels];
imp_set.channel_size=new int[1+imp_set.channels];
imp_set.channel_target=new int[1+imp_set.channels];

for (int i=0;i<imp_set.channels;i++)//go through all channels and set the import-format (if possible)
{
    if (imp_schema.channels>=i)//there is a suitable import-setting - maybe (we presume so...we hope the user knows best...)
    {
        imp_set.format_suggestion[i]=imp_set.channel_format[i]=imp_schema.channel_format[i];
        imp_set.channel_size[i]=imp_schema.channel_size[i];
        imp_set.channel_target[i]=imp_schema.channel_target[i];
        if (imp_set.channel_size[i]<=0) imp_set.channel_size[i]=binaryImportFormat[imp_set.channel_format[i]].size;
    }
    else//more channels than formats in schema
    {
        imp_set.channel_size[i]=bsize>0?bsize:1;
        if (imp_schema.channels-1>=0) imp_set.channel_format[i]=imp_set.format_suggestion[imp_schema.channels-1];
        else imp_set.channel_format[i]=guess_bin_channel_import_format(bsize);
        if (imp_set.channel_format[i]>=0)
        {
        imp_set.channel_format[i]=binaryImportFormat[imp_set.channel_format[i]].format;
        imp_set.channel_target[i]=IMPORT_TO_Y;//unknown is always Y
        }
        else
        {
        imp_set.channel_format[i]=COLUMN_OFFSET;
        imp_set.channel_target[i]=IMPORT_TO_NONE;
        }
    }
    imp_set.format_suggestion[i]=imp_set.channel_format[i];
    if (imp_set.channel_target[i]==IMPORT_TO_TRIGGER) imp_set.contains_trigger=true;
}

//cout << "first_suggestion=" << first_suggestion << endl;
//cout << imp_set.points << " " << imp_set.whole_size << " " << imp_set.bytesize << " " << imp_set.bitsize << endl;
if (imp_set.points<=0 && imp_set.whole_size!=-1 && (imp_set.bytesize!=-1 || imp_set.bitsize!=-1))
{
    int size=imp_set.bytesize!=-1?imp_set.bytesize:imp_set.bitsize/8;
    imp_set.points=imp_set.whole_size/size;
    if (imp_set.channels>0)
        imp_set.points/=imp_set.channels;
}

//cout << "points=" << imp_set.points << " whole=" << imp_set.whole_size << " byte=" << imp_set.bytesize << " bit=" << imp_set.bitsize << " global_size=" << global_size << endl;
/// imp_set.headersize=global_size;
imp_set.headersize=0;//no header in bin-file because header is in separate ini-file

/*cout << "C) 16-channel_factors=" << endl;
for (int i=0;i<16;i++)
{
cout << imp_set.channel_offsets[i] << " | " << imp_set.channel_factors[i] << endl;
}*/

/*
cout << "Faktors=" << endl;
for (int i=0;i<7;i++)
cout << "f[" << i << "]=" << imp_set.factors[i] << endl;
for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
cout << "ch_f[" << i << "]=" << imp_set.channel_factors[i] << endl;
*/

//we check the byte-size of the import-format here (only if a channel size in bytes is set)
if (bsize>0)
{
for (int i=0;i<imp_set.channels;i++)
{
    if (binaryImportFormat[imp_set.channel_format[i]].size!=bsize)
    {
    //cout << "Having to reguess Format of channel " << i << endl;
    //cout << "Original Suggestion: " << binaryImportFormatName[imp_set.channel_format[i]] << endl;
    imp_set.channel_format[i]=guess_suitable_import_format(imp_set.channel_format[i],bsize);
    //cout << "New Suggestion: " << binaryImportFormatName[imp_set.channel_format[i]] << endl;
    imp_set.channel_size[i]=binaryImportFormat[imp_set.channel_format[i]].size;
    imp_set.format_suggestion[i]=imp_set.channel_format[i];
    }
}
}
imp_set.ReadFromHeader=imp_set.HeaderFile;
//now we have read everything we could from the header!
//now we should read the data
}

int postprocess_bin_import_data(struct importSettings & imp_set,int & nr_of_new_sets,int ** n_gnos,int ** n_snos)
{
QString set_identifier;
char set_identifier_string[MAX_STRING_LENGTH];
nr_of_new_sets=0;
if (*n_gnos!=NULL) delete[] *n_gnos;
if (*n_snos!=NULL) delete[] *n_snos;

int number_of_sets_with_column[6]={0,0,0,0,0,0};
int number_of_x_columns=0;
int triggerChannel=-1;
int x_Channel=-1;
//int triggerSet=-1;
int triggerID=-1;
bool triggerIDfound=false;

for (int i=0;i<imp_set.channels;i++)
{
//qDebug() << "Postprocessing: " << i << "/" << imp_set.channels << "Target=" << imp_set.channel_target[i];
    if (imp_set.channel_target[i]==IMPORT_TO_TRIGGER)//All trigger-Channels will be imported as Y-Channel
    {
    imp_set.channel_target[i]=IMPORT_TO_Y;
    }
    if (imp_set.channel_target[i]==IMPORT_TO_X)
    {
        if (x_Channel==-1)
        x_Channel=i;
        else
        imp_set.channel_target[i]=IMPORT_TO_NONE;
    }
    if (imp_set.channel_target[i]==IMPORT_TO_Y && triggerIDfound==false) triggerID++;
    if (imp_set.channel_target[i]==IMPORT_TO_TRIGGER && triggerIDfound==false)
    {
    triggerID++;
    triggerIDfound=true;
    }
}

/*
qDebug() << "triggerID=" << triggerID << "triggerIDfound=" << triggerIDfound;
qDebug() << "TriggerValue=" << imp_set.triggervalue << "isPercent=" << imp_set.trigger_is_percent << "TriggerChannel=" << imp_set.trigger_channel << "TriggerType=" << imp_set.trigger_type;
*/

for (int i=0;i<imp_set.channels;i++)
{
    if (imp_set.channel_target[i]!=IMPORT_TO_NONE)
    {
        if (imp_set.channel_target[i]==IMPORT_TO_X)
            number_of_sets_with_column[0]++;
        else if (imp_set.channel_target[i]==IMPORT_TO_Y || imp_set.channel_target[i]==IMPORT_TO_TRIGGER)//we count trigger-channel as Y-channel
            number_of_sets_with_column[1]++;
        else if (imp_set.channel_target[i]==IMPORT_TO_Y1)
            number_of_sets_with_column[2]++;
        else if (imp_set.channel_target[i]==IMPORT_TO_Y2)
            number_of_sets_with_column[3]++;
        else if (imp_set.channel_target[i]==IMPORT_TO_Y3)
            number_of_sets_with_column[4]++;
        else if (imp_set.channel_target[i]==IMPORT_TO_Y4)
            number_of_sets_with_column[5]++;
        else if (imp_set.channel_target[i]==IMPORT_TO_TRIGGER)
        {
            triggerChannel=i;
            //if (imp_set.keep_trigger==true)//the trigger-channel counts as an additional Y-channel
            //{
            number_of_sets_with_column[1]++;
            //}
        }
    }
    //if (imp_set.set_title[i]!=NULL)
    //cout << "postprocessing: setTitle=#" << imp_set.set_title[i] << "#" << endl;
    //else
    //cout << "postprocessing: setTitle"<< i << " = NULL" << endl;
}
triggerChannel=imp_set.trigger_channel;
number_of_x_columns=number_of_sets_with_column[0];//save this, because we need to know it and the array will be a counter in future
int max_nr_of_sets=0;
int col_count_import_set=settype_cols(imp_set.set_type);
//cout << "col_count_import_set=" << col_count_import_set << endl;
for (int i=0;i<6;i++)//X,Y,Y1,...,Y4
{
    //cout << i << " = " << number_of_sets_with_column[i] << endl;
    if (number_of_sets_with_column[i] > 0 && i >= col_count_import_set)
    {
        sprintf(dummy,"[Warning] Maximum number of columns for import-set-type %s = %d. The column %s will not be imported!",set_types(imp_set.set_type),col_count_import_set,dataset_colname(i));
        stufftext(dummy);
    }
    if (max_nr_of_sets<number_of_sets_with_column[i]) max_nr_of_sets=number_of_sets_with_column[i];
    number_of_sets_with_column[i]=0;//we will need this as a counter...
}
//qDebug() << "Import from file: " << imp_set.DataFile.toLocal8Bit().constData() << " number_of_new_sets=" << max_nr_of_sets << " to be allocated";
*n_snos=new int[max_nr_of_sets+2];
*n_gnos=new int[max_nr_of_sets+2];
//labels labs;
//tickmarks *t;
int setno;//,ret;
if (imp_set.title!=NULL)
{
    //set_plotstr_string(&labs.title,imp_set.title);
    set_plotstr_string(&(g[imp_set.target_gno].labs.title),imp_set.title);
}
if (imp_set.subtitle!=NULL)
{
    //set_plotstr_string(&labs.stitle,imp_set.subtitle);
    set_plotstr_string(&(g[imp_set.target_gno].labs.stitle),imp_set.subtitle);
}
if (imp_set.x_title!=NULL)
{
    //t = get_graph_tickmarks(imp_set.target_gno, 0);//X
    //set_plotstr_string(&t->label, imp_set.x_title);
    set_plotstr_string(&(g[imp_set.target_gno].t[0]->label), imp_set.x_title);
}
if (imp_set.y_title!=NULL)
{
    //t = get_graph_tickmarks(imp_set.target_gno, 1);//Y
    //set_plotstr_string(&t->label, imp_set.y_title);
    set_plotstr_string(&(g[imp_set.target_gno].t[1]->label), imp_set.y_title);
}
/*
for (int i=0;i<imp_set.channels;i++)
cout<< "Channel[" << i << "]=" << imp_set.set_title[i] << endl;
*/
for (int i=0;i<max_nr_of_sets;i++)
{
setno = nextset(imp_set.target_gno);//allocate new sets
    (*n_snos)[i] = setno;
    (*n_gnos)[i] = imp_set.target_gno;
        set_set_hidden(imp_set.target_gno, setno, FALSE);
        //get_graph_labels(imp_set.target_gno, &labs);
    (void)setlength(imp_set.target_gno,setno,imp_set.points_read);
    (void)set_dataset_type(imp_set.target_gno,setno,imp_set.set_type);
    //if (imp_set.keep_trigger==true && triggerID==i) triggerSet=setno;//triggerChannel --> triggerID
    ///if (imp_set.trigger_channel>=0 && triggerID==i) triggerSet=setno;//triggerChannel --> triggerID
//cout << "setno=" << setno << " len=" << getsetlength(imp_set.target_gno,setno) << " set_type=" << imp_set.set_type << endl;
}//end for-loop over all new sets
//if (triggerChannel>-1 && imp_set.keep_trigger==false)// || (imp_set.keep_trigger==true && triggerSet<0)))//we need an extra set for the trigger channel, that will be deleted later
/// we do the trigger-channel-Stuff afterwards!
/*if (triggerChannel>-1)
{
    triggerSet=nextset(imp_set.target_gno);
    (void)setlength(imp_set.target_gno,triggerSet,imp_set.points_read);
    (void)set_dataset_type(imp_set.target_gno,triggerSet,SET_XY);
    (*n_snos)[max_nr_of_sets] = triggerSet;
    (*n_gnos)[max_nr_of_sets] = imp_set.target_gno;
}*/

//qDebug() << "imp_set.keep_trigger=" << imp_set.keep_trigger << "triggerChannel=" << triggerChannel << "triggerSet=" << triggerSet << "triggerID=" << triggerID;
//now we have generated more than one set!
int col=0,legend_shift=0;
bool contains_x=false;
QList<int> imported_channels;
imported_channels.clear();
for (int i=0;i<imp_set.channels;i++)
{
    if (imp_set.channel_target[i]!=IMPORT_TO_NONE)
    {
    imported_channels << i;
        /*if (imp_set.channel_target[i]==IMPORT_TO_TRIGGER && imp_set.keep_trigger==false)
        {
            memcpy(g[imp_set.target_gno].p[triggerSet].data.ex[1],imp_set.first_data[i],sizeof(double)*imp_set.points_read);
            continue;
        }*/
    //double * n_data=(double*)malloc(sizeof(double)*points_read);
    //memcpy(n_data,imp_set.first_data[i],sizeof(double)*points_read);
        switch (imp_set.channel_target[i])
        {
        case IMPORT_TO_X:
            col=0;
            contains_x=true;
            legend_shift++;
            break;
        case IMPORT_TO_Y:
        case IMPORT_TO_TRIGGER://trigger-channel is always interpreted as Y
            col=1;
            break;
        /*case IMPORT_TO_TRIGGER://trigger-channel is always interpreted as Y
            col=1;
                if (imp_set.keep_trigger==false)
                legend_shift++;
            break;*/
        case IMPORT_TO_Y1:
            col=2;
            break;
        case IMPORT_TO_Y2:
            col=3;
            break;
        case IMPORT_TO_Y3:
            col=4;
            break;
        case IMPORT_TO_Y4:
            col=5;
            break;
        default:
            col=-1;
            break;
        }
        if (col>=col_count_import_set || col<0)
        {
            continue;//go to next channel because the allocated set does not have enough space for this column
        }
    memcpy(g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].data.ex[col],imp_set.first_data[i],sizeof(double)*imp_set.points_read);
    ///memcpy(g[target_gno].p[setno].data.ex[col],imp_set.first_data[i],sizeof(double)*points_read);
//cout << "Channel=" << i << " number_o_ch=" << number_of_sets_with_column[col] << " Legend=" << imp_set.set_title[i] << endl;
        //if (imp_set.channel_target[i]==IMPORT_TO_Y || (imp_set.channel_target[i]==IMPORT_TO_TRIGGER && imp_set.keep_trigger==true))// && imp_set.keep_trigger==true))
        //if (col==1 || (imp_set.channel_target[i]==IMPORT_TO_TRIGGER && imp_set.keep_trigger==true))
        if (col==1 || (imp_set.channel_target[i]==IMPORT_TO_TRIGGER))
        {
        QFileInfo fi(imp_set.DataFile);
        set_identifier=fi.filePath()+QObject::tr(", Channel ")+QString::number(i);
            //if (imp_set.set_title[imp_set.import_dest.at(i)]!=NULL)
            /*if (imp_set.set_title[i]!=NULL && (i<triggerChannel || (i>=triggerChannel && imp_set.keep_trigger==true) ) )
            {
               strcpy(set_identifier_string,imp_set.set_title[i]);
            }
            else if (imp_set.set_title[i]!=NULL && i>triggerChannel && i<max_nr_of_sets)
            {
                strcpy(set_identifier_string,imp_set.set_title[i+1]);
            }*/
            if (inhibit_set_legend==0)
            {
                if (imp_set.set_title[i+legend_shift]!=NULL)
                {
                strcpy(set_identifier_string,imp_set.set_title[i+legend_shift]);
                strcpy(g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].lstr,set_identifier_string);
                strcpy(g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].orig_lstr,set_identifier_string);
                }
                else
                {
                sprintf(set_identifier_string,"binary import from: %s",set_identifier.toLocal8Bit().constData());
                strcpy(g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].lstr,set_identifier_string);
                sprintf(set_identifier_string,"binary import from: %s",set_identifier.toUtf8().constData());
                strcpy(g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].orig_lstr,set_identifier_string);
                }
            }
            strcpy(g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].comments,set_identifier.toLocal8Bit().constData());
            strcpy(g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].orig_comments,set_identifier.toUtf8().constData());
//qDebug() << "setComment=" << set_identifier;
        }
//cout << "channel " << i << " factor=" << imp_set.channel_factors[i] << " offset=" << imp_set.channel_offsets[i] << " col_factor=" << imp_set.factors[col] << endl;
        //if (imp_set.factors[col]!=1.0)
            for (int k=0;k<imp_set.points_read;k++)
            {
            g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].data.ex[col][k]
            =
            g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].data.ex[col][k]*imp_set.factors[col]*imp_set.channel_factors[i]
            +imp_set.channel_offsets[i];
            }
        ///g[target_gno].p[setno].data.ex[col][k]*=imp_set.factors[col];
        number_of_sets_with_column[col]++;
    }
}//data imported into sets

if (contains_x==false)//no X-column set --> initialize every X in every set with header-data
{
    col=0;//x-axis
    double dx=1.0;
    double X0=0.0;
    if (imp_set.deltaxset==false && imp_set.fset==true)
    {
        dx=1.0/imp_set.f;
    }
    else if (imp_set.deltaxset==true && imp_set.fset==false)
    {
        dx=imp_set.deltax;
    }
    else if (imp_set.deltaxset==true && imp_set.fset==true)
    {
        dx=imp_set.deltax;
    }
    if (imp_set.x0set==true) X0=imp_set.x0;
    for (int j=0;j<max_nr_of_sets;j++)//generate an x-axis for all sets
    {
        for (int i=0;i<imp_set.points_read;i++)
        {
            g[imp_set.target_gno].p[(*n_snos)[j]].data.ex[col][i]=i*dx+X0;
        }
    }
}//ende contains_x==false
else//at least one x-column
{
    if (number_of_x_columns==1)//only one X for all sets --> all sets get this column
    {
        for (int j=1;j<max_nr_of_sets;j++)
        {
            memcpy(g[imp_set.target_gno].p[(*n_snos)[j]].data.ex[0],g[imp_set.target_gno].p[(*n_snos)[0]].data.ex[0],sizeof(double)*imp_set.points_read);//copy X-column
        }
    }
    else //some X have been imported and some others not --> give the rest an index as X-column
    {
        for (int j=number_of_x_columns;j<max_nr_of_sets;j++)
        {
            for (int i=0;i<imp_set.points_read;i++)
            {
                g[imp_set.target_gno].p[(*n_snos)[j]].data.ex[col][i]=i*1.0;//write only index numbers into X-columns
            }
        }
    }
}

//do trigger-channel-actions
if (triggerChannel>-1 && imp_set.trigger_type>=0)
{
/*qDebug() << "--- actually do the trigger - stuff ---";
qDebug() << "Trigger-set =" << imp_set.trigger_channel;
qDebug() << "Trigger-type=" << imp_set.trigger_type;
qDebug() << "Trigger-value=" << imp_set.triggervalue;
qDebug() << "Trigger-percent=" << imp_set.trigger_is_percent;*/

double * trigger_data=new double[imp_set.points_read+1];
col=1;//by default the column is a Y-column
if (imported_channels.contains(imp_set.trigger_channel)==true)//if the trigger-channel is imported we use the channel-type
{
    switch (imp_set.channel_target[imp_set.trigger_channel])
    {
    case IMPORT_TO_X:
        col=0;
        break;
    case IMPORT_TO_Y:
    case IMPORT_TO_TRIGGER://trigger-channel is always interpreted as Y
        col=1;
        break;
    case IMPORT_TO_Y1:
        col=2;
        break;
    case IMPORT_TO_Y2:
        col=3;
        break;
    case IMPORT_TO_Y3:
        col=4;
        break;
    case IMPORT_TO_Y4:
        col=5;
        break;
    default:
        col=-1;
        break;
    }
}
if (col<0||col>5)
{
col=1;
//qDebug() << "INVALID IMPORT CHANNEL";
}
memcpy(trigger_data,imp_set.first_data[imp_set.trigger_channel],sizeof(double)*imp_set.points_read);
for (int k=0;k<imp_set.points_read;k++)
{
trigger_data[k]
=
trigger_data[k]*imp_set.factors[col]*imp_set.channel_factors[imp_set.trigger_channel]*imp_set.factors[6]
+imp_set.channel_offsets[imp_set.trigger_channel];
}//[6]=trigger-factor

int trigger_index_pos=0;//at which point in the file the trigger is reached (first point after trigger)
double index_fraction=0.0;//the part between the trigger-index and the index before that that indicates the exact position of the trigger_limit (0=trigger-point, 1=point before trigger-point)
double trigger_shift=0.0;//How much do we have to shift the X-axis?
double trigger_limit=imp_set.triggervalue;
if (imp_set.trigger_is_percent==true && imp_set.points_read>0)
{
double min,max,delta;
min=max=trigger_data[0];
    for (int lll=1;lll<imp_set.points_read;lll++)
    {
    if (trigger_data[lll]>max) max=trigger_data[lll];
    if (trigger_data[lll]<min) min=trigger_data[lll];
    }
delta=max-min;
delta*=imp_set.triggervalue/100.0;
trigger_limit=min+delta;
}
//qDebug() << "Looking for trigger-limit=" << trigger_limit;
if (imp_set.trigger_type==0)//rising edge
{
    for (int lll=1;lll<imp_set.points_read;lll++)
    {
        if (trigger_data[lll-1]<trigger_limit && trigger_data[lll]>=trigger_limit)
        {
            trigger_index_pos=lll;//trigger_shift=g[imp_set.target_gno].p[triggerSet].data.ex[0][lll];
            if (trigger_data[lll-1]==trigger_data[lll]) index_fraction=0.0;
            else index_fraction=(trigger_limit-trigger_data[lll])/(trigger_data[lll-1]-trigger_data[lll]);
            break;
        }
    }
}
else if (imp_set.trigger_type==1)//falling edge
{
    for (int lll=1;lll<imp_set.points_read;lll++)
    {
        if (trigger_data[lll-1]>=trigger_limit && trigger_data[lll]<trigger_limit)
        {
            trigger_index_pos=lll;//trigger_shift=g[imp_set.target_gno].p[triggerSet].data.ex[0][lll];
            if (trigger_data[lll-1]==trigger_data[lll]) index_fraction=0.0;
            else index_fraction=(trigger_limit-trigger_data[lll])/(trigger_data[lll-1]-trigger_data[lll]);
            break;
        }
    }
}
else//either edge
{
    for (int lll=1;lll<imp_set.points_read;lll++)
    {
        if ((trigger_data[lll-1]>=trigger_limit && trigger_data[lll]<trigger_limit) || (trigger_data[lll-1]<trigger_limit && trigger_data[lll]>=trigger_limit))
        {
            trigger_index_pos=lll;//trigger_shift=g[imp_set.target_gno].p[triggerSet].data.ex[0][lll];
            if (trigger_data[lll-1]==trigger_data[lll]) index_fraction=0.0;
            else index_fraction=(trigger_limit-trigger_data[lll])/(trigger_data[lll-1]-trigger_data[lll]);
            break;
        }
    }
}
//qDebug() << "trigger_index_pos=" << trigger_index_pos << "index_fraction=" << index_fraction;
for (int lll=0;lll<max_nr_of_sets;lll++)
{
//qDebug() << "Shifting set G" << imp_set.target_gno << ".S" << (*n_snos)[lll];
trigger_shift=g[imp_set.target_gno].p[(*n_snos)[lll]].data.ex[0][trigger_index_pos];//search in X-column
    if (trigger_index_pos>0)
    {
    trigger_shift-=(g[imp_set.target_gno].p[(*n_snos)[lll]].data.ex[0][trigger_index_pos]-g[imp_set.target_gno].p[(*n_snos)[lll]].data.ex[0][trigger_index_pos-1])*index_fraction;
    }
//qDebug() << "Trigger-Shift=" << trigger_shift;
ShiftSetAxis(imp_set.target_gno,(*n_snos)[lll],-trigger_shift,DATA_X);
}
delete[] trigger_data;
}//end trigger-channel-actions
/*
append_to_storage(&collect_nr_of_sets,&col_gnos,max_nr_of_sets,gnos);//save the set-ids for the undo-operations
collect_nr_of_sets-=max_nr_of_sets;//because collect_nr_of_sets has to be increased in the next function
append_to_storage(&collect_nr_of_sets,&col_snos,max_nr_of_sets,snos);
*/
nr_of_new_sets=max_nr_of_sets;
return RETURN_SUCCESS;
}

///do Read Header not working at the moment for ini-files
void doReadDataFromHeader(ifstream & ifi,struct importSettings & imp_set)
{
    char dummy[512];
    bool integer_type;
    double d_value;
    char buffer[16];
    char * stringText=new char[2];
    int size,readbytes,global_size=0;
//imp_set.first_suggestion=0;/// should be in the parent widget (somehow)

    if (imp_set.header_present==true && imp_set.header_format==HEADER_FORMAT_INI_FILE)
    //if (cmbFormatSource->currentIndex()==2 && cmbHeaderFileFormat->currentIndex()==1)
    {//ini-header in separate file
    /// INI
        /// so viele inits braucht man eigentlich nicht (bzw. man sollte in init unterscheiden, welche Daten man zuruecksetzen will --> nur die gelesenen Daten und nicht die Einstellungen zum Lesen
        /// initSettings(imp_set);
        get_all_settings_from_ini_file(imp_set.HeaderFile,imp_set.keys,imp_set.vals,imp_set.import_channel_dest);
        imp_set.token_target=new int[imp_set.keys.length()+1];

        //for (int i=0;i<tabHeader->nr_of_sels;i++)
        for (int i=0;i<imp_set.nr_of_header_values;i++)
        {
            if (imp_set.header_value_import[i]!=IMPORT_TO_NONE)//tabHeader->sels[i]->currentValue()!=IMPORT_TO_NONE)
            {
                strcpy(dummy,imp_set.vals.at(i).toLocal8Bit().constData());//tabHeader->readValues[i].toLocal8Bit());
                d_value=atof(dummy);
                switch (imp_set.header_value_import[i])//tabHeader->sels[i]->currentValue())
                {
                case IMPORT_TO_TITLE:
                    if (imp_set.title!=NULL)
                        delete[] imp_set.title;
                    imp_set.title=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
                    strcpy(imp_set.title,dummy);
                    break;
                case IMPORT_TO_SET_LEGEND:
                    if (imp_set.set_title[imp_set.import_dest.at(i)]!=NULL)
                        delete[] imp_set.set_title[imp_set.import_dest.at(i)];
                    imp_set.set_title[imp_set.import_dest.at(i)]=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
                    strcpy(imp_set.set_title[imp_set.import_dest.at(i)],dummy);
                    break;
                case IMPORT_TO_X0:
                    imp_set.x0=d_value;
                    imp_set.x0set=true;
                    break;
                case IMPORT_TO_DELTAX:
                    imp_set.deltax=d_value;
                    imp_set.deltaxset=true;
                    break;
                case IMPORT_TO_XTITLE:
                    if (imp_set.x_title!=NULL)
                        delete[] imp_set.x_title;
                    imp_set.x_title=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
                    strcpy(imp_set.x_title,dummy);
                    break;
                case IMPORT_TO_YTITLE:
                    if (imp_set.y_title!=NULL)
                        delete[] imp_set.y_title;
                    imp_set.y_title=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
                    strcpy(imp_set.y_title,dummy);
                    break;
                case IMPORT_TO_XFACTOR:
                    imp_set.factors[0]*=d_value;
                    break;
                case IMPORT_TO_YFACTOR:
                    imp_set.factors[1]*=d_value;
                    break;
                case IMPORT_TO_Y1FACTOR:
                    imp_set.factors[2]*=d_value;
                    break;
                case IMPORT_TO_Y2FACTOR:
                    imp_set.factors[3]*=d_value;
                    break;
                case IMPORT_TO_Y3FACTOR:
                    imp_set.factors[4]*=d_value;
                    break;
                case IMPORT_TO_Y4FACTOR:
                    imp_set.factors[5]*=d_value;
                    break;
                /*case IMPORT_TO_TRIGGER_FACTOR:
                    imp_set.factors[6]*=d_value;
                    break;*/
                case IMPORT_TO_SUBTITLE:
                    if (imp_set.subtitle!=NULL)
                        delete[] imp_set.subtitle;
                    imp_set.subtitle=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
                    strcpy(imp_set.subtitle,dummy);
                    break;
                case IMPORT_TO_NUMBER_OF_DATA:
                    imp_set.points=atoi(dummy);
                    break;
                case IMPORT_TO_NUMBER_OF_CHANNELS:
                    imp_set.channels=atoi(dummy);
                    break;
                case IMPORT_TO_DATA_SIZE:
                    imp_set.bytesize=atoi(dummy);
                    break;
                case IMPORT_TO_DATA_SIZE_BIT:
                    imp_set.bitsize=atoi(dummy);
                    break;
                case IMPORT_TO_DATA_SAMPLING_RATE:
                    imp_set.f=d_value;
                    imp_set.fset=true;
                    break;
                case IMPORT_TO_WHOLE_DATA_BLOCK_SIZE:
                    imp_set.whole_size=atoi(dummy);
                    break;
                case IMPORT_TO_SINGLE_DATA_BLOCK_SIZE:
                    imp_set.single_size=atoi(dummy);
                    break;
                }
            }
        }
    }
    else if (imp_set.header_present==true && imp_set.header_format==HEADER_FORMAT_DATA_FILE)//binary header
    {
//cout << "HEADER IN A BIN-DATA FILE" << endl;
    long * headerDatas=new long[imp_set.nr_of_header_values];
    long double * ldHeaderDatas=new long double[imp_set.nr_of_header_values];
        for (int i=0;i<imp_set.nr_of_header_values;i++)//tabHeader->number_of_lines;i++)
        {
            size=imp_set.header_value_size[i];//tabHeader->inFormats[i]->getSize();
            global_size+=size;
            //if (tabHeader->inFormats[i]->getType()!=COLUMN_OFFSET && tabHeader->inFormats[i]->getType()!=COLUMN_STRING)
            if (imp_set.header_value_format[i]!=COLUMN_OFFSET && imp_set.header_value_format[i]!=COLUMN_STRING)
            {
                ifi.read(buffer,size);
                readbytes=(int)(ifi.gcount());
                if (readbytes!=size)
                {
                    sprintf(dummy,"[Information] Stopped reading header item after import of %d Bytes (of %d bytes).",readbytes,size);
                    stufftext(dummy);
                }
            }
            switch (imp_set.header_value_format[i])//tabHeader->inFormats[i]->getType())
            {
            case COLUMN_OFFSET:
            default:
                integer_type=false;
                for (int j=0;j<size;j++)
                    ifi.read(buffer,1);//read byte after byte into the same buffer (we dont need it)
                break;
            case COLUMN_SIG_CHAR:
                integer_type=true;
                headerDatas[i]=(long)(*((signed char*)((void*)buffer)));
                break;
            case COLUMN_USIG_CHAR:
                integer_type=true;
                headerDatas[i]=(long)(*((unsigned char*)((void*)buffer)));
                break;
            case COLUMN_SIG_SHORT:
                integer_type=true;
                headerDatas[i]=(long)(*((signed short*)((void*)buffer)));
                break;
            case COLUMN_USIG_SHORT:
                integer_type=true;
                headerDatas[i]=(long)(*((unsigned short*)((void*)buffer)));
                break;
            case COLUMN_SIG_INT:
                integer_type=true;
                headerDatas[i]=(long)(*((signed int*)((void*)buffer)));
                break;
            case COLUMN_USIG_INT:
                integer_type=true;
                headerDatas[i]=(long)(*((unsigned int*)((void*)buffer)));
                break;
            case COLUMN_SIG_LONG:
                integer_type=true;
                headerDatas[i]=(long)(*((signed long*)((void*)buffer)));
                break;
            case COLUMN_USIG_LONG:
                integer_type=true;
                headerDatas[i]=(long)(*((unsigned long*)((void*)buffer)));
                break;
            case COLUMN_FLOAT:
                integer_type=false;
                ldHeaderDatas[i]=(long double)(*((float*)((void*)buffer)));
                break;
            case COLUMN_DOUBLE:
                integer_type=false;
                ldHeaderDatas[i]=(long double)(*((double*)((void*)buffer)));
                break;
            case COLUMN_LONG_DOUBLE:
                integer_type=false;
                ldHeaderDatas[i]=(long double)(*((long double*)((void*)buffer)));
                break;
            case COLUMN_STRING:
                integer_type=false;
                if (imp_set.determine_string_size==true)
                {
                    int res=16;
                    int read_s=0;
                    char * targ=new char[res+1];
                    char read_c=imp_set.string_end_char-1;
                    while (read_c!=imp_set.string_end_char)
                    {
                        ifi.read(&read_c,1);
                        targ[read_s]=read_c;
                        read_s++;
                        if (read_s==res)
                        {
                            char * targ2=new char[res+17];
                            memcpy(targ2,targ,sizeof(char)*read_s);
                            delete[] targ;
                            targ=targ2;
                            res+=16;
                        }
                    }
                    targ[read_s]='\0';
                    global_size-=size;
                    size=read_s;
                    /// tabHeader->inFormats[i]->spnSize->setValue(size);
                    global_size+=size;
                    delete[] stringText;
                    stringText=new char[size+2];
                    strcpy(stringText,targ);
                }
                else
                {
                    delete[] stringText;
                    stringText=new char[size+2];
                    ifi.read(stringText,size);
                    stringText[size]='\0';
                    readbytes=(int)(ifi.gcount());
                    if (readbytes!=size)
                    {
                        sprintf(dummy,"[Information] Stopped reading header item after import of %d Bytes (of %d bytes).",readbytes,size);
                        stufftext(dummy);
                    }
                }
                break;
            }//end switch-block

            //if (tabHeader->inFormats[i]->getTarget()!=IMPORT_TO_NONE)
                switch (imp_set.header_value_import[i])
                {
                case IMPORT_TO_NONE:
                    break;
                case IMPORT_TO_TITLE:
                    if (imp_set.title!=NULL)
                        delete[] imp_set.title;
                    imp_set.title=new char[size+1];
                    strcpy(imp_set.title,stringText);
                    break;
                case IMPORT_TO_SET_LEGEND:
                    if (imp_set.set_title[imp_set.import_dest.at(i)]!=NULL)
                        delete[] imp_set.set_title[imp_set.import_dest.at(i)];
                    imp_set.set_title[imp_set.import_dest.at(i)]=new char[size+1];
                    strcpy(imp_set.set_title[imp_set.import_dest.at(i)],stringText);
                    break;
                case IMPORT_TO_X0:
                    if (integer_type)
                        imp_set.x0=headerDatas[i];
                    else
                        imp_set.x0=ldHeaderDatas[i];
                    imp_set.x0set=true;
                    break;
                case IMPORT_TO_DELTAX:
                    if (integer_type)
                        imp_set.deltax=headerDatas[i];
                    else
                        imp_set.deltax=ldHeaderDatas[i];
                    imp_set.deltaxset=true;
                    break;
                case IMPORT_TO_XTITLE:
                    if (imp_set.x_title!=NULL)
                        delete[] imp_set.x_title;
                    imp_set.x_title=new char[size+1];
                    strcpy(imp_set.x_title,stringText);
                    break;
                case IMPORT_TO_YTITLE:
                    if (imp_set.y_title!=NULL)
                        delete[] imp_set.y_title;
                    imp_set.y_title=new char[size+1];
                    strcpy(imp_set.y_title,stringText);
                    break;
                case IMPORT_TO_XFACTOR:
                    if (integer_type)
                        imp_set.factors[0]*=headerDatas[i];
                    else
                        imp_set.factors[0]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_YFACTOR:
                    if (integer_type)
                        imp_set.factors[1]*=headerDatas[i];
                    else
                        imp_set.factors[1]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y1FACTOR:
                    if (integer_type)
                        imp_set.factors[2]*=headerDatas[i];
                    else
                        imp_set.factors[2]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y2FACTOR:
                    if (integer_type)
                        imp_set.factors[3]*=headerDatas[i];
                    else
                        imp_set.factors[3]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y3FACTOR:
                    if (integer_type)
                        imp_set.factors[4]*=headerDatas[i];
                    else
                        imp_set.factors[4]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y4FACTOR:
                    if (integer_type)
                        imp_set.factors[5]*=headerDatas[i];
                    else
                        imp_set.factors[5]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y_OFFSET:
                    if (integer_type)
                        imp_set.offsets[1]*=headerDatas[i];
                    else
                        imp_set.offsets[1]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y1_OFFSET:
                    if (integer_type)
                        imp_set.offsets[2]*=headerDatas[i];
                    else
                        imp_set.offsets[2]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y2_OFFSET:
                    if (integer_type)
                        imp_set.offsets[3]*=headerDatas[i];
                    else
                        imp_set.offsets[3]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y3_OFFSET:
                    if (integer_type)
                        imp_set.offsets[4]*=headerDatas[i];
                    else
                        imp_set.offsets[4]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y4_OFFSET:
                    if (integer_type)
                        imp_set.offsets[5]*=headerDatas[i];
                    else
                        imp_set.offsets[5]*=ldHeaderDatas[i];
                    break;
                /*case IMPORT_TO_TRIGGER_FACTOR:
                    if (integer_type)
                        imp_set.factors[6]*=headerDatas[i];
                    else
                        imp_set.factors[6]*=ldHeaderDatas[i];
                    break;*/
                case IMPORT_TO_SUBTITLE:
                    delete[] imp_set.subtitle;
                    imp_set.subtitle=new char[size+1];
                    strcpy(imp_set.subtitle,stringText);
                    break;
                case IMPORT_TO_NUMBER_OF_DATA:
                    imp_set.points=headerDatas[i];
                    break;
                case IMPORT_TO_NUMBER_OF_CHANNELS:
                    imp_set.channels=headerDatas[i];
                    break;
                case IMPORT_TO_DATA_SIZE:
                    imp_set.bytesize=headerDatas[i];
                    break;
                case IMPORT_TO_DATA_SIZE_BIT:
                    imp_set.bitsize=headerDatas[i];
                    break;
                case IMPORT_TO_DATA_SAMPLING_RATE:
                    if (integer_type)
                        imp_set.f=headerDatas[i];
                    else
                        imp_set.f=ldHeaderDatas[i];
                    imp_set.fset=true;
                    break;
                case IMPORT_TO_WHOLE_DATA_BLOCK_SIZE:
                    imp_set.whole_size=headerDatas[i];
                    break;
                case IMPORT_TO_SINGLE_DATA_BLOCK_SIZE:
                    imp_set.single_size=headerDatas[i];
                    break;
                }
        }//end loop through lines
        delete [] headerDatas;
        delete [] ldHeaderDatas;
    }//end reading binary header
    else//ascii-header
    {

    }

    delete[] stringText;
    //int bsize;
//cout << "first_suggestion=" << first_suggestion << " bits=" << imp_set.bitsize << endl;

    /*imp_set.first_suggestion=-1;
    if (imp_set.bitsize!=-1)
    {
        bsize=imp_set.bitsize/8;
        if (bsize*8==imp_set.bitsize)//add suggestions for import
        {
            for (int i=0;i<NUMBER_OF_COLUMN_FORMATS;i++)
            {
                if (binaryImportFormat[i].size==bsize)
                {
                    if (imp_set.first_suggestion==-1)
                    imp_set.first_suggestion=i;
                }
            }
        }
    }*/

//cout << "first_suggestion=" << first_suggestion << " bytes=" << imp_set.bytesize << endl;

    /*if (imp_set.bytesize!=-1)
    {
        imp_set.first_suggestion=-1;
        for (int i=0;i<NUMBER_OF_COLUMN_FORMATS;i++)
        {
            if (binaryImportFormat[i].size==imp_set.bytesize)
            {
                if (imp_set.first_suggestion==-1)
                    imp_set.first_suggestion=i;
            }
        }
    }*/

//cout << "first_suggestion=" << first_suggestion << endl;
//cout << imp_set.points << " " << imp_set.whole_size << " " << imp_set.bytesize << " " << imp_set.bitsize << endl;
    if (imp_set.points<=0 && imp_set.whole_size!=-1 && (imp_set.bytesize!=-1 || imp_set.bitsize!=-1))
    {
        int size=imp_set.bytesize!=-1?imp_set.bytesize:imp_set.bitsize/8;
        imp_set.points=imp_set.whole_size/size;
        if (imp_set.channels>0)
            imp_set.points/=imp_set.channels;
    }
//cout << "points=" << imp_set.points << " whole=" << imp_set.whole_size << " byte=" << imp_set.bytesize << " bit=" << imp_set.bitsize << " global_size=" << global_size << endl;
    imp_set.headersize=global_size;
}

void binary_load_Phase1(QString Header_Filename,QString Data_Filename,struct importSettings & imp_set,struct importSettings & imp_scheme)//load header and initialize imp_set
{
insert_filenames_in_settings(imp_set,imp_scheme,Header_Filename,Data_Filename);
readHeaderData(imp_set,imp_scheme);
}

/*void binary_load_Phase2(struct importSettings & imp_set,struct importSettings & imp_scheme)//compare imp_set with imp_schema to prepare for binary import
{

}*/

void binary_load_Phase3(struct importSettings & imp_set)//the actual import (just reading the data)
{
//ifstream ifi;
//ifi.open(imp_set.DataFile.toLocal8Bit().constData(),ios::binary);
QByteArray ba;
QBuffer buffer;
int ret=LoadFileIntoByteArray(imp_set.DataFile,ba);
if (ret==RETURN_FAILURE) qDebug() << "Unable to load file into ByteArray";

buffer.setBuffer(&ba);
buffer.open(QIODevice::ReadOnly);
readBinaryFromFile(buffer,imp_set,&imp_set.first_data);
//ifi.close();
buffer.close();
}

void binary_load_Phase4(struct importSettings & imp_set,int & nr_of_new_sets,int ** n_gnos,int ** n_snos)//the postprocessing of the data
{
int ret=postprocess_bin_import_data(imp_set,nr_of_new_sets,n_gnos,n_snos);
    if (ret!=RETURN_SUCCESS)
    {
    qDebug() << "Problem during binary postprocessing!";// << endl;
    }
}

void frmBinaryFormatInput::transmitInfos(void)//this function is used after data has been read from a header to update the settings in the gui
{
    QByteArray ba;
    int tmpA;
    bool tmpB,tmpC;
    int sav_setOrdering,sav_triggerChannel,sav_triggerVal,sav_triggerType,sav_autoScale,sav_setType,sav_compression;
    QString sav_text;
//qDebug() << "transmitInfos: ReRead Header";
initSettings(imp_scheme,true);
initSettings(imp_set,true);
readAndCompleteFileNames(2,tmpA,tmpB);

sav_setType=tabImportInfo->selType->currentIndex();
sav_autoScale=tabImportInfo->selAutoscale->currentIndex();
tmpB=tabDataInfo->chkReadToEOF->isChecked();
sav_triggerChannel=tabDataInfo->selTriggerSet->currentIndex();
sav_setOrdering=tabDataInfo->selOrder->currentIndex();
sav_text=tabDataInfo->selTriggerValue->text();
if ((tmpA=sav_text.indexOf("%"))>=0)
{
tmpC=true;
sav_text=sav_text.left(tmpA);
}
else
{
tmpC=false;
}
sav_triggerVal=sav_text.toDouble();
sav_triggerType=tabDataInfo->selTriggerType->currentValue();
sav_compression=tabDataInfo->selDataCompressed->method();

//qDebug() << "transmitInfos: Read Filenames";
//qDebug() << "A transmitInfos: setorder=" << imp_set.setorder;
if (datFileNames.length()>0)
{
imp_set.DataFile=datFileNames.at(0);
}
if (headerFileNames.length()>0)
{
imp_set.HeaderFile=headerFileNames.at(0);
}
readSettings(imp_scheme,0);//just read header-settings
readSettings(imp_set,0);//just read header-settings
//qDebug() << "B transmitInfos: setorder=" << imp_set.setorder;
//qDebug() << "transmitInfos: after readSettings";
tabHeader->read_header_settings(imp_scheme);
tabHeader->read_header_settings(imp_set);
//qDebug() << "C transmitInfos: setorder=" << imp_set.setorder;
//qDebug() << "transmitInfos: after tabHeader->read_header_settings";
readHeader();
//qDebug() << "D transmitInfos: setorder=" << imp_set.setorder;
tabImportInfo->selType->setCurrentIndex(sav_setType);
imp_set.set_type=sav_setType;
tabImportInfo->selAutoscale->setCurrentIndex(sav_autoScale);
imp_set.autoscale=sav_autoScale;
tabDataInfo->chkReadToEOF->setChecked(tmpB);
imp_set.read_to_eof=tmpB;
tabDataInfo->selTriggerSet->setCurrentIndex(sav_triggerChannel);
imp_set.trigger_channel=sav_triggerChannel;
tabDataInfo->selOrder->setCurrentIndex(sav_setOrdering);
imp_set.setorder=sav_setOrdering;
tabDataInfo->selTriggerValue->setText(sav_text);
imp_set.trigger_is_percent=tmpC;
imp_set.triggervalue=sav_triggerVal;
tabDataInfo->selTriggerType->setCurrentValue(sav_triggerType);
imp_set.trigger_type=sav_triggerType;
tabDataInfo->selDataCompressed->setMethod(sav_compression);
imp_set.data_is_compressed=sav_compression;

imp_set.valid_status=1;
imp_scheme.valid_status=1;
//qDebug() << "transmitting Infos";
    if (tabFileInfo->DatFile!=NULL) delete[] tabFileInfo->DatFile;
    if (tabFileInfo->HeaderFile!=NULL) delete[] tabFileInfo->HeaderFile;
//cout << "bin_file_nr_to_import=" << bin_file_nr_to_import << endl;
//cout << "datFileNames.length()=" << datFileNames.length() << endl;
    if (datFileNames.length()<=bin_file_nr_to_import || bin_file_nr_to_import<0)
    {
    tabFileInfo->DatFile=NULL;
    }
    else
    {
    ba=datFileNames.at(bin_file_nr_to_import).toLocal8Bit();
    tabFileInfo->DatFile=new char[ba.length()+8];
    strcpy(tabFileInfo->DatFile,ba.constData());
    }
    if (headerFileNames.length()<=bin_file_nr_to_import || bin_file_nr_to_import<0)
    {
    tabFileInfo->HeaderFile=NULL;
    }
    else
    {
    ba=headerFileNames.at(bin_file_nr_to_import).toLocal8Bit();
    tabFileInfo->HeaderFile=new char[ba.length()+8];
    strcpy(tabFileInfo->HeaderFile,ba.constData());
    }
    convertSettingsToString();
    tabFileInfo->headerContents=settingString;
    tabFileInfo->ShowInfos();
//cout << "channels=" << imp_set.channels << endl;
    if (imp_set.channels>0) tabDataInfo->spnChannelCount->setValue(imp_set.channels);
    else tabDataInfo->spnChannelCount->setValue(0);
    tabDataInfo->channelCountChanged(tabDataInfo->spnChannelCount->value());
    if (imp_set.points>0) tabDataInfo->spnDataSetCount->setValue(imp_set.points);
    else tabDataInfo->spnDataSetCount->setValue(0);
    qApp->processEvents();
    tabDataInfo->selOrder->setCurrentValue(imp_set.setorder);
//qDebug() << "setOrder=" << imp_set.setorder;
    tabDataInfo->selTriggerType->setCurrentValue(imp_set.trigger_type);
    ///tabDataInfo->selTriggerValue->setValue(imp_set.triggervalue);
    char dummy[128];
    sprintf(dummy,"%g",imp_set.triggervalue);
    QString set_Text(dummy);
    if (imp_set.trigger_is_percent==true)
    {
    set_Text+=QString(" %");
    }
    Replace_Dec_Sep_In_Single_String(set_Text);
    tabDataInfo->selTriggerValue->setText(set_Text);
//cout << "NumberOfLines=" << tabDataInfo->number_of_lines << endl;
    qApp->processEvents();
        if (imp_set.format_suggestion!=NULL && imp_set.channel_size!=NULL && imp_set.channel_target!=NULL)
        {
        //qDebug() << "imp_set.channel_format_known=true";
            for (int i=0;i<tabDataInfo->number_of_lines;i++)
            {
            tabDataInfo->inFormats[i]->cmbFormat->setCurrentIndex(imp_set.format_suggestion[i]);
            tabDataInfo->inFormats[i]->spnSize->setValue(imp_set.channel_size[i]);
            tabDataInfo->inFormats[i]->cmbImportAs->setCurrentIndex(imp_set.channel_target[i]-1);
            }
        }
        /*else
        {
        qDebug() << "imp_set.channel_format_known=false";
        }*/
}

void frmBinaryFormatInput::convertSettingsToString(void)
{
    int bsize;
    first_suggestion=-1;
    char dummy[512];
    char dummy2[4];
    QString result(tr("Data read from Header:\n"));
    result.append(tr("Header size= ")+QString::number(imp_set.headersize)+QString(" bytes\n"));
    if (imp_set.title!=NULL)
        if (imp_set.title[0]!='\0')
            result.append(tr("Set title= ")+QString(imp_set.title)+QString("\n"));
    if (imp_set.subtitle!=NULL)
        if (imp_set.subtitle[0]!='\0')
            result.append(tr("Set subtitle= ")+QString(imp_set.subtitle)+QString("\n"));
    if (imp_set.x_title!=NULL)
        if (imp_set.x_title[0]!='\0')
            result.append(tr("Set x-title= ")+QString(imp_set.x_title)+QString("\n"));
    if (imp_set.y_title!=NULL)
        if (imp_set.y_title[0]!='\0')
            result.append(tr("Set y-title= ")+QString(imp_set.y_title)+QString("\n"));
    /*if (imp_set.set_title!=NULL)
        if (imp_set.set_title[0]!='\0')
            result.append(tr("Set-title= ")+QString(imp_set.set_title)+QString("\n"));*/
    for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
    {
    if (imp_set.set_title[i]!=NULL)
        if (imp_set.set_title[i][0]!='\0')
            result.append(tr("Set-title[")+QString::number(i)+QString("]= ")+QString(imp_set.set_title[i])+QString("\n"));
    }

    if (imp_set.x0set)
    {
        sprintf(dummy,"%g\n",imp_set.x0);
        result.append(tr("X0= ")+QString(dummy));
    }
    if (imp_set.deltaxset)
    {
        sprintf(dummy,"%g\n",imp_set.deltax);
        result.append(tr("deltaX= ")+QString(dummy));
    }
    if (imp_set.fset)
    {
        sprintf(dummy,"%g samples/sec\n",imp_set.f);
        result.append(tr("Sampling rate= ")+QString(dummy));
    }
    if (imp_set.channels!=-1)
    {
        sprintf(dummy,"%d\n",imp_set.channels);
        result.append(tr("Channels= ")+QString(dummy));
    }
    if (imp_set.points!=-1)
    {
        sprintf(dummy,"%d\n",imp_set.points);
        result.append(tr("Sample count= ")+QString(dummy));
    }
    for (int i=0;i<6;i++)
    {
        if (i==0) strcpy(dummy2,"X");
        else if (i==1) strcpy(dummy2,"Y");
        else sprintf(dummy2,"Y%d",i-1);
        if (imp_set.factors[i]!=1.0)
        {
            sprintf(dummy,"Factor for %s = %g\n",dummy2,imp_set.factors[i]);
            result.append(QString(dummy));
        }
    }
    if (imp_set.bitsize!=-1 && imp_set.bytesize==-1)
    {
        bsize=imp_set.bitsize/8;
        if (bsize*8==imp_set.bitsize)
            sprintf(dummy,"%d bits = %d bytes\n",imp_set.bitsize,imp_set.bytesize);
        else
            sprintf(dummy,"%d bits (not a multiple of 8)\n",imp_set.bitsize);
        result.append(tr("Size of sample= ")+QString(dummy));
        if (bsize*8==imp_set.bitsize)//add suggestions for import
        {
            for (int i=0;i<NUMBER_OF_COLUMN_FORMATS;i++)
            {
                if (binaryImportFormat[i].size==bsize)
                {
                    result.append(tr("Suggested import format= ")+QString(binaryImportFormatName[binaryImportFormat[i].format])+QString("\n"));
                    if (first_suggestion==-1)
                        first_suggestion=i;
                }
            }
        }
    }
    if (imp_set.bytesize!=-1)
    {
        first_suggestion=-1;
        sprintf(dummy,"%d bytes\n",imp_set.bytesize);
        result.append(tr("Size of sample= ")+QString(dummy));
        for (int i=0;i<NUMBER_OF_COLUMN_FORMATS;i++)
        {
            if (binaryImportFormat[i].size==imp_set.bytesize)
            {
                result.append(tr("Suggested import format= ")+QString(binaryImportFormatName[binaryImportFormat[i].format])+QString("\n"));
                if (first_suggestion==-1)
                    first_suggestion=i;
            }
        }
    }

    if ((imp_set.bytesize!=-1 || imp_set.bitsize!=-1) && imp_set.channels!=-1 && imp_set.points!=-1)
    {
        int bsize=imp_set.bytesize!=-1?imp_set.bytesize:imp_set.bitsize/8;
        int whole=bsize*imp_set.channels*imp_set.points;
        sprintf(dummy,"Data block size= %d Bytes\n",whole);
        result.append(QString(dummy));
        sprintf(dummy,"File section to be read= %d Bytes\n",whole+imp_set.headersize);
        result.append(QString(dummy));
    }

    if (imp_set.first_data!=NULL)
    {
        result.append(QString("\n"));
        result.append(tr("First 10 datapoints:\n"));
        QString strli=QString("Nr.:\t");
        for (int i=0;i<imp_set.channels;i++)
        {
            sprintf(dummy,"ch%d\t",i);
            strli=strli+QString(dummy);
        }
        strli=strli+QString("\n");
        result.append(strli);
        for (int j=0;j<10;j++)
        {
            sprintf(dummy,"%d:\t",j);
            strli=QString(dummy);
            for (int i=0;i<imp_set.channels;i++)
            {
                sprintf(dummy,"%g\t",imp_set.first_data[i][j]);
                strli=strli+QString(dummy);
            }
            strli=strli+QString("\n");
            result.append(strli);
        }
    }
    settingString=result;
}

void readBinaryFromFile(QBuffer & ifi,importSettings & imp_set,double *** data)
{
    char buffer[64];
    (*data)=new double*[imp_set.channels];
    long long position=ifi.pos();//tellg();//current position (assuming we already have read the header)
    long long length;
    //ifi.seekg(0,ios::end);
    length=ifi.size();//tellg();//length complete
    if (position!=imp_set.headersize) position=imp_set.headersize;
//qDebug() << "length=" << length << " position=" << position;
    length-=position;//length without header
    ifi.seek(position);//go to first byte after header
//qDebug() << "resulting length=" << length << "imp_set.channels=" << imp_set.channels;
    long size_of_one_point=0;
    long * size_of_one_set=new long[imp_set.channels];
    long calc_samp_count;
        for (int i=0;i<imp_set.channels;i++)
        size_of_one_point+=(long)(imp_set.channel_size[i]);
//qDebug() << "size_of_one_point=" << size_of_one_point;
    calc_samp_count=length/(size_of_one_point);
        if (imp_set.points>=0 && imp_set.points<calc_samp_count)
        imp_set.points_read=imp_set.points;
        else
        imp_set.points_read=calc_samp_count;

    if (imp_set.read_to_eof==true) imp_set.points_read=calc_samp_count;
//qDebug() << "calc_samp_count=" << calc_samp_count;
#ifndef WINDOWS_SYSTEM
        try
        {
#endif
            for (int i=0;i<imp_set.channels;i++)//space for ALL channels
            (*data)[i]=new double[imp_set.points_read+1];//we need a bit more space because we need to store extra data into dummy location
#ifndef WINDOWS_SYSTEM
        }
        catch (bad_alloc)
        {
            errwin(QObject::tr("Unable to allocate enough memory to import binary data.").toLocal8Bit().constData());
            return;
        }
#endif
        for (int i=0;i<imp_set.channels;i++)
        size_of_one_set[i]=calc_samp_count*imp_set.channel_size[i];//the byte-size in the file
//qDebug() << "size_of_one_point=" << size_of_one_point << " calc.samp.count=" << calc_samp_count;
    imp_set.columns_read=imp_set.channels;
    int i=0;//channel_nr
    int read=0;//current number of read data
    int real_read=0;//counts on even, if the channel has more data than is to be read
    //start reading with channel=0 and read=0
//qDebug() << "Start: Pos=" << ifi.pos() << "Size=" << ifi.size();
    while (ifi.pos()<ifi.size())// !ifi.eof())
    {
        ifi.read(buffer,imp_set.channel_size[i]);//read current input
        //and save it as double in the right position
        switch (imp_set.channel_format[i])
        {
        case COLUMN_OFFSET:
        case COLUMN_STRING:
            (*data)[i][read]=0.0;
            break;
        case COLUMN_SIG_CHAR:
            (*data)[i][read]=(double)(*((signed char*)((void*)(buffer))));
            break;
        case COLUMN_USIG_CHAR:
            (*data)[i][read]=(double)(*((unsigned char*)((void*)(buffer))));
            break;
        case COLUMN_SIG_SHORT:
            (*data)[i][read]=(double)(*((signed short*)((void*)(buffer))));
            break;
        case COLUMN_USIG_SHORT:
            (*data)[i][read]=(double)(*((unsigned short*)((void*)(buffer))));
            break;
        case COLUMN_SIG_INT:
            (*data)[i][read]=(double)(*((signed int*)((void*)(buffer))));
            break;
        case COLUMN_USIG_INT:
            (*data)[i][read]=(double)(*((unsigned int*)((void*)(buffer))));
            break;
        case COLUMN_SIG_LONG:
            (*data)[i][read]=(double)(*((signed long*)((void*)(buffer))));
            break;
        case COLUMN_USIG_LONG:
            (*data)[i][read]=(double)(*((unsigned long*)((void*)(buffer))));
            break;
        case COLUMN_FLOAT:
            (*data)[i][read]=(double)(*((float*)((void*)(buffer))));
            break;
        case COLUMN_DOUBLE:
            (*data)[i][read]=(double)(*((double*)((void*)(buffer))));
            break;
        case COLUMN_LONG_DOUBLE:
            (*data)[i][read]=(double)(*((long double*)((void*)(buffer))));
            break;
        }//end switch
        if (imp_set.setorder==1)//channel1|channel2|channel3| etc.
        {
            //next point in channel
            real_read++;//this counts the sample-points actually read
            if (real_read>=imp_set.points_read)//we have reached a point where there is no more data for this channel that is to be read
            {
                if (calc_samp_count>imp_set.points_read)//there is more data in the file than we actually need to read
                {
                    if (real_read>=calc_samp_count)//we have read enough
                    {
                        read=real_read=0;
                        i++;//next channel
                    }
                    else
                        read=imp_set.points_read;//we write all new data to the space just outside the read data we actually need
                }
                else//calc_samp_count==*points_read --> we are actually at the end of the data for one channel
                {
                    real_read=read=0;
                    i++;
                }

                if (i>=imp_set.channels)//no more channels available
                {
                    read=imp_set.points_read;
                    break;
                }
            }
            else
                read++;//no problems here --> read_count is identical to real_read_count
        }
        else //x1y1z1|x2y2z2|x3y3z3|x4y4z4| etc.
        {
            //read one point after the other
            //next channel
            i++;
            if (i>=imp_set.channels)//next point will start
            {
                i=0;//next point starts with ch0
                if (read<imp_set.points_read)//we have read less points than needed
                    read++;//read next point
                else
                    break;//we have read enough --> stop reading
            }
        }//ende channel_order
    }//end while(!eof)
//qDebug() << "read=" << read << "imp_set.points_read=" << imp_set.points_read;
    if (read!=imp_set.points_read)
    {
        cout << "error in reading: wrong count after eof: read=" << read << " points=" << imp_set.points_read << endl;
        imp_set.points_read=read;
    }
    delete[] size_of_one_set;
}

frmSetEditor::frmSetEditor(QWidget * parent):QDialog(parent)
{
    fname=new char[GR_MAXPATHLEN];
    fname[0]='\0';
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: SetEditor"));
    setWindowIcon(QIcon(*GraceIcon));
    layout=new QVBoxLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    layout1=new QHBoxLayout;
    //layout1->setMargin(STD_MARGIN);
    layout1->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
    empty=new QWidget;
    empty->setLayout(layout1);
    lenFromGraph=new QLineEdit(QString("0"),empty);
    lenFromSet=new QLineEdit(QString("0"),empty);
    labDataFrom1=new QLabel(tr("Data in Set G"),empty);
    labDataFrom2=new QLabel(QString(".S"),empty);
    layout1->addWidget(labDataFrom1);
    layout1->addWidget(lenFromGraph);
    layout1->addWidget(labDataFrom2);
    layout1->addWidget(lenFromSet);
    text=new QTextEdit(this);
    aac=new stdButtonGroup(this,true,false,false);
    aac->cmdApply->setText(tr("Update"));
    connect(aac->cmdApply,SIGNAL(clicked()),SLOT(doUpdate()));
    connect(aac->cmdClose,SIGNAL(clicked()),SLOT(doClose()));
    gno=0;
    setno=0;
    layout->addWidget(empty);
    layout->addWidget(text);
    layout->addWidget(aac);
    setLayout(layout);
    resize(LastSize_FormSetEditor);
}

frmSetEditor::~frmSetEditor()
{
    delete[] fname;
    LastSize_FormSetEditor=this->size();
}

void frmSetEditor::init(int g_no,int set_no)
{
    //write set data to file and read file contents
    char dummy[512];
    gno=g_no;
    setno=set_no;
    if (fname[0]=='\0')
    {
        QTemporaryFile * temp_file=new QTemporaryFile;
        if (temp_file->open())
        {
            delete[] fname;
            fname=new char[temp_file->fileName().size()+8];
            strcpy(fname,temp_file->fileName().toLocal8Bit());
            temp_file->close();
            delete temp_file;
        }
    }
    QFile * fi=new QFile(QString(fname));
    fi->remove();
    delete fi;
    //fname = tmpnam(NULL);//get a temporary file name
    sprintf(dummy,"%d",g_no);
    lenFromGraph->setText(QString(dummy));
    sprintf(dummy,"%d",set_no);
    lenFromSet->setText(QString(dummy));
    FILE *cp;
    cp = grace_openw(fname);
    if (cp == NULL)
    {
        return;
    }
    write_set(gno, setno, cp, sformat, FALSE, TRUE);
    grace_close(cp);
    QString str("");
    dummy[0]='\0';
    int counter=0;
    FILE * ifi;
    ifi=fopen(fname,"r");
    while (!feof(ifi))
    {
        if (fscanf(ifi,"%c",dummy+counter++)<=0) continue;
        dummy[511]='\0';
        if (counter==511)
        {
            str=str+QString(dummy);
            counter=0;
        }
    }
    dummy[counter-1]='\0';
    str=str+QString(dummy);
    fclose(ifi);
    text->setText(str);
    if (DecimalPointToUse==',')
        convertText('.',',');
}

void frmSetEditor::doUpdate(void)
{
    //write data from QTextEdit to file and read file into Grace
    if (DecimalPointToUse==',') convertText(',','.');
    QString content=text->toPlainText();
    if (DecimalPointToUse==',') convertText('.',',');
    xv_evalexpri(lenFromGraph,&gno);
    xv_evalexpri(lenFromSet,&setno);
    char * dummy;
    int target_index=content.indexOf(QString("@target"));
    bool target_defined=(target_index==-1)?false:true;
    dummy=new char[256];
    sprintf(dummy,"@target G%d.S%d",gno,setno);
    QStringList st1=content.split('\n');
    ofstream ofi;
    ofi.open(fname);
    if (target_defined==false)
    {
        ofi << dummy << endl << content.toLocal8Bit().constData() << endl << "&" << endl;
    }
    else//target defined --> replace it with the set-id
    {
        content.clear();
        for (int i=0;i<st1.length();i++)
        {
            if (st1.at(i).length()>0)
            {
                if (st1.at(i).indexOf(QString("@target"))>=0)
                {
                    content.append(QString(dummy)+QString('\n'));
                    ofi << dummy << endl;
                }
                else
                {
                    content.append(st1.at(i)+QString('\n'));
                    ofi << st1.at(i).toLocal8Bit().constData() << endl;
                }
            }
        }
        text->setText(content);
        if (DecimalPointToUse==',') convertText('.',',');
    }
    ofi.close();

    /* temporarily disable autoscale */
    int save_autos = autoscale_onread;
    autoscale_onread = AUTOSCALE_NONE;
    int gnos[2],snos[2],created;
    gnos[0]=gno;
    snos[0]=setno;
    //it has been here
    if ((bool)(created=is_set_active(gno, setno)))//if set already exists: delete data
    {
        SaveSetStatesPrevious(1,gnos,snos,UNDO_COMPLETE);
        curtype = dataset_type(gno, setno);
        killsetdata(gno, setno);
    }
    prepare_strings_for_saving();
    getdata(gno, fname, SOURCE_DISK, LOAD_SINGLE);
    resume_strings_after_load_or_save();
    setcomment(gno, setno, tr("Editor").toLocal8Bit().constData());
    autoscale_onread = save_autos;
    if (created==TRUE)//'created' is not the right word...
    {
        SetsModified(1,gnos,snos,UNDO_COMPLETE);
    }
    else
    {
        SetsCreated(1,gnos,snos,UNDO_COMPLETE);
    }
    sprintf(dummy," [G%d.S%d]",gno,setno);
    if (!created==false)
        addAditionalDescriptionToLastNode(-1,QObject::tr("Edit set in text editor")+QString(dummy),QString(),-1);
    else
        addAditionalDescriptionToLastNode(-1,QObject::tr("Create set in text editor")+QString(dummy),QString(),-1);
    delete[] dummy;
    mainWin->mainArea->completeRedraw();
}

void frmSetEditor::doClose(void)
{
    //delete files and all entries and hide this Window
    hide();
    text->clear();
    //fname=NULL;
}

void frmSetEditor::convertText(char oldDecSep,char newDecSep)
{
    if (oldDecSep==newDecSep) return;
    QString nl('\n');
    QString st=text->toPlainText(),st2;
    QStringList l1=st.split(QChar('\n'));
    st.clear();
    for (int i=0;i<l1.length();i++)
    {
        if (l1.at(i).length()>0)
        {
            if (l1.at(i).at(0)=='&' || l1.at(i).at(0)=='@')
            {
                st.append(l1.at(i)+nl);
            }
            else
            {
                st2=l1.at(i);
                if (oldDecSep=='.')//.-->,
                {
                st2.replace(QChar(','),QChar('|'));
                st2.replace(oldDecSep,newDecSep);
                }
                else
                {
                st2.replace(oldDecSep,newDecSep);
                st2.replace(QChar('|'),QChar(','));
                }
                st.append(st2+nl);
            }
        }
    }
    text->setText(st);
}

#define MAX_INPUT_LINE_LENGTH 2048
char linebuffer[MAX_INPUT_LINE_LENGTH];
int nextlinebufferpos=0;

int readLineFromFile(QFile * fi,struct csv_import_infos & import_info,char ** tline)
{//read from fi until EOF is reached or a lineSeparator-char is found (uses linebuffer if lineSeparator!='\n')
    static int counter,stringcounter,tokenlength,colcounter;
    static QByteArray line;
    static char * tmp_pointer;
    tmp_pointer=NULL;
    tokenlength=stringcounter=counter=0;//stringcounter counts '"', counter counts tokens (only 0 or 1 token read)
    if (fi->atEnd()==true && nextlinebufferpos==0)
    {
        //cout << "File at End !" << endl;
        return RETURN_FAILURE;//EOF and no more data in buffer
    }
    if (import_info.datsep=='\n')//simple case
    {
        //cout << "simple case" << endl;
        while (!fi->atEnd() && counter<1)
        {
            line = fi->readLine(MAX_INPUT_LINE_LENGTH);
            if (line.length()<1) return RETURN_FAILURE;
            delete[] *tline;
            (*tline)=new char[line.length()+2];
            strncpy(*tline,line.constData(),line.length());
            (*tline)[line.length()-1]='\0';//-1 because new-line-character is included and we don't need it!
            (*tline)[line.length()]='\0';
            (*tline)[line.length()+1]='\0';
            counter++;
        }
    }
    else//special character for line-separation
    {
        //cout << "complex case = #" << linebuffer << "#" << endl;
        while ((!fi->atEnd() || nextlinebufferpos>0) && counter<1)
        {
            if (!fi->atEnd())//more data in file-->read data to buffer
            {
                line = fi->readLine(MAX_INPUT_LINE_LENGTH-nextlinebufferpos);
                strncpy(linebuffer+nextlinebufferpos,line.constData(),line.length());/// Possible Problem: line.length() > MAX_INPUT_LINE_LENGTH !!
                nextlinebufferpos+=line.length();
                if (nextlinebufferpos>MAX_INPUT_LINE_LENGTH-1) nextlinebufferpos=MAX_INPUT_LINE_LENGTH-1;//if this is necessary, the program will crash anyway
                linebuffer[nextlinebufferpos]='\0';
                //cout << "new Linebuffer = #" << linebuffer << "#" << endl;
            }
            //nextlinebufferpos is the amount of data still present in linebuffer
            //use linebuffer to get data
            colcounter=0;
            //now we have to look for a suitable lineSeparator
            for (int k=0;k<nextlinebufferpos;k++)
            {
                if (linebuffer[k]==import_info.textsep)
                {
                    stringcounter++;
                }
                else if (linebuffer[k]==import_info.colsep)
                {
                    colcounter++;
                }
                else if (linebuffer[k]==import_info.datsep && stringcounter%2==0)
                {
                    /// TODO: INSERT MISSING SEARCH RESTRICTIONS ABOUT string-separators
                    tokenlength=k;
                    break;
                }
            }
            //tokenlength should now give an indication how long a line is
            if (tokenlength<1 && colcounter>0)
            {
                //cout << "colcounter>0 nextlinebufpos=" << nextlinebufferpos << endl;
                tokenlength=nextlinebufferpos-1;
            }
            else if (tokenlength<1)
            {
                return RETURN_FAILURE;
            }
            delete[] *tline;
            (*tline)=new char[tokenlength+2];
            strncpy(*tline,linebuffer,tokenlength);
            (*tline)[tokenlength]='\0';
            (*tline)[tokenlength+1]='\0';
            tmp_pointer=new char[nextlinebufferpos+2];
            strncpy(tmp_pointer,linebuffer+tokenlength+1,nextlinebufferpos);
            tmp_pointer[nextlinebufferpos]='\0';
            strncpy(linebuffer,tmp_pointer,nextlinebufferpos-tokenlength-1);
            linebuffer[nextlinebufferpos-tokenlength-1]='\0';
            nextlinebufferpos-=tokenlength+1;
            delete[] tmp_pointer;
            counter++;
        }//end while data present
    }//end if (complex-case)
    return RETURN_SUCCESS;
}

int get_next_token(char * tokenline,struct csv_import_infos & import_info,char * n_token,int * read_token_length)
{//searches for the next token and replaces the text-separator if neccessary
    static int len,stringcounter,dat_sep_occurrance,index;
    static char * tmp_string;
    len=strlen(tokenline);
    if (len<1) return RETURN_FAILURE;
    tmp_string=new char[2*len+2];
    dat_sep_occurrance=0;
    stringcounter=0;
    for ((*read_token_length)=0;(*read_token_length)<len;(*read_token_length)++)
    {
        if (tokenline[*read_token_length]==import_info.textsep)
        {
            stringcounter++;
        }
        else if (tokenline[*read_token_length]==import_info.colsep && stringcounter%2==0)
        {
            dat_sep_occurrance++;
            //(*read_token_length)++;
            break;
        }
    }
    strncpy(tmp_string,tokenline,(*read_token_length));
    tmp_string[(*read_token_length)]='\0';
    (*read_token_length)++;
    dat_sep_occurrance=stringcounter;
    stringcounter=0;
    len=strlen(tmp_string);
    index=0;
    if (dat_sep_occurrance>0)
    {
        for (int i=0;i<len;i++)
        {
            if (tmp_string[i]==import_info.textsep)
            {
                stringcounter++;
                if (stringcounter==1 || stringcounter==dat_sep_occurrance)
                {
                    n_token[index++]='"';
                }
                else
                {
                    n_token[index++]=tmp_string[i];
                }
            }
            else
            {
                n_token[index++]=tmp_string[i];
            }
        }
    }
    else
    {
        strcpy(n_token,tmp_string);
    }
    len=strlen(n_token);
    for (int l=0;l<4;l++)
    {
        n_token[len+l]='\0';
    }
    delete[] tmp_string;
    return RETURN_SUCCESS;
}

void redesign_tokenline(char * tokenline,struct csv_import_infos & import_info)
{
    static int stringcounter,len,index;
    char * newtokenline;
    index=stringcounter=0;
    len=strlen(tokenline);
    newtokenline=new char[2*len+2];
    newtokenline[index++]=import_info.textsep;
    for (int i=0;i<len;i++)
    {
        if (tokenline[i]==import_info.textsep)
        {
            stringcounter++;
            newtokenline[index++]=tokenline[i];
        }
        else if (tokenline[i]==import_info.datsep && stringcounter%2==0)
        {
            newtokenline[index++]=import_info.textsep;
            newtokenline[index++]=' ';
            newtokenline[index++]=import_info.textsep;
        }
        else
        {
            newtokenline[index++]=tokenline[i];
        }
    }
    newtokenline[index++]=import_info.textsep;
    newtokenline[index++]='\0';
    strcpy(tokenline,newtokenline);
    delete[] newtokenline;
}

QString return_format_name(int nr)
{
    if (nr<0 || nr>=NUM_FMT_OPTION_ITEMS)
    return QString("");
    else
    return QString(fmt_option_items[nr].label);
}

int guess_column_format(struct csv_import_infos & import_info, int * ncols, int ** formats,int ** prec_formats)
{
char * tokenline=new char[MAX_INPUT_LINE_LENGTH*2+4];
char * linetoken=new char[2];
char * n_token=new char[MAX_INPUT_LINE_LENGTH];
char * token;
int counter,quoted,reserved,len;
double value,tmp_val;
    (*ncols)=0;
    reserved=2;
    delete[] (*formats);
    (*formats)=new int[reserved];
    (*prec_formats)=new int[reserved];
    Dates_format df_pref, ddummy;
    const char *sdummy;
    int read_token_length,offset,token_format,old_token_format;
    int * int_tmp;
    int * old_format=NULL,old_f_cols;
    QByteArray line;
    QFile * file=new QFile(import_info.filename);
    df_pref=get_date_hint();
    counter=0;
    nextlinebufferpos=0;
    if (!file->open(QIODevice::ReadOnly | QIODevice::Text))
    {
        errmsg(QObject::tr("Unable to open csv-file.").toLocal8Bit().constData());
        delete[] tokenline;
        delete[] linetoken;
        delete[] n_token;
        return RETURN_FAILURE;
    }
    while (!file->atEnd() && counter<import_info.headerlines)//read header and ignore it!
    {
        line = file->readLine(MAX_INPUT_LINE_LENGTH);
        counter++;
    }
    counter=0;
    old_f_cols=0;
    while (readLineFromFile(file,import_info,&linetoken)==RETURN_SUCCESS && counter<3)//read max three lines!
    {
        *ncols=0;
        //cout << "Line " << counter << ": linetoken=#" << linetoken << "#" << endl;
        strcpy(tokenline,linetoken);
        len=strlen(tokenline);
        for (int l=0;l<4;l++)
        {
            tokenline[len+l]='\0';
        }
        offset=0;
        while (get_next_token(tokenline+offset,import_info,n_token,&read_token_length)==RETURN_SUCCESS)
        {//loop through tokens in one line
            offset+=read_token_length;
            //cout << "vor exchange:  n_token=#" << n_token << "#" << int('\n') << endl;
            if (import_info.dec_sep_komma==true) exchangePointComma(n_token);
            //cout << "nach exchange: n_token=#" << n_token << "#" << tokenline+offset << "#" << int(tokenline[offset]) << endl;
            //cout << "n_token=#" << n_token << "# next=#" << tokenline+offset << "#" << endl;
            next_token(n_token, &token, &quoted);
//qDebug() << "token=" << token << " parse=" << parse_date(token, df_pref, FALSE, &value, &ddummy);
         token_format=guess_date_or_number(token,1,&tmp_val);
//qDebug() << "Token=" << token << "val=" << tmp_val << "Format=" << token_format;
            (*prec_formats)[*ncols] = token_format;
            if (quoted)
            {
                old_token_format = (*formats)[*ncols] = FFORMAT_STRING;
                (*ncols)++;
            }
            else if (parse_date(token, df_pref, FALSE, &value, &ddummy) == RETURN_SUCCESS)
            {
                old_token_format = (*formats)[*ncols] = FFORMAT_DATE;
                (*ncols)++;
            }
            else if (parse_float(token, &value, &sdummy) == RETURN_SUCCESS)
            {
                old_token_format = (*formats)[*ncols] = FFORMAT_NUMBER;
                (*ncols)++;
            }
            else
            {
                /* last resort - treat the field as string, even if not quoted */
                old_token_format = (*formats)[*ncols] = FFORMAT_STRING;
                (*ncols)++;
            }
qDebug() << "Token=" << token << "val=" << tmp_val << "Format=" << token_format << "/" << return_format_name(token_format) << "OldFormat=" << (old_token_format==0?"Number":(old_token_format==1?"String":"Date/Time"));
            //cout << "token=#" << n_token << "# Format=" << (*formats)[(*ncols)-1] << endl;
            if (*ncols==reserved)//expand space for formats
            {
                int_tmp=new int[reserved*2];
                memcpy(int_tmp,*formats,sizeof(int)*(reserved));
                reserved*=2;
                delete[] (*formats);
                *formats=int_tmp;
                int_tmp=new int[reserved];
                memcpy(int_tmp,*prec_formats,sizeof(int)*(reserved/2));
                delete[] (*prec_formats);
                *prec_formats=int_tmp;
            }
        }//end loop through tokens in one line
        //we have read one line!
        if (counter==0)
        {
            old_format=new int[*ncols];
            old_f_cols=*ncols;
            memcpy(old_format,*formats,sizeof(int)*(*ncols));//save format of first lines
        }
        else
        {
            if (old_f_cols!=*ncols) goto end_guess_col_f;
            for (int l=0;l<*ncols;l++)
            {
                if (((*formats)[l])!=old_format[l]) goto end_guess_col_f;
            }
        }
        counter++;//line-counter
    }
    file->close();//we opended the file for guessing only
    delete file;
    if (old_format!=NULL) delete[] old_format;
    delete[] tokenline;
    delete[] linetoken;
    delete[] n_token;
    return RETURN_SUCCESS;
end_guess_col_f:
    if (old_format!=NULL) delete[] old_format;
    delete[] tokenline;
    delete[] linetoken;
    delete[] n_token;
    return RETURN_FAILURE;
}

int csvImport(struct csv_import_infos & import_info)
{
int endpos,emptyresidual;
    nextlinebufferpos=0;
    //first action: activate sets to have access to memory for results
    //cout << "Import: Activating sets nr=" << import_info.nr_of_target_sets << endl;
    for (int i=0;i<import_info.nr_of_target_sets;i++)
    {
        import_info.target_sets[i]=nextset(import_info.gno);
        setlength(import_info.gno,import_info.target_sets[i],1024);//we set a default length
    //qDebug() << "File=" << import_info.filename << " i=" << i << ": set=" << import_info.target_sets[i] << " length=" << getsetlength(import_info.gno,import_info.target_sets[i]);
        if (import_info.max_col_per_set[i]==2)
            set_dataset_type(import_info.gno,import_info.target_sets[i],SET_XY);
        else if (import_info.max_col_per_set[i]==3)
            set_dataset_type(import_info.gno,import_info.target_sets[i],SET_XYDY);
        else if (import_info.max_col_per_set[i]==4)
            set_dataset_type(import_info.gno,import_info.target_sets[i],SET_XYDXDY);
        else if (import_info.max_col_per_set[i]==5)
            set_dataset_type(import_info.gno,import_info.target_sets[i],SET_XYHILO);
        else
            set_dataset_type(import_info.gno,import_info.target_sets[i],SET_XYDXDXDYDY);
    }
    char * tokenline=new char[MAX_INPUT_LINE_LENGTH*2+4];
    char * linetoken=new char[2];
    char * n_token=new char[MAX_INPUT_LINE_LENGTH];
    int counter,col_counter,len;
    double value;
    Dates_format df_pref, ddummy;
    const char *sdummy;
    int read_token_length,offset,ret;
    QByteArray line;
    QFile * file=new QFile(import_info.filename);
    counter=0;
    df_pref=get_date_hint();
    //second action: try to actually open file
    if (!file->open(QIODevice::ReadOnly | QIODevice::Text))
    {
        errmsg(QObject::tr("Unable to open csv-file.").toLocal8Bit().constData());
        delete[] tokenline;
        delete[] linetoken;
        delete[] n_token;
        return RETURN_FAILURE;
    }
    //third action: read and ignore header lines
    while (!file->atEnd() && counter<import_info.headerlines)
    {
        line = file->readLine(MAX_INPUT_LINE_LENGTH);
        counter++;
    }
    counter=0;
    //fourth action: do the import
    while (readLineFromFile(file,import_info,&linetoken)==RETURN_SUCCESS)
    {
        ///cout << "Line " << counter << ": linetoken=#" << linetoken << "#" << endl;
        strcpy(tokenline,linetoken);
        len=strlen(tokenline);
        for (int l=0;l<4;l++)
        {
            tokenline[len+l]='\0';
        }
        offset=0;
        col_counter=0;
        while (get_next_token(tokenline+offset,import_info,n_token,&read_token_length)==RETURN_SUCCESS)
        {//loop through tokens in one line
            offset+=read_token_length;
            ///cout << "n_token=#" << n_token << "# next=#" << tokenline+offset << "#" << endl;
            if (import_info.col_format[col_counter]==-1)//unknown format
            {
                value=0.0;
            }
            else
            {
                if (import_info.dec_sep_komma==true) exchangePointCommaInFormat(n_token,import_info.col_format[col_counter]);
            ret=read_date_or_number_in_format(n_token,import_info.col_format[col_counter],TRUE,&value,&endpos,&emptyresidual);
            if (ret==RETURN_FAILURE) value=0.0;
            }
            /*if (import_info.col_format[col_counter]==FFORMAT_NUMBER)
            {
                //cout << "vor exchange" << endl;
                if (import_info.dec_sep_komma==true) exchangePointComma(n_token);
                value=0.0;
                //cout << "nach exchange#" << n_token << "#" << endl;
                parse_float(n_token, &value, &sdummy);
            }
            else if (import_info.col_format[col_counter]==FFORMAT_DATE)
            {
                parse_date(n_token, df_pref, FALSE, &value, &ddummy);
            }
            else
            {
                /// cout << "TOKEN-STRING=" << n_token << endl;
                value=0.0;
            }*/

            //we should now have a 'value' for our column-entry
            //cout << "determined value = " << value << endl;
            if (import_info.import_to_set[col_counter]==-2)//all sets
            {
                //cout << "value=" << value << " allsets nr=" << import_info.nr_of_target_sets << endl;
                for (int l=0;l<import_info.nr_of_target_sets;l++)
                {
                    /*if (import_info.target_sets[l]>=0)
                    {
                    cout << "set S" << import_info.target_sets[l] << " value=" << value << endl;*/
                    g[import_info.gno].p[import_info.target_sets[l]].data.ex[import_info.target_cols[col_counter]][counter]=value;
                    /*}
                    else
                    {
                    cout << "ERROR: target < 0" << endl;//this should never happen
                    }*/
                }
            }
            else if (import_info.import_to_set[col_counter]>=0)//normal set numbers
            {
                //cout << "target-set:" << import_info.import_to_set[col_counter] << " target_cols:" << import_info.target_cols[col_counter] << " value=" << value << endl;
                g[import_info.gno].p[import_info.import_to_set[col_counter]].data.ex[import_info.target_cols[col_counter]][counter]=value;
            }
            col_counter++;//column-counter
        }//end loop through tokens in one line
        counter++;//line-counter
        if (counter%1024==0)//we have to expand the amount of space in the sets
        {
            for (int l=0;l<import_info.nr_of_target_sets;l++)
                setlength(import_info.gno,import_info.target_sets[l],1024+getsetlength(import_info.gno,import_info.target_sets[l]));
        }
    }//end loop through lines in file
    int c=0, bg = getbgcolor();

    for (int l=0;l<import_info.nr_of_target_sets;l++)
    {
        if (l==0)
        {
        c=import_info.target_sets[l];
        }
        while (c == bg || get_colortype(c) != COLOR_MAIN)
        {
            c++;
            c %= number_of_colors();
        }
        setcomment(import_info.gno,import_info.target_sets[l],import_info.filename);
        setlength(import_info.gno,import_info.target_sets[l],counter);//reset the set-length to the actual number of datapoints read
//qDebug() << "nach lesen: y=" << g[import_info.gno].p[import_info.import_to_set[l]].data.ex[1][1];
//qDebug() << "G" << import_info.gno << ".S" << import_info.target_sets[l] << "Color=" << c;
        set_set_colors(import_info.gno, import_info.target_sets[l], c);
        c++;
    }
    file->close();
    delete file;
    delete[] tokenline;
    delete[] linetoken;
    delete[] n_token;
    return RETURN_SUCCESS;
}

frmCSVImporter::frmCSVImporter(QWidget * parent):QDialog(parent)
{
    init_csv_import_infos(&import_info);
    init_csv_import_infos(&import_info_tmp);
    import_info.colsep=';';
    import_info.datsep='\n';
    import_info.textsep='"';

//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: CSV-import"));
    setWindowIcon(QIcon(*GraceIcon));
    fileDialog=new QFileDialog(this,tr("Open CSV file"));
    fileDialog->hide();
    layout=new QGridLayout;
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    cmdOpenFile=new QPushButton(tr("Select CSV file"),this);
    connect(cmdOpenFile,SIGNAL(clicked()),SLOT(doOpen()));
    cmdReguess=new QPushButton(tr("Re-guess columns"),this);
    connect(cmdReguess,SIGNAL(clicked()),SLOT(doReguess()));
    ledFileName=new stdLineEdit(this,tr("Filename:"),false);
    ledFileName->setAcceptDrops(true);
    ledFileName->setText(QString(""));
    lblFileContents=new QTextEdit(QString(""),this);
    lblFileContents->setReadOnly(TRUE);
    lblFileContents->setMinimumHeight(120);
    ledColSep=new stdLineEdit(this,tr("Column-separator:"),false);
    ledColSep->setToolTip(tr("This character will be used as separator between different values in a line.\nTypically ',' or ';' are used. Sometimes tabs (\\t) or spaces ' ' are used.\nWarning: Only a single charactre will be used."));
    ledColSep->setText(QString(";"));
    ledSetSep=new stdLineEdit(this,tr("Data-set-separator:"),false);
    ledSetSep->setToolTip(tr("This character will be used as separator between lines of values in a file.\nTypically new lines are used (\\n).\nWarning: Only a single charactre will be used."));
    ledSetSep->setText(QString("\\n"));
    ledTextSep=new stdLineEdit(this,tr("Text-separators:"),false);
    ledTextSep->setToolTip(tr("This characer will be used to identify string entries."));
    ledTextSep->setText(QString("\""));
    selHeaderLines=new stdIntSelector(this,tr("Number of header-lines to ignore:"),0,100);
    selHeaderLines->setToolTip(tr("These lines will be ignored for reading. Lines that start with # will automatically be ignored."));
    connect(selHeaderLines,SIGNAL(currentValueChanged(int)),SLOT(headerLinesChanged(int)));
    selSetsToRead=new stdIntSelector(this,tr("Number of sets to read:"),1,512);
    connect(selSetsToRead,SIGNAL(currentValueChanged(int)),SLOT(setCountChanged(int)));
    graphselector=new uniList(GRAPHLIST,this);
    lblGraphSelector=new QLabel(tr("Target graph:"),this);
    lblFileCont=new QLabel(tr("File contents:"),this);
    chkKommaDecimalSep=new QCheckBox(tr("Decimal separator is ','"),this);
    chkAutoscaleOnRead=new QCheckBox(tr("Autoscale on read"),this);
    chkAutoscaleOnRead->setChecked(true);//autscale is default
    aac=new stdButtonGroup(this,true,true,false);
    connect(aac->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
    connect(aac->cmdApply,SIGNAL(clicked()),SLOT(doApply()));
    connect(aac->cmdClose,SIGNAL(clicked()),SLOT(doClose()));

    menuBar=new QMenuBar(this);
    actOpenFormat= new QAction(tr("&Open csv-format..."), this);
    actOpenFormat->setShortcut(tr("Ctrl+O"));
    actOpenFormat->setStatusTip(tr("Open a format-specifier-file and set import settings accordingly"));
    connect(actOpenFormat, SIGNAL(triggered()), this, SLOT(doLoadFormat()));
    actSaveFormat= new QAction(tr("&Save csv-format..."), this);
    actSaveFormat->setShortcut(tr("Ctrl+S"));
    actSaveFormat->setStatusTip(tr("Save current format-settings in a format-specifier-file"));
    connect(actSaveFormat, SIGNAL(triggered()), this, SLOT(doSaveFormat()));
    actClose= new QAction(tr("C&lose"), this);
    actClose->setShortcut(tr("Ctrl+Q"));
    actClose->setStatusTip(tr("Close csv-import-dialog (Crtl+Q)"));
    connect(actClose, SIGNAL(triggered()), this, SLOT(doClose()));

    DataMenu=new QMenu(tr("&File"), this );
    DataMenu->setTearOffEnabled(TRUE);
    DataMenu->addAction(actOpenFormat);
    DataMenu->addAction(actSaveFormat);
    DataMenu->addSeparator();
    DataMenu->addAction(actClose);
    menuBar->addMenu( DataMenu );

    int index=0;//,index2=0;
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar,index++,0,1,2);
#endif
    layout->addWidget(ledFileName,index,0,1,1);
    layout->addWidget(cmdOpenFile,index++,1,1,1);
    layout->addWidget(lblFileCont,index,0,1,1);
    layout->addWidget(lblGraphSelector,index++,1,1,1);
    layout->addWidget(lblFileContents,index,0,1,1);
    layout->addWidget(graphselector,index++,1,1,1);
    layout->addWidget(selHeaderLines,index,0,1,1);
    layout->addWidget(ledSetSep,index++,1,1,1);
    layout->addWidget(ledColSep,index,0,1,1);
    layout->addWidget(ledTextSep,index++,1,1,1);
    layout->addWidget(selSetsToRead,index,0,1,1);
    layout->addWidget(cmdReguess,index++,1,1,1);
    layout->addWidget(chkKommaDecimalSep,index,0,1,1);
    layout->addWidget(chkAutoscaleOnRead,index++,1,1,1);

    scroll=new QScrollArea(this);
    empty=new QLabel(this);
    empty->setMinimumSize(600,100);
    grid1=new QGridLayout(this);
    //grid1->setMargin(STD_MARGIN);
    grid1->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    grid1->setSpacing(STD_SPACING);

    lblDescription=NULL;
    recreate_input_selectors();

    empty->setLayout(grid1);
    scroll->setWidget(empty);

    layout->addWidget(scroll,index++,0,1,2);
    layout->addWidget(aac,index++,0,1,2);
    setLayout(layout);
    resize(LastSize_FormCSVImport);
}

frmCSVImporter::~frmCSVImporter()
{
    LastSize_FormCSVImport=this->size();
}

void frmCSVImporter::read_inputs(void)
{
FileNames.clear();
QString testText=ledFileName->text();
QStringList list=testText.split(";");
clear_csv_import_infos(&import_info);//clear previous settings
qDebug() << "Import-Files: list.length=" << list.length();
    for (int i=0;i<list.length();i++)
    {
    FileNames << list.at(i);
    qDebug() << list.at(i);
    }
    if (FileNames.length()<1) return;//no files in input-list!?
//for the beginning we look into the first file in the list
exists=get_file_infos(FileNames.at(0),readable,writable,size_kB);
if (readable==false || exists==false) return;//first file does not exist --> we can not read any data
    if (import_info.filename!=NULL) delete[] import_info.filename;
    import_info.filename=new char[FileNames.at(0).length()+2];
strcpy(import_info.filename,FileNames.at(0).toLocal8Bit().constData());
    //strcpy(import_info.filename,ledFileName->text().toLocal8Bit().constData());
    import_info.headerlines=selHeaderLines->value();
    if (ledColSep->text().isEmpty())
    {
    import_info.colsep=' ';//if nothing has been set as column-separator we use spaces
    stufftext(tr("No column-separator set --> using <space> as separator.").toLocal8Bit().constData());
    }
    else
    {
    import_info.colsep=ledColSep->text().at(0).toLatin1();
    if (!ledColSep->text().compare(QString("\\n")))
        import_info.colsep='\n';
    else if (!ledColSep->text().compare(QString("\\t")))
        import_info.colsep='\t';
    }
    if (ledSetSep->text().isEmpty())
    {
    import_info.datsep='\n';
    stufftext(tr("No data-point-separator set --> using <new-line> as separator.").toLocal8Bit().constData());
    }
    else
    {
    import_info.datsep=ledSetSep->text().at(0).toLatin1();
    if (!ledSetSep->text().compare(QString("\\n")))//every data point is in a seperate line
        import_info.datsep='\n';
    else if (!ledSetSep->text().compare(QString("\\t")))
        import_info.datsep='\t';
    }
    if (ledTextSep->text().isEmpty())
    {
    import_info.textsep='\"';
    stufftext(tr("No text-separators set --> using <quotes>(\") as separators.").toLocal8Bit().constData());
    }
    else
    {
    import_info.textsep=ledTextSep->text().at(0).toLatin1();
    if (!ledTextSep->text().compare(QString("\\n")))
        import_info.textsep='\n';
    else if (!ledTextSep->text().compare(QString("\\t")))
        import_info.textsep='\t';
    }
    import_info.nr_of_target_sets=selSetsToRead->value();
    import_info.dec_sep_komma=chkKommaDecimalSep->isChecked();
    int nr_of_sel,*sel=new int[2],maxplot,setno,free_sets_found=0;
    graphselector->get_selection(&nr_of_sel,&sel);
    if (nr_of_sel<1)
    {
        errmsg(tr("Please select a single target-graph!").toLocal8Bit().constData());
        ApplyError=true;
    }
    else if (nr_of_sel>1)
    {
        errmsg(tr("Please select only one target-graph!").toLocal8Bit().constData());
        ApplyError=true;
    }
    else//we have a single target-graph
    {
        import_info.gno=sel[0];
        if (import_info.target_sets!=NULL) delete[] import_info.target_sets;
        import_info.target_sets=new int[import_info.nr_of_target_sets];
        maxplot = number_of_sets(import_info.gno);//we look through the existing sets
        free_sets_found=0;
        for (setno = 0; setno < maxplot; setno++)
        {
            if (!is_set_active(import_info.gno, setno))
            {
                import_info.target_sets[free_sets_found++]=setno;
            }
            if (import_info.nr_of_target_sets==free_sets_found)//we found enough in the already existing sets
                break;
        }
        if (import_info.nr_of_target_sets>free_sets_found)//not enough sets found (we have to create new ones)
        {
            import_info.target_sets[free_sets_found++]=maxplot;//first new set is number of allocated sets
            while (import_info.nr_of_target_sets>free_sets_found)
            {
                import_info.target_sets[free_sets_found]=import_info.target_sets[free_sets_found-1]+1;//we just count upwards
                free_sets_found++;
            }
        }
        /*cout << "Predicted set-numbers:" << endl;
    for (int i=0;i<import_info.nr_of_target_sets;i++)
    {
    cout << i << ": S" << import_info.target_sets[i] << endl;
    }*/

    }
}

void frmCSVImporter::read_import_settings(void)//this will only be called directly before reading action begins
{//we have to read the column-import-settings and look for the set-numbers really in use
    FileNames.clear();
    QString testText=ledFileName->text();
    QStringList list=testText.split(";");
    qDebug() << "Files to read from: list.length=" << list.length();
        for (int i=0;i<list.length();i++)
        {
        FileNames << list.at(i);
        qDebug() << list.at(i);
        }
        if (FileNames.length()<1) return;
    exists=get_file_infos(FileNames.at(0),readable,writable,size_kB);
//exists=get_file_infos(ledFileName->text(),readable,writable,size_kB);
if (readable==false || exists==false) return;
    if (import_info.col_format!=NULL) delete[] import_info.col_format;
    import_info.col_format=new int[allocated_selectors];//allocated selectors = columns_to_read = guessed number of columns in the file
    if (import_info.target_cols!=NULL) delete[] import_info.target_cols;
    import_info.target_cols=new int[allocated_selectors];
    if (import_info.import_to_set!=NULL) delete[] import_info.import_to_set;
    import_info.import_to_set=new int[allocated_selectors];
    if (import_info.target_sets!=NULL) delete[] import_info.target_sets;
    import_info.target_sets=new int[allocated_selectors];
    if (import_info.max_col_per_set!=NULL) delete[] import_info.max_col_per_set;
    import_info.max_col_per_set=new int[allocated_selectors];
    import_info.nr_of_target_sets=0;
    bool found;
    int j;
    for (int i=0;i<allocated_selectors;i++)//go through the columns
    {
        import_info.target_sets[i]=-1;
        import_info.max_col_per_set[i]=2;//minimum =2 columns per set =XY
        import_info.col_format[i]=selFormat[i]->currentValue();
        import_info.import_to_set[i]=selTargetSet[i]->currentValue();
        import_info.target_cols[i]=selTargetColumn[i]->currentValue();
        if (import_info.import_to_set[i]>=0)//new real set-number
        {
            found=false;
            for (j=0;j<import_info.nr_of_target_sets;j++)//look trough all previous sets for the new set-id
            {
                if (import_info.import_to_set[i]==import_info.target_sets[j])
                {
                    found=true;
                    break;
                }
            }
            if (found==false)//set-id is really new
            {
                import_info.target_sets[import_info.nr_of_target_sets++]=import_info.import_to_set[i];
            }
        }
    }

    sort(import_info.nr_of_target_sets,import_info.target_sets);//sort set-IDs for simplicity

    /*if (import_info.nr_of_target_sets<=0)
    {
    cout << "no suitable set numbers" << endl;
    }
    else*/
    if (import_info.nr_of_target_sets>0)
    {
        //cout << "found set numbers:" << endl;
        for (int i=0;i<import_info.nr_of_target_sets;i++)
        {
            for (j=0;j<allocated_selectors;j++)//look through the selectors for a max-column-number for every set
            {
                if (import_info.import_to_set[j]==import_info.target_sets[i] && import_info.target_cols[j]+1>import_info.max_col_per_set[i]) import_info.max_col_per_set[i]=import_info.target_cols[j]+1;
            }
        }
        /*for (int i=0;i<import_info.nr_of_target_sets;i++)
        {
        cout << "S" << import_info.target_sets[i] << " max_cols=" << import_info.max_col_per_set[i] << endl;
        }*/
    }
}

void frmCSVImporter::recreate_input_selectors(void)
{
    if (import_info.columns_to_read<=0) return;//columns_to_read is the guessed number of columns in the file --> we create new input-selectors for every column
    if (lblDescription!=NULL)//we already had selectors --> delete the old ones
    {
        for (int i=0;i<allocated_selectors;i++)
        {
            delete lblDescription[i];
            delete selFormat[i];
            delete selTargetSet[i];
            delete selTargetColumn[i];
        }
        delete[] lblDescription;
        delete[] selFormat;
        delete[] selTargetSet;
        delete[] selTargetColumn;
    }
    allocated_selectors=import_info.columns_to_read;
    empty->setMinimumSize(this->width()-18,allocated_selectors*30+10);
    empty->setMaximumSize(this->width()-18,allocated_selectors*30+10);
    lblDescription=new QLabel *[allocated_selectors];
    selFormat=new StdSelector *[allocated_selectors];
    selTargetSet=new StdSelector *[allocated_selectors];
    selTargetColumn=new StdSelector *[allocated_selectors];
    QString * entr=new QString[NUM_FMT_OPTION_ITEMS+2];
    int * entr_nrs=new int[NUM_FMT_OPTION_ITEMS+2];
    for (int i=0;i<NUM_FMT_OPTION_ITEMS;i++)
    {
    entr[i]=QString(fmt_option_items[i].label);
    entr_nrs[i]=i;
    }
    entr[NUM_FMT_OPTION_ITEMS]=tr("Unknown");
    entr_nrs[NUM_FMT_OPTION_ITEMS]=-1;
    entr[NUM_FMT_OPTION_ITEMS+1]=tr("String");
    entr_nrs[NUM_FMT_OPTION_ITEMS+1]=-2;
    /*entr[0]=tr("Number");
    entr[1]=tr("Date/Time");
    entr[2]=tr("String");*/
    QString * entr2=new QString[2+import_info.nr_of_target_sets];
    int * entry_values2=new int[2+import_info.nr_of_target_sets];
    QString * entr3=new QString[6];
    entr2[0]=QString("None");
    entr2[1]=QString("All");
    entry_values2[0]=-1;
    entry_values2[1]=-2;
    for (int i=0;i<import_info.nr_of_target_sets;i++)
    {
        sprintf(dummy,"G%d.S%d",import_info.gno,import_info.target_sets[i]);
        entr2[i+2]=QString(dummy);
        entry_values2[i+2]=import_info.target_sets[i];
    }
    entr3[0]=QString("X");
    entr3[1]=QString("Y");
    entr3[2]=QString("Y1");
    entr3[3]=QString("Y2");
    entr3[4]=QString("Y3");
    entr3[5]=QString("Y4");
    //int entry_values[3]={FFORMAT_NUMBER,FFORMAT_DATE,FFORMAT_STRING};
    int index2=0;
    for (int i=0;i<allocated_selectors;i++)
    {
        sprintf(dummy," %d:",i);
        lblDescription[i]=new QLabel(tr("Column")+QString(dummy),this);
        selFormat[i]=new StdSelector(this,tr("Format:"),NUM_FMT_OPTION_ITEMS+2,entr);
        selFormat[i]->setValues(entr_nrs);//entry_values
        selTargetSet[i]=new StdSelector(this,tr("Import to set:"),2+import_info.nr_of_target_sets,entr2);
        selTargetSet[i]->setValues(entry_values2);
        selTargetColumn[i]=new StdSelector(this,tr("Import as:"),6,entr3);
        grid1->addWidget(lblDescription[i],index2,0);
        grid1->addWidget(selFormat[i],index2,1);
        grid1->addWidget(selTargetSet[i],index2,2);
        grid1->addWidget(selTargetColumn[i],index2++,3);
        selFormat[i]->setCurrentValue(import_info.col_format[i]);
    }
    if (allocated_selectors>0)
    {
        selTargetSet[0]->setCurrentValue(-2);//All
        selTargetColumn[0]->setCurrentValue(0);//X
        for (int i=1;i<allocated_selectors;i++)
        {
            if (i-1<import_info.nr_of_target_sets)
                selTargetSet[i]->setCurrentValue(import_info.target_sets[i-1]);//the set
            else
                selTargetSet[i]->setCurrentValue(-1);
            selTargetColumn[i]->setCurrentValue(1);//Y
        }
    }
    delete[] entr;
    delete[] entr2;
    delete[] entr3;
    delete[] entry_values2;
}

void frmCSVImporter::doReguess(void)
{
    FileNames.clear();
    QString testText=ledFileName->text();
    QStringList list=testText.split(";");
    //qDebug() << "list.length=" << list.length();
        for (int i=0;i<list.length();i++)
        FileNames << list.at(i);
        if (FileNames.length()<1) return;
    exists=get_file_infos(FileNames.at(0),readable,writable,size_kB);
//exists=get_file_infos(ledFileName->text(),readable,writable,size_kB);
if (readable==false || exists==false) return;
    readFirstLines();
    selSetsToRead->setValue(import_info.columns_to_read-1);
    read_inputs();
    recreate_input_selectors();
}

void frmCSVImporter::doOpen(void)
{
//QString filename=fileDialog->getOpenFileName(this,tr("Open CSV file"));
QString filename;
QStringList filenames=fileDialog->getOpenFileNames(this,tr("Open CSV file"));
if (filenames.length()<1) return;
filename=filenames.at(0);
for (int i=1;i<filenames.length();i++)
{
filename+=QString(";")+filenames.at(i);
}
    //if (!filename.isEmpty())
    //{
        ledFileName->setText(filename);
        readFirstLines();
        selSetsToRead->setValue(import_info.columns_to_read-1);
        read_inputs();
        recreate_input_selectors();
    //}
}

void frmCSVImporter::readFirstLines(void)
{
    read_inputs();
    QByteArray line,firstLine;
    QFile file(import_info.filename);
    QString text1;
    int counter=0,ret;
    lblFileContents->clear();
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        return;
    }
    while (!file.atEnd() && counter<import_info.headerlines)
    {
        line = file.readLine(1024);
        text1=QString(line.constData());
        text1.chop(1);
        lblFileContents->append(text1);
        counter++;
    }
    lblFileContents->append(QString("-#-#-#-#-#-#-#-#-"));
    counter=0;
    while (!file.atEnd() && counter<6)//read at most 6 lines
    {
        line = file.readLine(1024);
        text1=QString(line.constData());
        text1.chop(1);
        lblFileContents->append(text1);
        if (counter==0) firstLine=line;
        counter++;
    }
    lblFileContents->append(QString("..."));
    /*text1=QString(firstLine.constData());
text1.chop(1);
ind=text1.indexOf(import_info.datsep);
if (ind==-1) ind=text1.length();
text1=text1.left(ind);
ind=text1.count(import_info.colsep)+1;
sprintf(dummy,"--> %d data columns found per set",ind);
lblFileContents->append(tr("Analyzed line:"));
lblFileContents->append(text1);
lblFileContents->append(QString(dummy));*/
    file.close();

    int ncols,*colformats=NULL,*prec_col_formats=NULL;

    ret=guess_column_format(import_info,&ncols,&colformats,&prec_col_formats); // --> prec_col_formats is the new format-guess, should be more precise than the old/simple one
    //if (colformats==NULL) cout << "colformat==NULL n=" << ncols << endl;
    if (ret==RETURN_FAILURE || colformats==NULL)
    {
        lblFileContents->append(QString("Unable to guess column formats..."));
    }
    else
    {
        import_info.columns_to_read=ncols;
        if (import_info.col_format!=NULL)
            delete[] import_info.col_format;
        import_info.col_format=new int[import_info.columns_to_read];
        memcpy(import_info.col_format,prec_col_formats,sizeof(int)*ncols);

        sprintf(dummy,"Guessed number of columns=%d\nGuessed column formats:",ncols);
        lblFileContents->append(QString(dummy));
        for (int i=0;i<ncols;i++)
        {
            if (prec_col_formats[i]==-1)
            {
            sprintf(dummy,"Column %d = %s",i,"Unknown format");
            }
            else if (prec_col_formats[i]==-2)
            {
            sprintf(dummy,"Column %d = %s",i,"String");
            }
            else
            {
            sprintf(dummy,"Column %d = %s",i,return_format_name(prec_col_formats[i]).toLocal8Bit().constData());
            }
            /*if (colformats[i]==FFORMAT_STRING)
            {
                sprintf(dummy,"Column %d = %s",i,"String");
            }
            else if (colformats[i]==FFORMAT_DATE)
            {
                sprintf(dummy,"Column %d = %s",i,"Date/Time");
            }
            else
            {
                sprintf(dummy,"Column %d = %s",i,"Number");
            }*/
            lblFileContents->append(QString(dummy));
        }
    }
    if (colformats!=NULL)
        delete[] colformats;
    if (prec_col_formats!=NULL)
        delete[] prec_col_formats;
}

void frmCSVImporter::init(void)
{
    graphselector->update_number_of_entries();
    graphselector->set_graph_number(get_cg(),false);
}

void frmCSVImporter::headerLinesChanged(int c)
{
    (void)c;
    readFirstLines();
    selSetsToRead->setValue(import_info.columns_to_read-1);
    read_inputs();
    recreate_input_selectors();
}

void frmCSVImporter::setCountChanged(int c)
{
    (void)c;
    read_inputs();
    recreate_input_selectors();
}

void frmCSVImporter::doLoadFormat(void)
{
QString fFile=QFileDialog::getOpenFileName(this,tr("Open csv-format-file"),QString(qt_grace_templates_dir),tr("Format files (*.fmt)"));
if (!fFile.isEmpty())
{
loadCSVformatFromFile(fFile.toLocal8Bit().constData(),&import_info);
ledColSep->setText(stringFromSpecialChar(import_info.colsep));
ledSetSep->setText(stringFromSpecialChar(import_info.datsep));
ledTextSep->setText(stringFromSpecialChar(import_info.textsep));
selHeaderLines->setValue(import_info.headerlines);
selSetsToRead->setValue(import_info.nr_of_target_sets);
chkKommaDecimalSep->setChecked(import_info.dec_sep_komma);
recreate_input_selectors();
/// READ? GUESS?
}
}

void frmCSVImporter::doSaveFormat(void)
{
QString fFile=QFileDialog::getSaveFileName(this,tr("Save csv-format in file"),QString(qt_grace_templates_dir),tr("Format files (*.fmt)"));
if (!fFile.isEmpty())
{
read_inputs();
read_import_settings();
saveCSVformatToFile(fFile.toLocal8Bit().constData(),&import_info);
}
}

void frmCSVImporter::doApply(void)
{
    FileNames.clear();
    QString testText=ledFileName->text();
    QStringList list=testText.split(";");
    //qDebug() << "list.length=" << list.length();
        for (int i=0;i<list.length();i++)
        FileNames << list.at(i);
        if (FileNames.length()<1) return;
    exists=get_file_infos(FileNames.at(0),readable,writable,size_kB);
//exists=get_file_infos(ledFileName->text(),readable,writable,size_kB);
if (readable==false || exists==false)
{
//QMessageBox::information(this,tr("Error"),tr("No CSV-file selected!"));
errmsg(tr("No CSV-file selected!").toLocal8Bit().constData());
ApplyError=true;
return;
}
    ApplyError=false;
    read_inputs();//read all settings
    read_import_settings();//read the import-settings for every column
    if (import_info.nr_of_target_sets<=0)
    {
        errmsg(tr("No suitable target sets for import selected!").toLocal8Bit().constData());
        ApplyError=true;
    }
    if (ApplyError==true) return;
    for (int i=0;i<FileNames.length();i++)
    {
        if (import_info.filename) delete[] import_info.filename;
        import_info.filename=new char[8+FileNames.at(i).toLocal8Bit().length()*2];
        strcpy(import_info.filename,FileNames.at(i).toLocal8Bit().constData());
        /*if (i>0)
        {
            for (int j=0;j<import_info.nr_of_target_sets;j++)
            {
            import_info.target_sets[i]
            }
        }*/
        if (csvImport(import_info)==RETURN_SUCCESS)//do the actual import
        {
        //qDebug() << "NrOfTargetSets=" << import_info.nr_of_target_sets;
            if (chkAutoscaleOnRead->isChecked()) mainWin->doAutoScale();//if import worked --> rescale
            mainWin->mainArea->completeRedraw();//redraw
        }
        else
        {
        ApplyError=true;//tell Accept, than an error occured
        }
    }
}

void frmCSVImporter::doAccept(void)
{
    ApplyError=false;
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmCSVImporter::doClose(void)
{
    hide();
}

frmCSVImporterV2::frmCSVImporterV2(QWidget * parent):QDialog(parent)
{
int index=0,number=2;
QString * entr=new QString[8];
int * entr_val=new int[8];
int def_sep=10,def_col_sep=9;
guess_type=1;
Template=new struct csv_import_infos;
input=new struct csv_multi_import_infos;
init_csv_import_infos(Template);
init_mcsv_import_infos(input);

#ifdef MAC_SYSTEM
def_sep=13;
#endif

    setWindowTitle(tr("QtGrace: CSV-/ASCII-data-import"));
    setWindowIcon(QIcon(*GraceIcon));
    layout=new QGridLayout();
    //layout->setMargin(STD_MARGIN);
    layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout->setSpacing(STD_SPACING);

    mfsel=new multiFileSelector(this);
    chkGuess=new QCheckBox(tr("Guess format"),this);
    chkGuess->setToolTip(tr("If activated QtGrace will try to guess the format of a file that is entered here."));
    chkGuess->setChecked(true);

    number=2;
    entr[0]=QString(".");
    entr[1]=QString(",");
    selDecSep=new StdSelector(this,tr("Decimal separator:"),number,entr);
    selDecSep->setToolTip(tr("Decimal separator to be used while reading data values"));

    number=2;
    entr[0]=QString("G0");
    entr[1]=QString("G1");
    selGraph=new StdSelector(this,tr("Target-Graph:"),number,entr);
    selGraph->simple_graph_selector=true;
    selGraph->include_NONE=false;
    entr[0]=QString("--");
    entr[1]=QString("--");
    entr_val[0]=-1;
    entr_val[1]=-1;
    //selSourceSet=new StdSelector(this,tr("Source-Set:"),1,entr);
    //selSourceSet->setNewEntries(1,entr,entr_val);
    //connect(selSourceSet,SIGNAL(currentIndexChanged(int)),this,SLOT(newSourceSet(int)));
    lstSet=new uniList(SETLIST,this);
    lblFormat=new QLabel(tr("Format settings:"),this);
    multDataFormSel=new MultiDataFormatSelector(this);
    //multDataFormSel->reCreateSelectors(0,NULL,NULL);
    //qDebug() << "Empty.size=" << multDataFormSel->empty->size();
    postproset=new postProcessingSettings(this);
    postproset->changeAppearance(false,false,false);//eigentlich false,false,false

    layout0=new QGridLayout();
    //layout0->setMargin(0);
    layout0->setContentsMargins(0,0,0,0);
    layout0->setSpacing(STD_SPACING);
    layout1=new QGridLayout();
    //layout1->setMargin(0);
    layout1->setContentsMargins(0,0,0,0);
    layout1->setSpacing(0);
    empty0=new QWidget(this);

    selHeaderLines=new stdIntSelector(this,tr("Header-Lines:"),0,120000);
    selHeaderLines->setToolTip(tr("The first lines (=the header-lines) will be ignored.\nThis is useful if the file has some information at the beginning, that is unformated and has no '#' at the beginning."));
    selColSep=new StdSelector(this,tr("Column-Separator:"),number,entr);
    selColSep->setToolTip(tr("Character used for separating different values in a data-point."));
    selLineSep=new StdSelector(this,tr("Line-Separator:"),number,entr);
    selLineSep->setToolTip(tr("Character used for separating different data-points.\n(In most cases this should be a newline-character <CR>/<LF>.)"));
    entr[0] = tr("<Tab>");
    entr_val[0] = 9;
    entr[1] = tr("Line Feed <LF>");
    entr_val[1] = 10;
    entr[2] = tr("Carriage Return <CR>");
    entr_val[2] = 13;
    entr[3] = tr("<space>");
    entr_val[3] = 32;
    entr[4] = tr(";");
    entr_val[4] = 59;
    entr[5] = tr(",");
    entr_val[5] = 44;
    number=6;
    selColSep->setNewEntries(number,entr,entr_val);
    selLineSep->setNewEntries(number,entr,entr_val);
    selLineSep->setCurrentValue(def_sep);
    selColSep->setCurrentValue(def_col_sep);

    selInvalidVal=new LineWidthSelector(this);
    selInvalidVal->lblText->setText(tr("Value for invalid data:"));
    selInvalidVal->setToolTip(tr("This value will be used whenever a data-entry in the file could not be read.\nYou should put something here that is very obviously outside of the usual range of data-values."));
    selInvalidVal->spnLineWidth->setRange(-1000000.0,1000000.0);
    selInvalidVal->spnLineWidth->setSingleStep(1.0);
    selInvalidVal->setValue(-100.0);

    layout0->addWidget(selHeaderLines,0,0,1,1);
    layout0->addWidget(selInvalidVal,0,1,1,1);
    layout0->addWidget(selLineSep,1,0,1,1);
    layout0->addWidget(selColSep,1,1,1,1);
    layout0->addWidget(lblFormat,2,0,1,1);
    layout0->addWidget(selDecSep,2,1,1,1);
    empty0->setLayout(layout0);

    grpContents=new QGroupBox(tr("File view:"),this);
    grpContents->setCheckable(true);
    grpContents->setChecked(true);

    txtContent=new QTextEdit(this);
    txtContent->setReadOnly(true);
    layout1->addWidget(txtContent,0,0,1,1);

    grpContents->setLayout(layout1);

    cmdReRead=new QPushButton(tr("ReRead file"),this);
    cmdReRead->setToolTip(tr("Reads the file again, according to the format above.\nThis is useful to test different format settings for read-errors."));
    cmdGuess=new QPushButton(tr("Guess format"),this);
    cmdGuess->setToolTip(tr("Try to guess the format of the file (again)."));
    cmdRead=new QPushButton(tr("Read single set"),this);
    cmdRead->setToolTip(tr("Read the file (again) according to the current format settings\n(no guessing, just read according to the settings above).\nOnly a single set will be generated per set in the file:\nFirst data-column X, second data-column Y, first string-column becomes string-column of this set."));
    cmdReadAll=new QPushButton(tr("Read all sets (NXY)"),this);
    cmdReadAll->setToolTip(tr("Read the file (again) according to the current format settings\n(no guessing, just read according to the settings above).\nThis will continue to read the data and reuses the input settings for new sets on every set and column present in the file.\nThis will usually generate several new data-sets.\nFor every set generated from a set in the file the X-column will be the first data-column in the set.\nIf there are string-columns present in the file the string-columns will be added to the generated sets."));
    cmdReadBlockData=new QPushButton(tr("Read file into block-data"),this);
    cmdReadBlockData->setToolTip(tr("All data will be copied into the block-data-storage for further use.\nBlock-data can only accept double-precision-numbers and strings.\nOther data-formats will be converted to double-precision-numbers.\nOnly the first set in the first file will be used."));

    aac=new stdButtonGroup(this);

    menuBar=new QMenuBar(this);
    DataMenu=new QMenu(tr("&Data"),menuBar);
    actOpenFormat=new QAction(tr("&Open File Format"),DataMenu);
    actSaveFormat=new QAction(tr("&Save File Format"),DataMenu);
    actOpenBlockData=new QAction(tr("Open &Block Data Dialog"),DataMenu);
    actOpenFile=new QAction(tr("Open &File(s)"),DataMenu);
    actClose=new QAction(tr("&Close"),DataMenu);
    DataMenu->addAction(actOpenFormat);
    DataMenu->addAction(actSaveFormat);
    DataMenu->addSeparator();
    DataMenu->addAction(actOpenFile);
    DataMenu->addSeparator();
    DataMenu->addAction(actOpenBlockData);
    DataMenu->addSeparator();
    DataMenu->addAction(actClose);
    menuBar->addMenu(DataMenu);

    FileViewMenu=new QMenu(tr("&File view"),menuBar);
    actShowComments=new QAction(tr("Show &Comments"),FileViewMenu);
    actShowComments->setCheckable(true);
    actShowComments->setChecked(false);
    actShowComments->setToolTip(tr("Show comments present in the file in the file-view below"));
    actShowOriginal=new QAction(tr("Show &Original contents"),FileViewMenu);
    actShowOriginal->setCheckable(true);
    actShowOriginal->setChecked(true);
    actShowOriginal->setToolTip(tr("Show the original entries (in black) in the file in the file-view below"));
    actShowValues=new QAction(tr("Show &Values"),FileViewMenu);
    actShowValues->setCheckable(true);
    actShowValues->setChecked(true);
    actShowValues->setToolTip(tr("Show the values read from the file (in green) in the file-view below"));
    actShowErrors=new QAction(tr("Show &Error Lines"),FileViewMenu);
    actShowErrors->setCheckable(true);
    actShowErrors->setChecked(true);
    actShowErrors->setToolTip(tr("Show lines containing read-errors"));
    actShowHeader=new QAction(tr("Show &Header Lines"),FileViewMenu);
    actShowHeader->setCheckable(true);
    actShowHeader->setChecked(false);
    actShowHeader->setToolTip(tr("Show the ignored header lines"));
    selStartLines=new menuIntSelector(FileViewMenu,tr("Start-Lines:"),-1,100000);
    selStartLines->setValue(6);
    selStartLines->setToolTip(tr("Number of lines at the beginning of the file to be shown in the file-view below.\nA value of '-1' means: show every line."));
    selStopLines=new menuIntSelector(FileViewMenu,tr("End-Lines:"),0,100000);
    selStopLines->setValue(3);
    selStopLines->setToolTip(tr("Number of lines at the end of the file to be shown in the file-view below.\nLines at the beginning and at the end are separated by '...'."));

    FileViewMenu->addAction(actShowComments);
    FileViewMenu->addAction(actShowOriginal);
    FileViewMenu->addAction(actShowValues);
    FileViewMenu->addAction(actShowErrors);
    FileViewMenu->addAction(actShowHeader);
    FileViewMenu->addAction(selStartLines);
    FileViewMenu->addAction(selStopLines);
    menuBar->addMenu(FileViewMenu);

    connect(aac->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(aac->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(aac->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    connect(grpContents,SIGNAL(toggled(bool)),this,SLOT(contentsToggled(bool)));
    connect(actOpenFormat,SIGNAL(triggered()),this,SLOT(doOpenFormat()));
    connect(actSaveFormat,SIGNAL(triggered()),this,SLOT(doSaveFormat()));
    connect(actOpenFile,SIGNAL(triggered()),mfsel,SLOT(doLoadFile()));
    connect(actOpenBlockData,SIGNAL(triggered()),this,SLOT(doOpenEditBlockData()));
    connect(actClose,SIGNAL(triggered()),this,SLOT(doClose()));
    connect(cmdReRead,SIGNAL(clicked()),this,SLOT(doReRead()));
    connect(cmdGuess,SIGNAL(clicked()),this,SLOT(doGuess()));
    connect(cmdRead,SIGNAL(clicked()),this,SLOT(doRead()));
    connect(cmdReadAll,SIGNAL(clicked()),this,SLOT(doReadAll()));
    connect(cmdReadBlockData,SIGNAL(clicked()),this,SLOT(doReadBlockData()));
    connect(mfsel,SIGNAL(newSelection(QStringList)),this,SLOT(newFilesSelection(QStringList)));

    connect(actShowComments,SIGNAL(toggled(bool)),this,SLOT(updateViewSettingsA(bool)));
    connect(actShowOriginal,SIGNAL(toggled(bool)),this,SLOT(updateViewSettingsA(bool)));
    connect(actShowValues,SIGNAL(toggled(bool)),this,SLOT(updateViewSettingsA(bool)));
    connect(actShowErrors,SIGNAL(toggled(bool)),this,SLOT(updateViewSettingsA(bool)));
    connect(actShowHeader,SIGNAL(toggled(bool)),this,SLOT(updateViewSettingsA(bool)));
    connect(selStartLines,SIGNAL(currentValueChanged(int)),this,SLOT(updateViewSettingsB(int)));
    connect(selStopLines,SIGNAL(currentValueChanged(int)),this,SLOT(updateViewSettingsB(int)));
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar,index++,0,1,6);
#endif
    layout->addWidget(mfsel,index,0,1,5);
    layout->addWidget(chkGuess,index++,5,1,1);

    layout->addWidget(empty0,index++,0,1,6);

    layout->addWidget(multDataFormSel,index++,0,1,6);
//multDataFormSel->empty->adjustSize();
//multDataFormSel->adjustSize();

    layout->addWidget(cmdReRead,index,0,1,1);
    layout->addWidget(cmdGuess,index,1,1,1);
    layout->addWidget(cmdRead,index,2,1,1);
    layout->addWidget(cmdReadAll,index,3,1,1);
    layout->addWidget(cmdReadBlockData,index++,4,1,2);

    //layout->addWidget(txtContent,index++,0,1,6);
    layout->addWidget(grpContents,index++,0,1,6);

    layout->addWidget(selGraph,index++,0,1,1);
    //layout->addWidget(selSourceSet,index++,1,1,5);
    layout->addWidget(lstSet,index,0,1,1);
    layout->addWidget(postproset,index-1,1,2,5);
    index++;

    layout->addWidget(aac,index++,0,1,6);
    this->setLayout(layout);
    this->setAcceptDrops(true);

    layout->setColumnStretch(0,1);
    for (int i=1;i<6;i++)
    layout->setColumnStretch(i,2);

    //qDebug() << "LastSize_FormCSVImportV2=" << LastSize_FormCSVImportV2;
    resize(LastSize_FormCSVImportV2);
    postproset->min_element_height=selGraph->height();
    multDataFormSel->min_element_height=selGraph->height();
    multDataFormSel->reCreateSelectors(0,NULL,NULL);
    multDataFormSel->empty->setMinimumSize(150,25);
    multDataFormSel->empty->adjustSize();
    //qDebug() << "Empty.size=" << multDataFormSel->empty->size() << "selNrOfSets.visible=" << multDataFormSel->selNrOfSets->isVisible();
}

frmCSVImporterV2::~frmCSVImporterV2()
{
    LastSize_FormCSVImportV2=this->size();
}

void frmCSVImporterV2::dropEvent(QDropEvent * event)
{
mfsel->dropEvent(event);
}

void frmCSVImporterV2::dragEnterEvent(QDragEnterEvent * event)
{
if (event->mimeData()->hasUrls()==true) event->accept();
}

void frmCSVImporterV2::init(void)
{
selGraph->setValuesToGraphs(false,false);
selGraph->setCurrentValue(get_cg());
lstSet->set_graph_number(get_cg(),false);
}

void frmCSVImporterV2::setGUItoInput(bool incl_postprocessing=true)
{
    int * nr_of_cols=new int[2+input->nr_of_sets];
    int * set_data=new int[2+input->nr_of_sets];
    int nr;
    int * set_ids=new int[2+input->nr_of_sets];
    QString * entr=new QString[2+input->nr_of_sets];
    QList< QList<int> > formats;
    QList<int> tmp_list;
    formats.clear();
    nr=input->nr_of_sets;
    for (int i=0;i<input->nr_of_sets;i++)
    {
        nr_of_cols[i]=input->set[i].columns;
        set_data[i]=input->set[i].rows;
        tmp_list.clear();
        for (int j=0;j<nr_of_cols[i];j++)
        {
        tmp_list << input->set[i].csv_column_formats.at(j);
        }
    formats << tmp_list;
        if (i==0)
        {
        selColSep->setCurrentValue(input->set[i].colsep);
        selLineSep->setCurrentValue(input->set[i].datsep);
        }
    set_ids[i]=i;
    entr[i]=QString::number(i);
    }
    selHeaderLines->setValue(input->headerlines);
    selInvalidVal->setValue(input->invalid_value);
    selDecSep->setCurrentIndex((input->komma_is_decimal_sep==false?0:1));
    if (input->nr_of_sets<=0)
    {
    set_ids[0]=-1;
    entr[0]=QString("--");
    nr=1;
    }
    //selSourceSet->setNewEntries(nr,entr,set_ids);
    //selSourceSet->setCurrentIndex(0);
    multDataFormSel->min_element_height=selGraph->height();
    /**/
    if (incl_postprocessing)
    {
        if (chkGuess->isChecked()==true)
        {
            if (input->nr_of_sets<=0)
            postproset->init(0,*input);
            else
            postproset->init(settype_cols(postproset->selSetType->currentIndex()),*input);
        }
        else
        {
        postproset->init(input->postprocess_target_col.length(),*input);
        }
    postproset->min_element_height=selGraph->height();
    postproset->updateVisibilites();
    //postproset->adjustSize();
    }
        /*if (input->nr_of_sets<=0)
        postproset->resetColumnCount(0);
        else
        postproset->resetColumnCount(input->set[0].columns);*/
    if (input->error_count==0)
    grpContents->setTitle(tr("File view: (No Read-Errors)"));
    else if (input->error_count==1)
    grpContents->setTitle(tr("File view: (") + QString::number(input->error_count) + tr(" Read-Error)"));
    else
    grpContents->setTitle(tr("File view: (") + QString::number(input->error_count) + tr(" Read-Errors)"));

    multDataFormSel->reCreateSelectors(input->nr_of_sets,nr_of_cols,set_data);
    multDataFormSel->setAllFormatSettings(formats);
    //multDataFormSel->empty->setMinimumWidth(this->width()*0.95);
    multDataFormSel->empty->setMinimumHeight((1+multDataFormSel->selNrOfSets->value()*3)*(multDataFormSel->min_element_height+STD_SPACING)+STD_MARGIN);
    multDataFormSel->empty->adjustSize();
    txtContent->setHtml(input->text_as_html);
    delete[] nr_of_cols;
    delete[] set_data;
    delete[] set_ids;
    delete[] entr;
}

void frmCSVImporterV2::updateViewSettingsA(bool a)
{
(void)a;
updateViewSettings();
}

void frmCSVImporterV2::updateViewSettingsB(int a)
{
(void)a;
updateViewSettings();
}

void frmCSVImporterV2::updateViewSettings(void)
{
input->htmlShowValues=actShowValues->isChecked();
input->htmlShowComments=actShowComments->isChecked();
input->htmlShowOriginal=actShowOriginal->isChecked();
input->htmlShowErrorLines=actShowErrors->isChecked();
input->htmlShowHeaderLines=actShowHeader->isChecked();
input->startValues=selStartLines->value();
input->endValues=selStopLines->value();
//input->text_as_html=convert_csv_contents_to_html(*input,input->startValues,-1,input->endValues,input->htmlShowComments);
input->text_as_html=convert_csv_contents_to_html(*input);
txtContent->setHtml(input->text_as_html);
}

void frmCSVImporterV2::doReRead(void)
{
int sav_guess_type=guess_type;
QStringList list;
mfsel->getSelection(list);
if (list.length()<=0)
{
errmsg(tr("Please select a file to read.").toLocal8Bit().constData());
return;
}
N_DELETE2(input->filename);
input->filename=new char[4*list.at(0).length()+8];
strcpy(input->filename,list.at(0).toLocal8Bit().constData());
guess_type=0;//no guessing
//qDebug() << "Read Data from file according to settings above";
readGeneralSettingsIntoInput();
readDisplaySetting();
multDataFormSel->getAllFormatSettings(input->csv_column_formats_suggestion);
//qDebug() << "doReRead: filename=" << input->filename;
int ret=read_csv_file_into_sets(*input,guess_type);
//qDebug() << "ret=" << ret;
setGUItoInput();
if (input->error_count>0)
{
errmsg(input->errors_as_text.toLocal8Bit().constData());
}
guess_type=sav_guess_type;
}

void frmCSVImporterV2::doGuess(void)
{
int ret=QMessageBox::question(this,tr("Guess what?"),tr("Guess everything (Yes) or just the column-formats (No)?"),QMessageBox::Yes|QMessageBox::No|QMessageBox::Cancel);
if (ret==QMessageBox::Cancel) return;
QStringList list;
mfsel->getSelection(list);
    if (ret==QMessageBox::Yes)//guess all (guess_type==1)
    {
    //qDebug() << "Guess ALL Data Format";
    newFilesSelection(list);
    }
    else if (ret==QMessageBox::No)//just guess column-formats
    {
    guess_type=2;
    //qDebug() << "Guess Column-Format only";
    readGeneralSettingsIntoInput();
    newFilesSelection(list);
    guess_type=1;
    }
//postproset->initEntries(settype_cols(postproset->selSetType->currentValue()));
//postproset->setTypeChanged(postproset->selSetType->currentIndex());
postproset->new_number_of_lines(postproset->selLines->value());
}

void frmCSVImporterV2::doRead(void)
{
QStringList filelist;
mfsel->getSelection(filelist);
if (filelist.length()<=0) return;
set_wait_cursor();
int sav_guess_type=guess_type;
int target_gno=selGraph->currentValue(),new_id,ret;
char * new_comment=new char[GR_MAXPATHLEN],*new_legend=new char[GR_MAXPATHLEN];
QString error_string,text;
char str_txt[GR_MAXPATHLEN];
QStringList list;
QList<int> new_set_ids;
new_set_ids.clear();
for (int jkl=0;jkl<filelist.length();jkl++)
{
guess_type=0;//no guessing
    readGeneralSettingsIntoInput();
    readDisplaySetting();
    multDataFormSel->getAllFormatSettings(input->csv_column_formats_suggestion);
N_DELETE2(input->filename);
input->filename=new char[filelist.at(jkl).length()*4+8];
strcpy(input->filename,filelist.at(jkl).toLocal8Bit().constData());
    ret=read_csv_file_into_sets(*input,guess_type);
if (ret==RETURN_FAILURE)
{
errmsg(tr("Error reading data from csv-file into sets.").toLocal8Bit().constData());
}
    for (int i=0;i<input->nr_of_sets;i++)
    {
        if (input->set[i].rows<=0)
        {
        error_string=tr("Set ")+QString::number(i)+tr(" does not contain data.");
        errmsg(error_string.toLocal8Bit().constData());
        continue;
        }
    error_string.clear();
    gatherDefaultColumnIndices(input->set+i);
    //we want to generate a new set (type XY, possibly with a string-column)
    if (input->set[i].dataOnlyIndices.length()>=2)
    {
    new_id=nextset(target_gno);
        if (new_id<0)
        {
        error_string=tr("Unable to allocate more sets.");
        errmsg(error_string.toLocal8Bit().constData());
        break;
        }
    set_dataset_type(target_gno,new_id,SET_XY);
    setlength(target_gno,new_id,input->set[i].rows);
    get_csv_column(*input,i,input->set[i].dataOnlyIndices.at(0),getcol(target_gno,new_id,0));
    get_csv_column(*input,i,input->set[i].dataOnlyIndices.at(1),getcol(target_gno,new_id,1));
//qDebug() << "stringOnlyIndices=" << input->set[i].stringOnlyIndices.length();
        if (input->set[i].stringOnlyIndices.length()>0)//there are string-columns in the file --> add the first string-column as string-column
        {
        get_csv_string_column(*input,i,input->set[i].stringOnlyIndices.at(0),list);
        init_set_string(target_gno,new_id);
            for (int j=0;j<input->set[i].rows;j++)
            {
            //text=list.at(j);
            //qDebug() << "text=" << text << "toUtf8" << text.toUtf8();
            g[target_gno].p[new_id].data.s[j] = copy_string(g[target_gno].p[new_id].data.s[j],list.at(j).toLocal8Bit().constData());
            g[target_gno].p[new_id].data.orig_s[j] = copy_string(g[target_gno].p[new_id].data.orig_s[j],list.at(j).toLocal8Bit().constData());
            /*g[target_gno].p[new_id].data.s[j] = copy_string(g[target_gno].p[new_id].data.orig_s[j],text.toUtf8().constData());
                if (activateLaTeXsupport==TRUE)
                complete_LaTeX_to_Grace_Translator(text);
            generate_string_Qt_aware(str_txt,text);
            g[target_gno].p[new_id].data.orig_s[j] = copy_string(g[target_gno].p[new_id].data.s[j],str_txt);*/
            }

        }
    generateCommentAndLegendAfterImport(input->filename,i,input->set[i].dataOnlyIndices.at(0),input->set[i].dataOnlyIndices.at(1),new_comment,new_legend);
    set_legend_string(target_gno,new_id,new_legend);
    setcomment(target_gno,new_id,new_comment);
    new_set_ids << new_id;
    }
    else
    {
    error_string=tr("Set ")+QString::number(i)+tr(" does not contain enough recognizable columns to generate a XY-set.");
    errmsg(error_string.toLocal8Bit().constData());
    }
    }//end of loop through all sets
}//end of loop through all files
if (filelist.length()>0)//if we read data from different files we have to reset the data displayed to the first file
{
N_DELETE2(input->filename);
input->filename=new char[filelist.at(0).length()*4+8];
strcpy(input->filename,filelist.at(0).toLocal8Bit().constData());
ret=read_csv_file_into_sets(*input,guess_type);
setGUItoInput();
}
int * newGIDs=new int[2+new_set_ids.length()];
int * newSIDs=new int[2+new_set_ids.length()];
for (int i=0;i<new_set_ids.length();i++)
{
newGIDs[i]=target_gno;
newSIDs[i]=new_set_ids.at(i);
}
SetsCreated(new_set_ids.length(),newGIDs,newSIDs,UNDO_COMPLETE);
delete[] newGIDs;
delete[] newSIDs;
    if (input->error_count>0)
    {
    errmsg(input->errors_as_text.toLocal8Bit().constData());
    }
guess_type=sav_guess_type;
mainWin->mainArea->completeRedraw();
unset_wait_cursor();
}

void frmCSVImporterV2::doReadAll(void)
{
QStringList filelist;
mfsel->getSelection(filelist);
if (filelist.length()<=0) return;
set_wait_cursor();
int target_gno=selGraph->currentValue(),new_id,ret;
char * new_comment=new char[GR_MAXPATHLEN],*new_legend=new char[GR_MAXPATHLEN];
int next_data_col,last_string_col,next_string_col;
int colA,colB,counter_in_set;
QString error_string;
QStringList list;
QList<int> new_set_ids;
int sav_guess_type=guess_type;
new_set_ids.clear();
for (int jkl=0;jkl<filelist.length();jkl++)
{
guess_type=0;//no guessing
    readGeneralSettingsIntoInput();
    readDisplaySetting();
    multDataFormSel->getAllFormatSettings(input->csv_column_formats_suggestion);
N_DELETE2(input->filename);
input->filename=new char[filelist.at(jkl).length()*4+8];
strcpy(input->filename,filelist.at(jkl).toLocal8Bit().constData());
    ret=read_csv_file_into_sets(*input,guess_type);
    if (ret==RETURN_FAILURE)
    {
    errmsg(tr("Error reading data from csv-file into sets.").toLocal8Bit().constData());
    }
prepareColumnsForProgression(input);
        for (int i=0;i<input->nr_of_sets;i++)
        {
        counter_in_set=0;
        next_data_col=last_string_col=next_string_col=-1;
            if (input->set[i].rows<=0)
            {
            error_string=tr("Set ")+QString::number(i)+tr(" does not contain data.");
            errmsg(error_string.toLocal8Bit().constData());
            continue;
            }
        error_string.clear();
gatherDefaultColumnIndices(input->set+i);
/*qDebug() << "Set" << i << "dataOnlyIndices  =" << input->set[i].dataOnlyIndices;
qDebug() << "Set" << i << "stringOnlyIndices=" << input->set[i].stringOnlyIndices;*/
        if (input->set[i].dataOnlyIndices.length()>0) next_data_col=input->set[i].dataOnlyIndices.at(0);
        else next_data_col=-1;
        if (input->set[i].stringOnlyIndices.length()>0) next_string_col=input->set[i].stringOnlyIndices.at(0);
        else next_string_col=-1;
        //determine X-column
        colA=next_data_col;
        next_data_col=input->set[i].dataOnlyIndices.indexOf(next_data_col)+1;
        if (next_data_col>=input->set[i].dataOnlyIndices.length()) next_data_col=-1;//no more data available
        else next_data_col=input->set[i].dataOnlyIndices.at(next_data_col);
        //we want to generate new sets (type XY, possibly with a string-column)
        while (next_data_col>=0)
        {
        new_id=nextset(target_gno);
            if (new_id<0)
            {
            error_string=tr("Unable to allocate more sets.");
            errmsg(error_string.toLocal8Bit().constData());
            break;
            }
        set_dataset_type(target_gno,new_id,SET_XY);
        setlength(target_gno,new_id,input->set[i].rows);
        get_csv_column(*input,i,colA,getcol(target_gno,new_id,0));
        get_csv_column(*input,i,next_data_col,getcol(target_gno,new_id,1));
        colB=next_data_col;
        next_data_col=input->set[i].dataOnlyIndices.indexOf(next_data_col)+1;
        if (next_data_col>=input->set[i].dataOnlyIndices.length()) next_data_col=-1;//no more data available
        else next_data_col=input->set[i].dataOnlyIndices.at(next_data_col);
            if (next_string_col>=0)//there are string-columns in the file --> add the first string-column as string-column
            {
            get_csv_string_column(*input,i,next_string_col,list);
            next_string_col=input->set[i].stringOnlyIndices.indexOf(next_string_col)+1;
            if (next_string_col>=input->set[i].stringOnlyIndices.length()) next_string_col=-1;//no more string-columns available
            else next_string_col=input->set[i].stringOnlyIndices.at(next_string_col);
            init_set_string(target_gno,new_id);
                for (int j=0;j<input->set[i].rows;j++)
                {
                ///missing: do the encoding!
                g[target_gno].p[new_id].data.s[j] = copy_string(g[target_gno].p[new_id].data.s[j],list.at(j).toLocal8Bit().constData());
                g[target_gno].p[new_id].data.orig_s[j] = copy_string(g[target_gno].p[new_id].data.orig_s[j],list.at(j).toLocal8Bit().constData());
                }
            }
        generateCommentAndLegendAfterImport(input->filename,i,colA,colB,new_comment,new_legend);
        set_legend_string(target_gno,new_id,new_legend);
        setcomment(target_gno,new_id,new_comment);
        new_set_ids << new_id;
        counter_in_set++;
        }
        if (counter_in_set<=0)
        {
        error_string=tr("Set ")+QString::number(i)+tr(" does not contain enough recognizable columns to generate a XY-set.");
        errmsg(error_string.toLocal8Bit().constData());
        }
        }//end of loop through all sets
}//end of loop through all files
if (filelist.length()>0)//if we read data from different files we have to reset the data displayed to the first file
{
N_DELETE2(input->filename);
input->filename=new char[filelist.at(0).length()*4+8];
strcpy(input->filename,filelist.at(0).toLocal8Bit().constData());
ret=read_csv_file_into_sets(*input,guess_type);
setGUItoInput();
}
//UNDO-stuff
int * newGIDs=new int[2+new_set_ids.length()];
int * newSIDs=new int[2+new_set_ids.length()];
    for (int i=0;i<new_set_ids.length();i++)
    {
    newGIDs[i]=target_gno;
    newSIDs[i]=new_set_ids.at(i);
    }
    SetsCreated(new_set_ids.length(),newGIDs,newSIDs,UNDO_COMPLETE);
delete[] newGIDs;
delete[] newSIDs;
        if (input->error_count>0)
        {
        errmsg(input->errors_as_text.toLocal8Bit().constData());
        }
guess_type=sav_guess_type;
mainWin->mainArea->completeRedraw();
unset_wait_cursor();
}

void frmCSVImporterV2::doReadBlockData(void)
{
//qDebug() << "Read All Data from file into block-data for later use.";
QStringList filelist;
mfsel->getSelection(filelist);
if (filelist.length()<=0) return;

int sav_guess_type=guess_type;
int ret;
QString error_string;
QStringList list;

guess_type=0;//no guessing
    readGeneralSettingsIntoInput();
    readDisplaySetting();
    multDataFormSel->getAllFormatSettings(input->csv_column_formats_suggestion);
N_DELETE2(input->filename);
input->filename=new char[filelist.at(0).length()*4+8];
strcpy(input->filename,filelist.at(0).toLocal8Bit().constData());
    ret=read_csv_file_into_sets(*input,guess_type);
        if (input->nr_of_sets<1)
        {
        error_string=tr("File ")+filelist.at(0)+tr(" does not contain readable data in first set.");
        errmsg(error_string.toLocal8Bit().constData());
        return;
        }
        if (input->set[0].rows<=0)
        {
        error_string=tr("Set ")+QString::number(0)+tr(" does not contain data.");
        errmsg(error_string.toLocal8Bit().constData());
        return;
        }
    error_string.clear();
    gatherDefaultColumnIndices(input->set+0);
QStringList stringcol;
ss_data ssd;
double * d_ptr;
char ** sp;
int * formats=new int[2+input->set[0].columns];
    for (int i=0;i<input->set[0].columns;i++)
    {
    formats[i]=simplified_format(input->set[0].csv_column_formats.at(i));
    if (formats[i]==FFORMAT_DATE) formats[i]=FFORMAT_NUMBER;//changed because the new format is double and the original block-data-import is unable to read date/time
    }
init_ss_data(&ssd,input->set[0].columns,formats);
        for (int i=0;i<input->set[0].columns;i++)
        {
            if (formats[i]==FFORMAT_STRING)
            {
            get_csv_string_column(*input,0,i,stringcol);
            ssd.data[i] = (void*)xmalloc(input->set[0].rows*sizeof(char*));
            sp = (char **)ssd.data[i];
                for (int j=0;j<input->set[0].rows;j++)
                {
                sp[j]=copy_string(NULL,stringcol.at(j).toLocal8Bit().constData());
                }
            }
            else
            {
            ssd.data[i] = (void*)xmalloc(input->set[0].rows*sizeof(double));
            d_ptr = (double*)ssd.data[i];
            get_csv_column(*input,0,i,d_ptr);
            }
        }
ssd.nrows=input->set[0].rows;
set_blockdata(&ssd);
if (FormEditBlockData==NULL)
{
    FormEditBlockData=new frmEditBlockData(mainWin);
}
FormEditBlockData->init();
FormEditBlockData->hide();
FormEditBlockData->filename=filelist.at(0);
error_string.clear();
error_string=tr("Data from file ")+FormEditBlockData->filename+tr(" has been copied into block-data.\n")+QString::number(ssd.nrows)+tr(" rows, ")+QString::number(ssd.ncols)+tr(" columns");
stufftext(error_string.toLocal8Bit().constData());
guess_type=sav_guess_type;
}

void frmCSVImporterV2::doOpenEditBlockData(void)
{
mainWin->mainArea->inlineSetPopup->doCreateFromBlockData();
}

void frmCSVImporterV2::newFilesSelection(QStringList l)
{
//qDebug() << "New File(s) entered:" << l;
    if (chkGuess->isChecked()==true && l.length()>0)
    {
        set_wait_cursor();
        readGeneralSettingsIntoInput();
        readDisplaySetting();
        N_DELETE2(input->filename);
        input->filename=new char[l.at(0).length()*4+8];
        strcpy(input->filename,l.at(0).toLocal8Bit().constData());
        //qDebug() << "single_filename=" << input->filename;
        int ret=read_csv_file_into_sets(*input,guess_type);
        //qDebug() << "ret=" << ret;
        setGUItoInput();
        if (input->error_count>0)
        {
        errmsg(input->errors_as_text.toLocal8Bit().constData());
        }
        unset_wait_cursor();
    }
}

void frmCSVImporterV2::doOpenFormat(void)
{
QString filename=QFileDialog::getOpenFileName(this,tr("Open Settings"),qt_grace_templates_dir,QString("*.fmt"));
if (filename.isEmpty()==false)
{
//qDebug() << "Loading from file:" << filename;
ifstream ifi;
ifi.open(filename.toLocal8Bit().constData());
loadCSV_multiSetFormat_FromFile(ifi,input);
ifi.close();
/*qDebug() << "nr_of_sets=" << input->nr_of_sets;
    for (int i=0;i<input->nr_of_sets;i++)
    {
    qDebug() << i << ": cols=" << input->set[i].columns << "column-formats=" << input->set[i].csv_column_formats;
    input->set[i].columns=input->set[i].csv_column_formats.length();
    }
setGUItoInput();*/
for (int i=0;i<input->nr_of_sets;i++)
{
    input->set[i].rows=0;
    input->set[i].columns=input->set[i].csv_column_formats.length();
input->set[i].colsep=input->default_col_separator;
input->set[i].datsep=input->line_separator;
}
input->error_count=0;
struct csv_multi_import_infos * sav_input;
sav_input=new struct csv_multi_import_infos;
init_mcsv_import_infos(sav_input);

copy_mcsv_import_infos(sav_input,input,false);
//set neccessary input-data
setGUItoInput(false);
//loading file
doReRead();//includes setGUItoInput()
postproset->set_data_to_input(*sav_input);
postproset->updateVisibilites();
delete sav_input;
}
}

void frmCSVImporterV2::doSaveFormat(void)
{
QString filename=QFileDialog::getSaveFileName(this,tr("Save Settings"),qt_grace_templates_dir,QString("*.fmt"));
if (filename.isEmpty()==false)
{
//qDebug() << "Saving to file:" << filename;
    readGeneralSettingsIntoInput();
    postproset->readSettings(*input);
ofstream ofi;
ofi.open(filename.toLocal8Bit().constData());
saveCSV_multiSetFormat_ToFile(ofi,input);
ofi.close();
//qDebug() << "Finished saving.";
}
}

void frmCSVImporterV2::readGeneralSettingsIntoInput(void)
{
    input->komma_is_decimal_sep=(selDecSep->currentIndex()==0?false:true);
    input->invalid_value=selInvalidVal->value();
    input->default_col_separator=selColSep->currentValue();
    input->line_separator=selLineSep->currentValue();
    input->headerlines=selHeaderLines->value();
}

void frmCSVImporterV2::readAllInputs(void)
{
readGeneralSettingsIntoInput();

}

void frmCSVImporterV2::readDisplaySetting(void)
{
    input->htmlShowValues=actShowValues->isChecked();
    input->htmlShowComments=actShowComments->isChecked();
    input->htmlShowOriginal=actShowOriginal->isChecked();
    input->htmlShowErrorLines=actShowErrors->isChecked();
    input->htmlShowHeaderLines=actShowHeader->isChecked();
    input->startValues=selStartLines->value();
    input->endValues=selStopLines->value();
}

void frmCSVImporterV2::contentsToggled(bool t)
{
    (void)t;
    txtContent->setVisible(grpContents->isChecked());
}

void frmCSVImporterV2::doApply(void)
{
QStringList filelist;
mfsel->getSelection(filelist);
if (filelist.length()<1) return;
readAllInputs();//--> copy data into csv-read-template
int sav_guess_type=guess_type;
guess_type=0;//no further guessing here!
QString error_text;
int target_gno=selGraph->currentValue();
//int target_set=-1;
int tmp1,tmp2,c;
int number,*sel=new int[2];
//int nr_of_new_sets=0;
int * new_graph_ids=new int[2+filelist.length()];
int * new_set_ids=new int[2+filelist.length()];
int * old_set_ids=new int[2+filelist.length()];
lstSet->get_selection(&number,&sel);
int ret,source_setid;
QList<int> sourcecols;
QList<int> target_graphs,target_sets,used_target_sets;
//delete the memory for new set-ids for undo
N_DELETE2(new_set_nos);
N_DELETE2(new_graph_nos);
new_set_no=0;
//append_to_storage2(&new_set_no,&new_set_nos,&new_graph_nos,1,&new_graph,&new_set);
set_wait_cursor();
//target-columns from postprocessing
postproset->readSettings(*input);
source_setid=0;

QList<char> lstColumnSep,lstDataSep,lstTextSep;
QList<bool> lstDecSep;
QList< QList<int> > lstSavedCSVColumnFormats;
lstColumnSep.clear();
lstDataSep.clear();
lstTextSep.clear();
lstDecSep.clear();
lstSavedCSVColumnFormats.clear();

//first we have to save the settings
multDataFormSel->getAllFormatSettings(lstSavedCSVColumnFormats);
for (int i=0;i<input->nr_of_sets;i++)
{
lstColumnSep << input->set[i].colsep;
lstDataSep << input->set[i].datsep;
lstTextSep << input->set[i].textsep;
lstDecSep << input->set[i].dec_sep_komma;
}

int max_cols=settype_cols(input->targetSetType);
for (int i=0;i<input->postprocess_target_col.length();i++)
{
        /*if (input->postprocess_target_col.at(i)<0 || input->postprocess_target_col.at(i)>5)
        qDebug() << i << ": Target=" << input->postprocess_target_col.at(i) << " --> "<< input->postprocess_target_col.at(i) << "/" << max_cols;
        else
        qDebug() << i << ": Target=" << dataset_colname(input->postprocess_target_col.at(i)) << " --> "<< input->postprocess_target_col.at(i) << "/" << max_cols;*/
    if (input->postprocess_target_col.at(i)>=max_cols)
    {
    error_text=tr("Target set type does not have column ")+QString(dataset_colname(input->postprocess_target_col.at(i)))+tr(". This target column will be ignored.");
    errmsg(error_text.toLocal8Bit().constData());
    input->postprocess_target_col.removeAt(i);
    input->postprocess_operation_type.removeAt(i);
    input->postprocess_operation_source1.removeAt(i);
    input->postprocess_operation_source2.removeAt(i);
    input->postprocess_operation_source1_sav.removeAt(i);
    input->postprocess_operation_source2_sav.removeAt(i);
    input->postprocess_operation_source_set1.removeAt(i);
    input->postprocess_operation_source_set2.removeAt(i);
    input->postprocess_val1.removeAt(i);
    input->postprocess_val2.removeAt(i);
    input->postprocess_advancement1.removeAt(i);
    input->postprocess_advancement2.removeAt(i);
    i--;
    }
}
QString description;
description.clear();
//we have to fill target_graphs, target_sets with suggestions for new set-ids
target_graphs.clear();
target_sets.clear();
for (int i=0;i<number;i++)
{
target_graphs << target_gno;
target_sets << sel[i];
}
if (number<=0)
{
c=-2;//we start with a color and give different colors to all new sets
}
else
{
c=-1;//no color changes because we work with exisiting sets
}
used_target_sets.clear();
//go throught the list of files and load data from every file
for (int i=0;i<filelist.length();i++)
{
    for (int j=0;j<used_target_sets.length();j++)//we have to remove the already used indices from the beginning of the list
    {
    if (target_graphs.length()>0) target_graphs.removeFirst();
    if (target_sets.length()>0) target_sets.removeFirst();
    }
    if (target_graphs.length()<=0)//if there are no suggested graphs and sets left --> fill with a dummy
    {
    target_graphs.clear();
    target_sets.clear();
    target_graphs << target_gno;
    target_sets << -1;
    }
    used_target_sets.clear();//we have to clear this for every file
N_DELETE2(input->filename);
input->filename=new char[filelist.at(i).length()*4+8];
strcpy(input->filename,filelist.at(i).toLocal8Bit().constData());
input->csv_column_formats_suggestion=lstSavedCSVColumnFormats;//for every new file we make the same suggestions
if (i>0) description+=QString(", ");
description+=filelist.at(i);
ret=read_csv_file_into_sets(*input,guess_type);//do the actual reading (this reads all data in memory, the new sets will be constructed later)

//qDebug() << "Read from file:" << filelist.at(i);
//we construct more than one set from each file
//IMPORTANT: All files have to have the same file-format
//we have to reset the filename in "input" for every file and order a re-reading of the file with same format-settings as before
//if more than one set is to be read from a file we have to increase the column-indices

//qDebug() << "postprocessing START, used target sets=" << used_target_sets << "new_set_no=" << new_set_no;
//this just reads and generates a single(!) set (the reading from the file has to be completed beforehand); strictly speaking more than a single set is created if a target column is set more than once
//if multiple sets are wanted the different settings have to be made elsewhere
ret=constructSetFromCSVWithPostprocessing(*input,target_graphs,target_sets,used_target_sets);
//qDebug() << "postprocessing STOP, used target sets=" << used_target_sets << "new_set_no=" << new_set_no;
//add new set-ids to list of new set-ids for undo-function later
//qDebug() << "usedTargetSets.length=" << used_target_sets.length() << "target_graphs.length=" << target_graphs.length();
    for (int j=0;j<used_target_sets.length();j++)
    {
    tmp1=target_graphs.at(j);
    tmp2=used_target_sets.at(j);
    append_to_storage2(&new_set_no,&new_graph_nos,&new_set_nos,1,&tmp1,&tmp2);
    }
}
delete[] sel;
delete[] new_graph_ids;
delete[] new_set_ids;
delete[] old_set_ids;

if (new_set_no>0)
{
    if (c==-2)
    {
    c=new_set_nos[0];
    }
    if (c>=0)
    {
        for (int i=0;i<new_set_no;i++)
        {
            if (new_set_nos[i]>0) c=g[new_graph_nos[i]].p[new_set_nos[i]-1].linepen.color+1;
            while (c == getbgcolor() || get_colortype(c) != COLOR_MAIN)
            {
            c++;
            c %= number_of_colors();
            }
        (void)set_set_colors(new_graph_nos[i],new_set_nos[i],c);
            c++;
            c %= number_of_colors();
        }
    }
    /*qDebug() << "undo: new_set_no=" << new_set_no;
    for (int k=0;k<new_set_no;k++)
    {
    qDebug() << "G" << new_graph_nos[k] << ".S" << new_set_nos[k];
    }*/
//undo-stuff
SetsCreated(new_set_no,new_graph_nos,new_set_nos,UNDO_COMPLETE);
description=tr("Set")+(new_set_no>1?tr("s"):QString(""))+tr(" created from CSV-file")+(filelist.length()>1?tr("s"):QString(""))+QString(": ")+description;
addAditionalDescriptionToLastNode(-1,description,QString(),-1);//usefull for adding a formula or changing the description
}
    if (postproset->selAutoScale->currentIndex()>0)
    {
        if (postproset->selAutoScale->currentIndex()==1)
        mainWin->doAX();
        else if (postproset->selAutoScale->currentIndex()==2)
        mainWin->doAY();
        else
        mainWin->doAutoScale();
    }
    else
    {
    mainWin->mainArea->completeRedraw();
    }
guess_type=sav_guess_type;
unset_wait_cursor();
}

void frmCSVImporterV2::doAccept(void)
{
    ApplyError=false;
doApply();
    if (ApplyError==false)
    doClose();
}

void frmCSVImporterV2::doClose(void)
{
    hide();
}

frmProgressWin::frmProgressWin(QWidget * parent):QDialog(parent)
{
setWindowTitle(tr("Current progress"));
lblText=new QLabel(QString(""),this);
progress=new QProgressBar(this);
layout=new QVBoxLayout;
//layout->setMargin(0);
layout->setContentsMargins(0,0,0,0);
layout->setSpacing(0);
layout->addWidget(lblText);
layout->addWidget(progress);
setLayout(layout);
resize(LastSize_FormProgress);
}

frmProgressWin::~frmProgressWin()
{
    LastSize_FormProgress=this->size();
}

void frmProgressWin::init(QString text,int max)
{
    if (text.isEmpty())
    {
    lblText->setVisible(false);
    }
    else
    {
    lblText->setText(text);
    lblText->setVisible(true);
    }
progress->setRange(0,max);
progress->setValue(0);
}

void frmProgressWin::increase(void)
{
progress->setValue(progress->value()+1);
qApp->processEvents();
}

void frmProgressWin::setVal(int val)
{
progress->setValue(val);
qApp->processEvents();
}

frmQuestionDialog::frmQuestionDialog(QWidget * parent):QDialog(parent)
{
//lblIcon=new QLabel(this);
//lblIcon->setPixmap(qApp->style()->standardPixmap(QStyle::SP_MessageBoxQuestion));
    lblIcon=new QLabel(this);
    QPixmap pm;
    pm=qApp->style()->standardIcon(QStyle::SP_MessageBoxQuestion).pixmap(50,50);
    lblIcon->setPixmap(pm);

layout=new QGridLayout();
//layout->setMargin(STD_MARGIN);
layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
layout->setSpacing(STD_SPACING);
cmdYes=new QPushButton(tr("Yes"),this);
cmdNo=new QPushButton(tr("No"),this);
cmdSave=new QPushButton(tr("Save"),this);
cmdSaveAs=new QPushButton(tr("SaveAs..."),this);
connect(cmdYes,SIGNAL(clicked()),SLOT(doYes()));
connect(cmdNo,SIGNAL(clicked()),SLOT(doNo()));
connect(cmdSave,SIGNAL(clicked()),SLOT(doSave()));
connect(cmdSaveAs,SIGNAL(clicked()),SLOT(doSaveAs()));
lblText=new QLabel("",this);
QFont fnt=lblText->font();
fnt.setPixelSize(16);
lblText->setFont(fnt);

//layout->addWidget(lblIcon,0,0,2,2);
//layout->addWidget(lblText,0,2,2,4);
//layout->addWidget(cmdYes,2,2,1,1);
//layout->addWidget(cmdNo,2,3,1,1);
//layout->addWidget(cmdSave,2,4,1,1);
//layout->addWidget(cmdSaveAs,2,5,1,1);
layout->addWidget(lblIcon,0,0,1,1);
layout->addWidget(lblText,0,1,1,3);
layout->addWidget(cmdYes,1,0,1,1);
layout->addWidget(cmdNo,1,1,1,1);
layout->addWidget(cmdSave,1,2,1,1);
layout->addWidget(cmdSaveAs,1,3,1,1);

setLayout(layout);
resize(LastSize_FormQuestion);
}

frmQuestionDialog::~frmQuestionDialog()
{
    LastSize_FormQuestion=this->size();
}

void frmQuestionDialog::init(QString text,QString title_text,bool show_Save,bool show_SaveAs,bool show_Yes, bool show_No)
{
lblText->setText(text);
setWindowTitle(title_text);
cmdYes->setVisible(show_Yes);
cmdNo->setVisible(show_No);
cmdSave->setVisible(show_Save);
cmdSaveAs->setVisible(show_SaveAs);
}

void frmQuestionDialog::doYes(void)
{
    //done(QMessageBox::Yes);
    done(1);
}

void frmQuestionDialog::doNo(void)
{
    //done(QMessageBox::No);
    done(0);//Cancel
}

void frmQuestionDialog::doSave(void)
{
    if (strcmp (get_docname(), NONAME) != 0)
    {
    bool readable,writeable,overwrite=false;
    long kB;
    bool exists=get_file_infos(QString(get_docname()),readable,writeable,kB);
        if (exists==true)
        {
        int ret=QMessageBox::question(this,tr("Warning! File exists!"),tr("Overwite file ")+QString(get_docname())+tr("?"),QMessageBox::Yes,QMessageBox::No);
            if (ret==QMessageBox::Yes)
            overwrite=true;
            else
            overwrite=false;
        }
        if (exists==false || overwrite==true)
        {
        save_project(get_docname());
        done(1);
        }
        else
        done(0);
    }
    else
    doSaveAs();
}

void frmQuestionDialog::doSaveAs(void)
{
QString filename=QFileDialog::getSaveFileName(this,tr("Save Project"));
//cout << endl << "filename=#" << filename.toLocal8Bit().constData() << "#" << endl;
if (filename.isEmpty())
{
done(0);
return;
}

QFileInfo finfo(filename);
QString suf=finfo.suffix();
if (suf.isEmpty() && auto_set_agr_extension)
{
filename=finfo.path()+QDir::separator()+finfo.completeBaseName()+QString(".agr");
}

bool readable,writeable,overwrite=false;
long kB;
bool exists=get_file_infos(filename,readable,writeable,kB);

if (exists==true)
{
int ret=QMessageBox::question(this,tr("Warning! File exists!"),tr("Overwite file ")+filename+tr("?"),QMessageBox::Yes,QMessageBox::No);
    if (ret==QMessageBox::Yes)
    overwrite=true;
    else
    overwrite=false;
}
if (exists==false || overwrite==true)
{
save_project(filename.toLocal8Bit().data());
done(1);
}
else
done(0);
}

frmSimpleListSelectionDialog::frmSimpleListSelectionDialog(QWidget * parent):QDialog(parent)
{
layout=new QGridLayout();
//layout->setMargin(STD_MARGIN);
layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
layout->setSpacing(STD_SPACING);
selNames=new StdSelector(this,tr("Load exisiting standard binary format:"),0,NULL);
ledNewName=new stdLineEdit(this,tr("Enter new name for binary format:"));
cmdCancel=new QPushButton(tr("Cancel"),this);
connect(cmdCancel,SIGNAL(clicked()),SLOT(doCancel()));
cmdSelect=new QPushButton(tr("Load"),this);
connect(cmdSelect,SIGNAL(clicked()),SLOT(doSelect()));
cmdNew=new QPushButton(tr("Use new name"),this);
connect(cmdNew,SIGNAL(clicked()),SLOT(doNew()));
return_name=QString("");
return_nr=-1;//nothing
setWindowTitle(tr("Select standard binary format"));
layout->addWidget(selNames,0,0,1,1);
layout->addWidget(cmdSelect,0,1,1,1);
layout->addWidget(ledNewName,1,0,1,1);
layout->addWidget(cmdNew,1,1,1,1);
layout->addWidget(cmdCancel,2,1,1,1);
setLayout(layout);
resize(LastSize_FormSimpleListSel);
}

frmSimpleListSelectionDialog::~frmSimpleListSelectionDialog()
{
    LastSize_FormSimpleListSel=this->size();
}

void frmSimpleListSelectionDialog::init(QString * name_list,int nr,bool read)
{
selNames->setNewEntries(nr,name_list);
ledNewName->setText("");
    if (read==true)
    {
    selNames->lblText->setText(tr("Load exisiting standard binary format:"));
    ledNewName->setVisible(false);
    cmdNew->setVisible(false);
    cmdSelect->setText(tr("Load"));
    }
    else
    {
    selNames->lblText->setText(tr("Overwrite exisiting standard binary format:"));
    ledNewName->setVisible(true);
    cmdNew->setVisible(true);
    cmdSelect->setText(tr("Save"));
    }
}

void frmSimpleListSelectionDialog::doCancel(void)
{
    return_name=QString("");
    return_nr=-1;
    done(0);
}

void frmSimpleListSelectionDialog::doSelect(void)
{
    return_name=selNames->entries[selNames->currentIndex()];
    return_nr=selNames->currentIndex();
    done(1);
}

void frmSimpleListSelectionDialog::doNew(void)
{
    if (ledNewName->text().isEmpty())
    {
    QMessageBox::warning(this,tr("Error"),tr("Please enter a proper name for the binary format!"));
    }
    else
    {
    QString text=ledNewName->text();
    return_name=text.replace(QString(" "),QString("_"));
    return_nr=-2;//new name/file
    done(1);
    }
}

frmReportOnFitParameters::frmReportOnFitParameters(QWidget * parent):QDialog(parent)
{
layout=new QGridLayout();
//layout->setMargin(STD_MARGIN);
layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
layout->setSpacing(0);
int line=0,col=0;
cmdReport=new QPushButton(tr("Report"),this);
cmdUpdate=new QPushButton(tr("Update"),this);
cmdReport->setToolTip(tr("List all settings for every fit-parameter"));
cmdUpdate->setToolTip(tr("Reread the values of the fit-parameters\n(update GUI)"));
layout->addWidget(cmdUpdate,line,0,1,2);
layout->addWidget(cmdReport,line++,2,1,2);
lblName[0]=new QLabel(tr("Name"),this);
lblName[1]=new QLabel(tr("Name"),this);
lblValue[0]=new QLabel(tr("Value"),this);
lblValue[1]=new QLabel(tr("Value"),this);
    layout->addWidget(lblName[0],line,0);
    layout->addWidget(lblName[1],line,2);
    layout->addWidget(lblValue[0],line,1);
    layout->addWidget(lblValue[1],line++,3);
setWindowTitle(tr("Report on fit parameters"));

/// Decimaltrennzeichen umwandeln (auch in report!)

QLocale newLocale=(DecimalPointToUse=='.')?(*dot_locale):(*comma_locale);
for (int i=0;i<MAXPARM;i++)
{
spnPara[i]=new LineWidthSelector(this);
spnPara[i]->lblText->setText(QString("a")+QString::number(i));
spnPara[i]->spnLineWidth->setDecimals(6);
spnPara[i]->spnLineWidth->setSingleStep(0.0001);
spnPara[i]->spnLineWidth->setRange(-DBL_MAX,DBL_MAX);
spnPara[i]->setLocale(newLocale);
if (i==MAXPARM/2) {col=2;line=2;}
layout->addWidget(spnPara[i],line++,col,1,2);
}
cmdSet=new QPushButton(tr("Set"),this);
cmdSet->setToolTip(tr("Set the fit-values to the values displayed here"));
cmdClose=new QPushButton(tr("Close"),this);
connect(cmdClose,SIGNAL(clicked()),SLOT(doClose()));
connect(cmdSet,SIGNAL(clicked()),SLOT(doSet()));
connect(cmdReport,SIGNAL(clicked()),SLOT(doReport()));
connect(cmdUpdate,SIGNAL(clicked()),SLOT(init()));
layout->addWidget(cmdSet,line,0,1,2);
layout->addWidget(cmdClose,line++,2,1,2);
setLayout(layout);
resize(LastSize_FormReportFitParameters);
}

frmReportOnFitParameters::~frmReportOnFitParameters()
{
    LastSize_FormReportFitParameters=this->size();
}

void frmReportOnFitParameters::init(void)
{
    for (int i=0;i<MAXPARM;i++)
    {
    spnPara[i]->setValue(nonl_parms[i].value);
    }
}

void frmReportOnFitParameters::doSet(void)
{
    for (int i=0;i<MAXPARM;i++)
    {
    nonl_parms[i].value=spnPara[i]->value();
    }
}

void frmReportOnFitParameters::doReport(void)
{
QString tmptext;
char dummy_vals[128];
    stufftext(tr("Current settings for fit-parameters:").toLocal8Bit().constData());
    for (int i=0;i<MAXPARM;i++)
    {
    tmptext=QString("A")+QString::number(i)+QString("=");
    sprintf(dummy_vals,sformat,nonl_parms[i].value);
    SetDecimalSeparatorToUserValue(dummy_vals,false);
    tmptext+=QString(dummy_vals)+QString("\t ")+tr("Min=");
    sprintf(dummy_vals,sformat,nonl_parms[i].min);
    SetDecimalSeparatorToUserValue(dummy_vals,false);
    tmptext+=QString(dummy_vals)+QString("\t ")+tr("Max=");
    sprintf(dummy_vals,sformat,nonl_parms[i].max);
    SetDecimalSeparatorToUserValue(dummy_vals,false);
    tmptext+=QString(dummy_vals)+QString("\t ")+tr("Use constrains=")+(nonl_parms[i].constr==0?tr("No"):tr("Yes"));
    stufftext(tmptext.toLocal8Bit().constData());
    }
}

void frmReportOnFitParameters::doClose(void)
{
hide();
}

frmGeometricEvaluation::frmGeometricEvaluation(QWidget * parent):QDialog(parent)
{
setWindowTitle(tr("QtGrace: Geometric evaluation"));
int index=0;
layout=new QGridLayout(this);
layout->setSpacing(STD_SPACING);
//layout->setMargin(STD_MARGIN);
layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
sourceSelect=new grpSelect(tr("Source:"),this);
sourceSelect->lblGraph->setText(tr("Select one source graph:"));
sourceSelect->lblSet->setText(tr("Select two source sets:"));
int nr_of_entries=5;
QString * entries=new QString[8];

entries[0]=tr("Intersections");
entries[1]=tr("Intersection angles");
entries[2]=tr("Intersections and angles");
entries[3]=tr("Area of polygon");
entries[4]=tr("Length of polygon-path");
selOption=new StdSelector(this,tr("Find:"),nr_of_entries,entries);

nr_of_entries=3;
entries[0]=tr("Intersection-X");
entries[1]=tr("Index");
entries[2]=tr("None / report only");
selLoadX=new StdSelector(this,tr("Load x as:"),nr_of_entries,entries);

nr_of_entries=7;
entries[0]=tr("None");
entries[1]=tr("Region 0");
entries[2]=tr("Region 1");
entries[3]=tr("Region 2");
entries[4]=tr("Region 3");
entries[5]=tr("Region 4");
entries[6]=tr("Inside graph");
selRegion=new StdSelector(this,tr("Restrictions:"),nr_of_entries,entries);
chkInvert=new QCheckBox(tr("Negate region"),this);

delete[] entries;
buttons=new stdButtonGroup(this);
connect(buttons->cmdApply,SIGNAL(clicked()),SLOT(doApply()));
connect(buttons->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
connect(buttons->cmdClose,SIGNAL(clicked()),SLOT(doClose()));

layout->addWidget(selOption,index++,0);
layout->addWidget(sourceSelect,index++,0);
layout->addWidget(selLoadX,index++,0);
layout->addWidget(selRegion,index++,0);
layout->addWidget(chkInvert,index++,0);
layout->addWidget(buttons,index++,0);

connect(selOption,SIGNAL(currentIndexChanged(int)),this,SLOT(optionChanged(int)));

setLayout(layout);
resize(LastSize_FormGeometricEvaluation);
}

frmGeometricEvaluation::~frmGeometricEvaluation()
{
    LastSize_FormGeometricEvaluation=this->size();
}

void frmGeometricEvaluation::optionChanged(int v)
{
int nr_of_entries=3;
QString entries[3];
entries[1]=tr("Index");
entries[2]=tr("None / report only");
switch (v)
{
default:
case 0://Intersections
case 1://Intersection angles
case 2://Intersections and angles
entries[0]=tr("Intersection-X");
sourceSelect->lblSet->setText(tr("Select two source sets:"));
break;
case 3://Area of polygon
case 4://Length of polygon-path
entries[0]=tr("Set-ID");
sourceSelect->lblSet->setText(tr("Select source set(s):"));
break;
}
selLoadX->setNewEntries(nr_of_entries,entries);
}

void frmGeometricEvaluation::init(void)
{
sourceSelect->update_number_of_entries();
sourceSelect->set_graph_nr(cg);
sourceSelect->listGraph->set_graph_number(cg,false);
}

void frmGeometricEvaluation::doApply(void)
{
int src_g,n_src_sets,*src_s=new int[2];
int option,load_x,sorton,invert_region;
int n_set,setlen,index;
int ret,is_in,resno;
int nr_of_intersections=0,nr_of_points_in_region=0;
char dummy[128];
char * rarray=NULL;
QString report,n_legend;
double * intersection_x=NULL;
double * intersection_y=NULL;
double * intersection_a=NULL;
double * m1=NULL;
double * m2=NULL;
double * m3=NULL;
double * orig_x, * orig_y;
int l1,l2;
double worksize;
QString s1,s2,s_msg;
option=selOption->currentValue();
load_x=selLoadX->currentValue();
switch (selRegion->currentIndex())
{
case 0:
default:
    sorton=RESTRICT_NONE;
    break;
case 1:
    sorton=RESTRICT_REG0;
    break;
case 2:
    sorton=RESTRICT_REG1;
    break;
case 3:
    sorton=RESTRICT_REG2;
    break;
case 4:
    sorton=RESTRICT_REG3;
    break;
case 5:
    sorton=RESTRICT_REG4;
    break;
case 6:
    sorton=RESTRICT_WORLD;
    break;
}
invert_region=chkInvert->isChecked()==true?1:0;
sourceSelect->listGraph->get_selection(&n_src_sets,&src_s);
if (n_src_sets!=1)
{
errwin(tr("Please select a single source-graph.").toLocal8Bit().constData());
goto finish_Apply_geomEval;
}
else src_g=src_s[0];
sourceSelect->listSet->get_selection(&n_src_sets,&src_s);
if (option<3 && n_src_sets!=2)
{
errwin(tr("Please select two source-sets.").toLocal8Bit().constData());
goto finish_Apply_geomEval;
}
else if (n_src_sets<1)
{
errwin(tr("Please select at least one source-set.").toLocal8Bit().constData());
goto finish_Apply_geomEval;
}

if (option<3 && (getsetlength(src_g,src_s[0])<=1 || getsetlength(src_g,src_s[1])<=1))
{
errwin(tr("Please select two source-sets with more than one point each.").toLocal8Bit().constData());
goto finish_Apply_geomEval;
}

l1=getsetlength(src_g,src_s[0]);
l2=getsetlength(src_g,src_s[1]);
worksize=log(fabs(l1*l2))/log(10.0);
s1=tr("Warning");
s2.clear();
s_msg.clear();
if (worksize>=7.95 && worksize<8.99)
{
   s_msg=tr("Finding intersections with these sets will take some time.\nProceed anyway?");
}
else if (worksize>=8.95)
{
   s_msg=tr("Finding intersections with these sets will take extremely long.\nProceed anyway?");
}
if (!s_msg.isEmpty())
{
    if (!yesnowin(s_msg.toLocal8Bit().constData(),s1.toLocal8Bit().constData(),s2.toLocal8Bit().constData(),NULL))
    {
    goto finish_Apply_geomEval;
    }
}

set_wait_cursor();

if (option==0 || option==1 || option==2)
{
//ret=get_all_intersection_points_between_two_sets(src_g,src_s[0],src_g,src_s[1],&intersection_x,&intersection_y,&nr_of_intersections);
ret=get_all_intersection_points_and_all_angles_between_two_sets(src_g,src_s[0],src_g,src_s[1],&intersection_x,&intersection_y,&intersection_a,&nr_of_intersections);
if (ret==RETURN_FAILURE || intersection_x==NULL || intersection_y==NULL || intersection_a==NULL || nr_of_intersections<1)
{
errwin(tr("No Intersections found!").toLocal8Bit().constData());
goto finish_Apply_geomEval;
}
/*qDebug() << "10*dbl_epsilon=" << 10*DBL_EPSILON;*/
//qDebug() << "nr_of_intersections=" << nr_of_intersections << endl;
if (sorton!=RESTRICT_NONE)
{
nr_of_points_in_region=0;
new_set_no=-1;
    if (m1!=NULL) delete[] m1;
    m1=new double[nr_of_intersections+1];
    if (m2!=NULL) delete[] m2;
    m2=new double[nr_of_intersections+1];
    if (m3!=NULL) delete[] m3;
    m3=new double[nr_of_intersections+1];
//reduce intersections to the ones inside the selected region
for (int i=0;i<nr_of_intersections;i++)
{
    if (sorton==RESTRICT_WORLD)
    is_in=isInWorld(src_g,intersection_x[i],intersection_y[i]);
    else
    is_in=inregion(sorton,intersection_x[i],intersection_y[i]);

    if ((is_in && invert_region==false) || (!is_in && invert_region==true))
    {
    m1[nr_of_points_in_region]=intersection_x[i];
    m2[nr_of_points_in_region]=intersection_y[i];
    m3[nr_of_points_in_region]=intersection_a[i];
    nr_of_points_in_region++;
    }
}
memcpy(intersection_x,m1,sizeof(double)*nr_of_points_in_region);
memcpy(intersection_y,m2,sizeof(double)*nr_of_points_in_region);
memcpy(intersection_a,m3,sizeof(double)*nr_of_points_in_region);
nr_of_intersections=nr_of_points_in_region;
}
else
{
nr_of_points_in_region=nr_of_intersections;
}
//now we have reduced the intersections to the ones inside the selected region
//qDebug() << "after region-check: nr_of_intersections=" << nr_of_intersections << endl;
    if (ret==RETURN_FAILURE || intersection_x==NULL || intersection_y==NULL || intersection_a==NULL || nr_of_points_in_region<=0)
    {
    errwin(tr("No Intersections found!").toLocal8Bit().constData());
    goto finish_Apply_geomEval;
    }
}//end option 0 || 1 || 2
else if (option==3 || option==4)
{
if (m1!=NULL) delete[] m1;
m1=new double[n_src_sets+1];
    for (int i=0;i<n_src_sets;i++)
    {
    orig_x = getcol(src_g,src_s[i],DATA_X);
    orig_y = getcol(src_g,src_s[i],DATA_Y);
        if (m2!=NULL) delete[] m2;
        if (m3!=NULL) delete[] m3;
        XCFREE(rarray);
        resno = get_restriction_array(src_g, src_s[i], sorton, invert_region, &rarray);
        setlen = getsetlength(src_g,src_s[i]);
        m2=new double[setlen+1];
        m3=new double[setlen+1];
            if (rarray==NULL)
            {
            index=setlen;
            memcpy(m2,orig_x,setlen*sizeof(double));
            memcpy(m3,orig_y,setlen*sizeof(double));
            }
            else
            {
            index=0;
            for (int j=0;j<setlen;j++)
            {
                if (rarray[j]==1)
                {
                m2[index]=orig_x[j];
                m3[index++]=orig_y[j];
                }
            }
            }
        if (option==3)
        {
        m1[i]=comp_area(index,m2,m3);
        }
        else//option==4
        {
        m1[i]=comp_perimeter(index,m2,m3);
        }
    }
}

switch (option)
{
default:
case 0://Intersections
n_legend=tr("Intersection points between ")+QString("G")+QString::number(src_g)+QString(".S")+QString::number(src_s[0])+tr(" and ")+QString("G")+QString::number(src_g)+QString(".S")+QString::number(src_s[1]);
    if (load_x==2)//report only
    {
    report.clear();
    report+=n_legend+QString(":\n");
        for (int i=0;i<nr_of_intersections;i++)
        {
            sprintf(dummy,sformat,intersection_x[i]);
            if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
            report+=QString("[ ")+QString(dummy);
            sprintf(dummy,sformat,intersection_y[i]);
            if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
            report+=QString(" | ")+QString(dummy)+QString(" ]\n");
        }
        if (nr_of_points_in_region<=0)
        {
        report+=tr("No intersection points inside selected region found.\n");
        }
    stufftext(report.toLocal8Bit().data());
    }
    else//create sets
    {
    n_set=nextset(src_g);
    setlength(src_g,n_set,nr_of_intersections);
        if (load_x==0)//x-values
        {
        memcpy(getcol(src_g,n_set,0),intersection_x,sizeof(double)*nr_of_intersections);
        }
        else//just an index
        {
            for (int i=0;i<nr_of_intersections;i++)
            g[src_g].p[n_set].data.ex[0][i]=i;
        }
    memcpy(getcol(src_g,n_set,1),intersection_y,sizeof(double)*nr_of_intersections);
        if (getsetlength(src_g,n_set)>0)
        {
            if (inhibit_set_legend==0)
            set_legend_string(src_g,n_set,n_legend.toLocal8Bit().data());
        SetsCreated(1,&src_g,&n_set,UNDO_COMPLETE);//undo-stuff
        }
    }
break;
case 1://Intersection angles
n_legend=tr("Intersection angles between ")+QString("G")+QString::number(src_g)+QString(".S")+QString::number(src_s[0])+tr(" and ")+QString("G")+QString::number(src_g)+QString(".S")+QString::number(src_s[1]);
//we already got the inersection points, now we need the angles as well
//the new intersection-function already calculates the angles
//intersection_a=new double[2+nr_of_intersections];
//get_intersection_angles(src_g,src_s[0],src_g,src_s[1],intersection_x,intersection_a,nr_of_intersections);
    if (load_x==2)//report only
    {
    report.clear();
    report+=n_legend+QString(":\n");
        for (int i=0;i<nr_of_intersections;i++)
        {
            sprintf(dummy,sformat,intersection_x[i]);
            if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
            report+=QString("[ ")+QString(dummy);
            sprintf(dummy,sformat,intersection_y[i]);
            if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
            report+=QString(" | ")+QString(dummy)+QString(" ] ")+tr("angle")+QString("= ");
            sprintf(dummy,sformat,intersection_a[i]);
            if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
            report+=QString(dummy)+QString(" rad | ");
            sprintf(dummy,sformat,intersection_a[i]*57.295779513082325);
            if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
            report+=QString(dummy)+QString(" degrees\n");
        }
    stufftext(report.toLocal8Bit().data());
    }
    else//create set
    {
    n_set=nextset(src_g);
    setlength(src_g,n_set,nr_of_intersections);
        if (load_x==0)
        {
        memcpy(getcol(src_g,n_set,0),intersection_x,sizeof(double)*nr_of_intersections);
        }
        else
        {
            for (int i=0;i<nr_of_intersections;i++)
            g[src_g].p[n_set].data.ex[0][i]=i;
        }
    memcpy(getcol(src_g,n_set,1),intersection_a,sizeof(double)*nr_of_intersections);
        if (getsetlength(src_g,n_set)>0)
        {
            if (inhibit_set_legend==0)
            set_legend_string(src_g,n_set,n_legend.toLocal8Bit().data());
        SetsCreated(1,&src_g,&n_set,UNDO_COMPLETE);
        }
    }
break;
case 2://Intersection points and -angles
    n_legend=tr("Intersection points between ")+QString("G")+QString::number(src_g)+QString(".S")+QString::number(src_s[0])+tr(" and ")+QString("G")+QString::number(src_g)+QString(".S")+QString::number(src_s[1]);
    if (load_x==2)//report only
    {
    report.clear();
    report+=n_legend+QString(":\n");
        for (int i=0;i<nr_of_intersections;i++)
        {
            sprintf(dummy,sformat,intersection_x[i]);
            if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
            report+=QString("[ ")+QString(dummy);
            sprintf(dummy,sformat,intersection_y[i]);
            if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
            report+=QString(" | ")+QString(dummy)+QString(" ] ")+tr("angle")+QString("= ");
            sprintf(dummy,sformat,intersection_a[i]);
            if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
            report+=QString(dummy)+QString(" rad | ");
            sprintf(dummy,sformat,intersection_a[i]*57.295779513082325);
            if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
            report+=QString(dummy)+QString(" degrees\n");
        }
        if (nr_of_points_in_region<=0)
        {
        report+=tr("No intersection points inside selected region found.\n");
        }
    stufftext(report.toLocal8Bit().data());
    }
    else//create sets
    {
    n_set=nextset(src_g);
    setlength(src_g,n_set,nr_of_intersections);
    (void)set_dataset_type(src_g,n_set,SET_XYZ);
        if (load_x==0)//x-values
        {
        memcpy(getcol(src_g,n_set,0),intersection_x,sizeof(double)*nr_of_intersections);
        }
        else//just an index
        {
            for (int i=0;i<nr_of_intersections;i++)
            g[src_g].p[n_set].data.ex[0][i]=i;
        }
    memcpy(getcol(src_g,n_set,1),intersection_y,sizeof(double)*nr_of_intersections);
    memcpy(getcol(src_g,n_set,2),intersection_a,sizeof(double)*nr_of_intersections);
        if (getsetlength(src_g,n_set)>0)
        {
            if (inhibit_set_legend==0)
            set_legend_string(src_g,n_set,n_legend.toLocal8Bit().data());
        SetsCreated(1,&src_g,&n_set,UNDO_COMPLETE);//undo-stuff
        }
    }
break;
case 3:
case 4:
    if (option==3)
    n_legend=tr("Area of set-polygon(s)");
    else//option==4
    n_legend=tr("Length of polygon-path of set(s)");

        if (load_x==2)//report only
        {
        report.clear();
        report+=n_legend+QString(":\n");
            for (int i=0;i<n_src_sets;i++)
            {
                sprintf(dummy,sformat,m1[i]);
                if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
                report+=QString("G")+QString::number(src_g)+QString(".S")+QString::number(src_s[i])+QString(": ")+QString(dummy)+QString("\n");
            }
        stufftext(report.toLocal8Bit().data());
        }
        else//create sets
        {
        n_set=nextset(src_g);
        setlength(src_g,n_set,n_src_sets);
            if (load_x==0)//source-id
            {
                for (int i=0;i<n_src_sets;i++)
                g[src_g].p[n_set].data.ex[0][i]=src_s[i];
            }
            else//just an index
            {
                for (int i=0;i<n_src_sets;i++)
                g[src_g].p[n_set].data.ex[0][i]=i;
            }
        memcpy(getcol(src_g,n_set,1),m1,sizeof(double)*n_src_sets);
            if (getsetlength(src_g,n_set)>0)
            {
                if (inhibit_set_legend==0)
                set_legend_string(src_g,n_set,n_legend.toLocal8Bit().data());
            SetsCreated(1,&src_g,&n_set,UNDO_COMPLETE);//undo-stuff
            }
        }

break;
}
mainWin->mainArea->completeRedraw();
finish_Apply_geomEval:
unset_wait_cursor();
if (intersection_x!=NULL) delete[] intersection_x;
if (intersection_y!=NULL) delete[] intersection_y;
if (intersection_a!=NULL) delete[] intersection_a;
if (m1!=NULL) delete[] m1;
if (m2!=NULL) delete[] m2;
if (m3!=NULL) delete[] m3;
if (src_s!=NULL) delete[] src_s;
XCFREE(rarray);
}

void frmGeometricEvaluation::doAccept(void)
{
ApplyError=false;
doApply();
if (ApplyError==false)
        doClose();
}

void frmGeometricEvaluation::doClose(void)
{
hide();
}

//padding_type=PROCESSING_INTERPOLATION
//padding_type=PROCESSING_ZERO_PADDING --> include zeros at start and at end
//padding_type=PROCESSING_FIRST_LAST_PADDING --> include the same values at the beginning and at the end
int create_padded_set(int n_gno,int & n_sno,int o_gno,int o_sno,int new_length,int padding_type)//creates new set (n_gno,n_sno) from old set (o_gno,o_sno), they should not be the same!; if n_sno==-1 --> create new set as next set nr
{
    int resno,setlen=getsetlength(o_gno,o_sno);
    int len_diff=new_length-setlen;
    int add_at_beginning=len_diff/2;
    int add_at_end=len_diff-add_at_beginning;
    double y0,y1;
    double xmin,xmax,ymin,ymax;
    double xspace=0.0;
    double * mesh = NULL;
    int error=RETURN_SUCCESS;
    int index;
    if (n_sno==-1)
    {
        n_sno = nextset(n_gno);
    }
    //interpolate or add zeros (get min_x and max_x first)
    resno = getsetminmax(o_gno,o_sno,&xmin,&xmax,&ymin,&ymax, FALSE);
    if (resno != RETURN_SUCCESS)
    {
        errmsg(QObject::tr("Error in computation of min and max").toLocal8Bit().constData());
        return RETURN_FAILURE;
    }
    bool mono=monospaced_v6(g[o_gno].p[o_sno].data.ex[0], setlen, &xspace);
    if (!mono && (padding_type==PROCESSING_ZERO_PADDING || padding_type==PROCESSING_FIRST_LAST_PADDING))
    {
        errmsg(QObject::tr("Error! Set not monospaced in x! Switching to interpolation!").toLocal8Bit().constData());
        return RETURN_FAILURE;
    }
    do_copyset(o_gno,o_sno,n_gno,n_sno);//allocate new set
    sortset(n_gno,n_sno,DATA_X,dataset_type(n_gno,n_sno));
    y0=g[o_gno].p[o_sno].data.ex[1][0];
    y1=g[o_gno].p[o_sno].data.ex[1][setlen-1];
    error=setlength(n_gno,n_sno,new_length);
    if (error==RETURN_FAILURE)
    {
        errmsg(QObject::tr("Error! Unable to allocate enough space for set-data!").toLocal8Bit().constData());
        return RETURN_FAILURE;
    }
    if (padding_type==PROCESSING_ZERO_PADDING && mono==TRUE)
    {
        //zero padding
        index=0;
        for (int i=0;i<add_at_beginning;i++)
        {
            g[n_gno].p[n_sno].data.ex[0][index]=xmin-(add_at_beginning-i)*xspace;
            g[n_gno].p[n_sno].data.ex[1][index++]=0.0;
        }
        for (int i=0;i<setlen;i++)
        {
            g[n_gno].p[n_sno].data.ex[0][index]=g[o_gno].p[o_sno].data.ex[0][i];
            g[n_gno].p[n_sno].data.ex[1][index++]=g[o_gno].p[o_sno].data.ex[1][i];
        }
        for (int i=0;i<add_at_end;i++)
        {
            g[n_gno].p[n_sno].data.ex[0][index]=xmax+(1+i)*xspace;
            g[n_gno].p[n_sno].data.ex[1][index++]=0.0;
        }
        //cout << "zero-padding" << endl;
        sortset(n_gno,n_sno,DATA_X,dataset_type(n_gno,n_sno));
    }
    else if (padding_type==PROCESSING_FIRST_LAST_PADDING && mono==TRUE)
    {
        //start/end-padding
        index=0;
        for (int i=0;i<add_at_beginning;i++)
        {
            g[n_gno].p[n_sno].data.ex[0][index]=xmin-(add_at_beginning-i)*xspace;
            g[n_gno].p[n_sno].data.ex[1][index++]=y0;
        }
        for (int i=0;i<setlen;i++)
        {
            g[n_gno].p[n_sno].data.ex[0][index]=g[o_gno].p[o_sno].data.ex[0][i];
            g[n_gno].p[n_sno].data.ex[1][index++]=g[o_gno].p[o_sno].data.ex[1][i];
        }
        for (int i=0;i<add_at_end;i++)
        {
            g[n_gno].p[n_sno].data.ex[0][index]=xmax+(1+i)*xspace;
            g[n_gno].p[n_sno].data.ex[1][index++]=y1;
        }
        sortset(n_gno,n_sno,DATA_X,dataset_type(n_gno,n_sno));
        //cout << "start/end-padding y=" << y0 << "-" << y1 << endl;
    }
    else
    {
        //interpolation
        mesh = allocate_mesh(xmin, xmax, new_length);
        resno = do_interp(o_gno,o_sno,n_gno,n_sno,mesh,new_length, 0, 0);
        if (resno != RETURN_SUCCESS)
        {
            errmsg(QObject::tr("Error in generation of interpolated set").toLocal8Bit().constData());
            return RETURN_FAILURE;
        }
        //cout << "interpolation" << endl;
    }
    return RETURN_SUCCESS;
}

int do_filter_on_one_set(int n_gno,int n_sno,int o_gno,int o_sno,int type,int realization,int restr_type,int restr_negate,int abs,int debug,char * formula,int point_extension,int oversampling,double ripple,int order1,int order2,double f1,double f2)
{
    if (is_set_active(o_gno,o_sno)==FALSE)//original set does not exist
    {
        sprintf(dummy,"[G%d.S%d]",o_gno,o_sno);
        QString ErrorText=QObject::tr("Error filtering set: Set does not exis! ");
        ErrorText+=QString(dummy);
        errwin(ErrorText.toLatin1().constData());
        return RETURN_FAILURE;
    }
    double factor=1.0;
    if (realization==FILTER_BRICKWALL && abs==1)
    {
        factor=1.0/sqrt(2.0);
    }

    /*char dummy[256];
    sprintf(dummy,"Filter: (%d,%d)-->(%d,%d), factor=%f",o_gno,o_sno,n_gno,n_sno,factor);
    qDebug() << dummy;*/
    int sav_orig_vis=g[o_gno].p[o_sno].hidden;
    int error, resno;/// error benutzen!
    char fstr[256];
    char * rarray;
    int setlen,color=g[o_gno].p[o_sno].linepen.color+1;
    if (color>=(int)number_of_colors()) color=1;//go back to black
    if (is_set_active(n_gno,n_sno)==TRUE) color=g[n_gno].p[n_sno].linepen.color;
    int n_setlen;
    double xspace;
    bool mono;
    int workset0,workset1,workset2,workset3,workset4;/// sets beschriften!
    workset0 = nextset(n_gno);
    do_copyset(o_gno, o_sno, n_gno, workset0);
    int padded_set=nextset(n_gno);
    do_copyset(o_gno, o_sno, n_gno, padded_set);
    int fft_original=nextset(n_gno);
    do_copyset(o_gno, o_sno, n_gno, fft_original);
    workset4=nextset(n_gno);//this is going to be the cut-off/filter-function
    do_copyset(o_gno, o_sno, n_gno, workset4);
    int filtered_data=nextset(n_gno);
    do_copyset(o_gno, o_sno, n_gno, filtered_data);
        setcomment(n_gno, workset0,"");
        setcomment(n_gno, padded_set,"");
        setcomment(n_gno, fft_original,"");
        setcomment(n_gno, workset4,"");
        setcomment(n_gno, filtered_data,"");
    if (inhibit_set_legend==0)
    {
    set_legend_string(n_gno, workset0,"");
    set_legend_string(n_gno, padded_set,"");
    set_legend_string(n_gno, fft_original,"");
    set_legend_string(n_gno, workset4,"");
    set_legend_string(n_gno, filtered_data,"");
    }
    double * mesh = NULL;
    double * real_data=NULL;
    double * imag_data=NULL;
    double * cutoff_function=NULL;
    double * cut_r=NULL;
    double * cut_i=NULL;
    struct komplex tmp_ko,tmp_ko2;
    double * cut_r2;
    double * cut_i2;
    int n_pts,nu;
    double amp_correction;
    //char * filter_name=new char[1024];
    //char * filter_dummy=new char[1024];
    QString filter_name,filter_dummy;
    //sprintf(filter_name,"Set G%d.S%d filtered with ",o_gno,o_sno);
    filter_name=QObject::tr("Set G")+QString::number(o_gno)+QObject::tr(".S")+QString::number(o_sno)+QObject::tr(" filtered with ");
    switch (type)
    {
    default:
    case FILTER_LOW_PASS:
    //sprintf(filter_dummy,"Low-Pass-Filter: CutOff = %g kHz, Order = %d, ",f1/1000.0,order1);
    filter_dummy=QObject::tr("Low-Pass-Filter: CutOff = ")+QString::number(f1/1000.0)+QObject::tr(" kHz, Order = ")+QString::number(order1)+QObject::tr(", ");
    break;
    case FILTER_BAND_PASS:
    //sprintf(filter_dummy,"Band-Pass-Filter: Pass = %g kHz - %g kHz, Order = %d / %d, ",f1/1000.0,f2/1000.0,order1,order2);
    filter_dummy=QObject::tr("Band-Pass-Filter: Pass = ")+QString::number(f1/1000.0)+QObject::tr(" kHz - ")+QString::number(f2/1000.0)+QObject::tr(" kHz, Order = ")+QString::number(order1)+QObject::tr(" / ")+QString::number(order2)+QObject::tr(", ");
    break;
    case FILTER_HIGH_PASS:
    //sprintf(filter_dummy,"High-Pass-Filter: CutOff = %g kHz, Order = %d, ",f1/1000.0,order1);
    filter_dummy=QObject::tr("High-Pass-Filter: CutOff = ")+QString::number(f1/1000.0)+QObject::tr(" kHz, Order = ")+QString::number(order1)+QObject::tr(", ");
    break;
    case FILTER_BAND_STOP:
    //sprintf(filter_dummy,"Band-Stop-Filter: Stop = %g kHz - %g kHz, Order = %d / %d, ",f1/1000.0,f2/1000.0,order1,order2);
    filter_dummy=QObject::tr("Band-Stop-Filter: Stop = ")+QString::number(f1/1000.0)+QObject::tr(" kHz - ")+QString::number(f2/1000.0)+QObject::tr(" kHz, Order = ")+QString::number(order1)+QObject::tr(" / ")+QString::number(order2)+QObject::tr(", ");
    break;
    }
    //strcat(filter_name,filter_dummy);
    filter_name+=filter_dummy;
    switch (realization)
    {
    default:
    case FILTER_BRICKWALL:
    //strcpy(filter_dummy,"Brickwall");
    filter_dummy=QObject::tr("Brickwall");
    break;
    case FILTER_BUTTERWORTH:
    //strcpy(filter_dummy,"Butterworth");
     filter_dummy=QObject::tr("Butterworth");
    break;
    case FILTER_BESSEL:
    //strcpy(filter_dummy,"Bessel");
    filter_dummy=QObject::tr("Bessel");
    break;
    case FILTER_CHEBYCHEV:
    //sprintf(filter_dummy,"Chebychev (Ripples = %g dB)",ripple);
    filter_dummy=QObject::tr("Chebychev (Ripples = ")+QString::number(ripple)+QObject::tr(" dB");
    break;
    case FILTER_GAUSSIAN:
        //sprintf(filter_name,"Set G%d.S%d filtered with ",o_gno,o_sno);
        filter_name=QObject::tr("Set G")+QString::number(o_gno)+QObject::tr(".S")+QString::number(o_sno)+QObject::tr(" filtered with ");
        switch (type)
        {
        default:
        case FILTER_LOW_PASS:
        //sprintf(filter_dummy,"Low-Pass-Filter: CutOff = %g kHz, Gaussian",f1/1000.0);
        filter_dummy=QObject::tr("Low-Pass-Filter: CutOff = ")+QString::number(f1/1000.0)+QObject::tr(" kHz, Gaussian");
        break;
        case FILTER_BAND_PASS:
        //sprintf(filter_dummy,"Band-Pass-Filter: Pass = %g kHz - %g kHz, Gaussian",f1/1000.0,f2/1000.0);
        filter_dummy=QObject::tr("Band-Pass-Filter: Pass = ")+QString::number(f1/1000.0)+QObject::tr(" - ")+QString::number(f2/1000.0)+QObject::tr(" kHz, Gaussian");
        break;
        case FILTER_HIGH_PASS:
        //sprintf(filter_dummy,"High-Pass-Filter: CutOff = %g kHz, Gaussian",f1/1000.0);
        filter_dummy=QObject::tr("High-Pass-Filter: CutOff = ")+QString::number(f1/1000.0)+QObject::tr(" kHz, Gaussian");
        break;
        case FILTER_BAND_STOP:
        //sprintf(filter_dummy,"Band-Stop-Filter: Stop = %g kHz - %g kHz, Gaussian",f1/1000.0,f2/1000.0);
        filter_dummy=QObject::tr("Band-Stop-Filter: Stop = ")+QString::number(f1/1000.0)+QObject::tr(" - ")+QString::number(f2/1000.0)+QObject::tr(" kHz, Gaussian");
        break;
        }
    break;
    }
    //strcat(filter_name,filter_dummy);
    //delete[] filter_dummy;
    filter_name+=filter_dummy;
    workset1=workset2=workset3=-1;
    error=0;
    /// keep for debug:
    /// -extended set with zero-padding and interpolation
    /// -fft of the set
    /// -filter-function (=transfer-function)
    /// -filtered data in frequency-space
    //first set to be created is n_sno which will be the set number for the result
    resno = get_restriction_array(o_gno,o_sno,restr_type, restr_negate, &rarray);//generate restriction array
    if (resno != RETURN_SUCCESS)
    {
        errmsg(QObject::tr("Error in evaluation of restriction").toLocal8Bit().constData());
        error=1;
        goto end_single_filter;
    }
    set_parser_setno(o_gno,o_sno);
    ///STEPS TO DO:
    //Calculate the real X-values (has to be time in seconds) and save them in new set (using the restriction) --> n_sno
    sprintf(fstr,"X=X*(%s)",formula);
    ReplaceDecimalSeparator(fstr);
    resno = do_compute(o_gno,o_sno,n_gno,workset0,rarray,fstr);
    //--> n_sno not interpolated yet! --> x-values will be needed at the end (but restriction has already been applied)
    if (resno != RETURN_SUCCESS)
    {
        errmsg(QObject::tr("Error in evaluation of x-axis conversion").toLocal8Bit().constData());
        error=1;
        goto end_single_filter;
    }
    setlen=getsetlength(n_gno,workset0);
    n_setlen=1<<((int)ceil(log((double)setlen)/log(2.0)));//get next power of two for interpolation
    if (point_extension==PROCESSING_INTERPOLATION)
        n_setlen*=(1<<oversampling);
    //interpolate or add points --> n_setlen will be new setlength (has to be power of 2 because of FFT)
    workset1 = nextset(n_gno);
    if (create_padded_set(n_gno,workset1,n_gno,workset0,n_setlen,point_extension)==RETURN_FAILURE)
    {
        errmsg(QObject::tr("Error! Unable to raise set length to power of 2!").toLocal8Bit().constData());
        error=1;
        goto end_single_filter;
    }
    //--> workset1 is a set with the points selected and the length a power of 2 (and possibly padded with extra points), x-axis is time in seconds
    workset2= nextset(n_gno);
    do_copyset(n_gno, workset1, n_gno, workset2);//workset2 is a copy of workset1 (workset1 is kept unchanged for debug reasons)
    workset3= nextset(n_gno);
    do_copyset(n_gno, workset1, n_gno, workset3);//workset3 has the original x-values (the y-values are lost and replaced by the results later)
    //workset4= nextset(n_gno);
    do_copyset(n_gno, workset1, n_gno, workset4);
    do_copyset(n_gno, workset1, n_gno, padded_set);
    n_pts=n_setlen;
    nu=(int)(ceil(log((double)n_setlen)/log(2.0)));
    real_data=new double[n_pts];
    imag_data=new double[n_pts];
    cutoff_function=new double[n_pts];
    cut_r=new double[n_pts];
    cut_i=new double[n_pts];
    //copy y-data into real part for fft
    memset(imag_data,0,sizeof(double)*n_pts);
    memcpy(real_data,g[n_gno].p[workset1].data.ex[1],sizeof(double)*n_pts);
    mono=monospaced_v6(g[n_gno].p[workset1].data.ex[0], n_pts, &xspace);
    if (!mono)
    {
        errmsg(QObject::tr("Error! Set not monospaced in x!").toLocal8Bit().constData());
        error=1;
        goto end_single_filter;
    }
    /*
    real_data ... ptr. to real part of data to be transformed
    imag_data ... ptr. to imag  "   "   "   "  "      "
    inv ..... Switch to flag normal or inverse transform
    n_pts ... Number of real data points
    nu ...... logarithm in base 2 of n_pts e.g. nu = 5 if n_pts = 32.
    int fft_v6(double *real_data, double *imag_data, int n_pts, int nu, int inv);
    */
    //do fft
    resno = fft_v6(real_data,imag_data,n_pts,nu,0);
    if (resno != RETURN_SUCCESS)
    {
        errmsg(QObject::tr("Error in forward fft").toLocal8Bit().constData());
        error=1;
        goto end_single_filter;
    }
    //generate cutoff function --> according to Filter-parameters set
    /* amplitude correction due to the zero padding etc. */
    amp_correction = 1.0/sqrt((double)n_pts);
    //we work on workset2 here (not workset1 or the original)
        for (int i=0;i<n_pts;i++)
        {
        g[n_gno].p[workset2].data.ex[0][i]=((double)i)/(xspace*n_pts);//x-values in frequency-space
        g[n_gno].p[workset2].data.ex[1][i]=amp_correction*hypot(real_data[i], imag_data[i]);
        }
    for (int i=n_pts/2;i<n_pts;i++)//the second half of the x-values has to have the other sign
        g[n_gno].p[workset2].data.ex[0][i]=-g[n_gno].p[workset2].data.ex[0][n_pts-i-1];
    do_copyset(n_gno, workset2, n_gno, fft_original);
    ///order=n*20dB/Dekade
    ///--> 1.order = decrease by factor 10 at frequency*10
    ///--> 2.order = decrease by factor 100 at frequency*10
    ///--> n-th Order= decrease by factor 10^n at frequency*10
    ///LowPass-cutoff-function:
    ///V(f) = 1.0/sqrt( 1.0 + (f/f_cut)^(2.0*n) )
    //We always generate a low pass at the beginning; we use the x-values of workset2 (which is the fft-version of the original set)
    switch (realization)
    {
    default:
    case FILTER_BRICKWALL:
        generateLowPass_Brickwall(g[n_gno].p[workset2].data.ex[0],n_pts,f1,cut_r,cut_i);
        break;
    case FILTER_BUTTERWORTH:
        generateLowPass_Butterworth(g[n_gno].p[workset2].data.ex[0],n_pts,f1,order1,cut_r,cut_i);
        break;
    case FILTER_BUTTERWORTH_SIMPLE:
        generateLowPass_Butterworth_simple(g[n_gno].p[workset2].data.ex[0],n_pts,f1,order1,cut_r,cut_i);
        break;
    case FILTER_BESSEL:
        generateLowPass_Bessel(g[n_gno].p[workset2].data.ex[0],n_pts,f1,order1,cut_r,cut_i);
        break;
    case FILTER_CHEBYCHEV:
        generateLowPass_Chebychev(g[n_gno].p[workset2].data.ex[0],n_pts,f1,order1,ripple,cut_r,cut_i);
        break;
    case FILTER_GAUSSIAN:
        //generateLowPass_Butterworth_simple(g[n_gno].p[workset2].data.ex[0],n_pts/2,f1,order1,cut_r,cut_i);
        generateLowPass_Gaussian(g[n_gno].p[workset2].data.ex[0],n_pts,f1,order1,cut_r,cut_i);
        //generateLowPass_Gaussian(double * f,int n,double f_cutoff,int order,double * cutoff_Function)
        break;
    }
    if (type==FILTER_BAND_PASS || type==FILTER_BAND_STOP)
    {//in this case we have to generate another cut-off-function for the second filter frequency
        //At first we always generate a band-pass-filter
        cut_r2=new double[n_pts];
        cut_i2=new double[n_pts];
        switch (realization)
        {
        case FILTER_BRICKWALL:
            generateLowPass_Brickwall(g[n_gno].p[workset2].data.ex[0],n_pts,f2,cut_r2,cut_i2);
            break;
        case FILTER_BUTTERWORTH:
            generateLowPass_Butterworth(g[n_gno].p[workset2].data.ex[0],n_pts,f2,order2,cut_r2,cut_i2);
            break;
        case FILTER_BUTTERWORTH_SIMPLE:
            generateLowPass_Butterworth_simple(g[n_gno].p[workset2].data.ex[0],n_pts,f2,order2,cut_r2,cut_i2);
            break;
        case FILTER_BESSEL:
            generateLowPass_Bessel(g[n_gno].p[workset2].data.ex[0],n_pts,f2,order2,cut_r2,cut_i2);
            break;
        case FILTER_CHEBYCHEV:
            generateLowPass_Chebychev(g[n_gno].p[workset2].data.ex[0],n_pts,f2,order2,ripple,cut_r2,cut_i2);
            break;
        case FILTER_GAUSSIAN:
            generateLowPass_Gaussian(g[n_gno].p[workset2].data.ex[0],n_pts,f2,order2,cut_r2,cut_i2);
            break;
        }
        for(int i=0;i<n_pts;i++)//generate the whole cut-off from two low-pass-filters --> this generates a band-pass
        {
            cut_r[i]=(1.0-cut_r[i])*cut_r2[i];
            cut_i[i]=(1.0-cut_i[i])*cut_i2[i];
        }
        delete[] cut_r2;
        delete[] cut_i2;
    }
    for(int i=0;i<n_pts;i++)//fft-spectra symetrical --> fill the second half
    {
        cutoff_function[i]=hypot(cut_r[i],cut_i[i]);
    }
    for(int i=0;i<n_pts;i++)//workset4 gets the x-values of workset2...
        g[n_gno].p[workset4].data.ex[0][i]=g[n_gno].p[workset2].data.ex[0][i];
    switch (type)//...and workset4 gets the cut-off-function as y-values
    {
    default:
    case FILTER_LOW_PASS:
    case FILTER_BAND_PASS:
        for(int i=0;i<n_pts;i++)
            g[n_gno].p[workset4].data.ex[1][i]=cutoff_function[i];
        break;
    case FILTER_HIGH_PASS:
    case FILTER_BAND_STOP://for high-pass or band-stop the cutoff has to be inverted here
        for(int i=0;i<n_pts;i++)
        {
            cut_r[i]=1.0-cut_r[i];
            cut_i[i]=1.0-cut_i[i];
            cutoff_function[i]=1.0-cutoff_function[i];
            g[n_gno].p[workset4].data.ex[1][i]=cutoff_function[i];
        }
        break;
    }
    //multiply fft-coefficients by cutoff function
    if (abs==1)
    {
        for (int i=0;i<n_pts;i++)
        {
            real_data[i]*=amp_correction*cutoff_function[i]*factor;
            imag_data[i]*=amp_correction*cutoff_function[i]*factor;
        }
    }
    else
    {
        for (int i=0;i<n_pts;i++)
        {
            tmp_ko.real=real_data[i];
            tmp_ko.imag=imag_data[i];
            tmp_ko2.real=cut_r[i];
            tmp_ko2.imag=cut_i[i];
            tmp_ko=mult_komplex(tmp_ko,tmp_ko2);
            real_data[i]=amp_correction*tmp_ko.real*factor;
            imag_data[i]=amp_correction*tmp_ko.imag*factor;
        }
    }
    do_copyset(n_gno, workset4, n_gno, filtered_data);
    for (int i=0;i<n_pts;i++)
    {
        g[n_gno].p[filtered_data].data.ex[1][i]=hypot(real_data[i],imag_data[i]);//real_data of filtered coefficients
    }
    //do inverse-fft
    resno = fft_v6(real_data,imag_data,n_pts,nu,1);
    if (resno != RETURN_SUCCESS)
    {
        errmsg(QObject::tr("Error in forward fft").toLocal8Bit().constData());
        error=1;
        goto end_single_filter;
    }
    //copy result to workset3
    for (int i=0;i<n_pts;i++)
    {
        g[n_gno].p[workset3].data.ex[1][i]=amp_correction*real_data[i];//-->workset3 now has the y-values of the back-transformed data and the extended x-values (in a power of 2)
    }
    //interpolate result to original X-values
    //delete worksets if necessary
    do_copyset(n_gno, workset2, n_gno, workset1);//save workset2 to workset1

    sprintf(fstr,"X=X/(%s)",formula);
    ReplaceDecimalSeparator(fstr);
    set_parser_setno(n_gno,workset3);
    resno = do_compute(n_gno, workset3, n_gno, workset2, NULL, fstr);//transform X-axis back to original scale --> resulting data present in workset2 but probably to many points

    xfree(mesh);
    mesh = getcol(o_gno, o_sno, DATA_X);//get original x-values
    resno = do_interp(n_gno, workset2, n_gno, workset0, mesh, setlen, 0, 0);//interpolate back to original set axis and store data in target-set
    if (resno != RETURN_SUCCESS)
    {
        errmsg(QObject::tr("Error in generation of interpolated set").toLocal8Bit().constData());
        error=1;
        goto end_single_filter;
    }
end_single_filter:
    killsetdata(n_gno,workset2);
    killsetdata(n_gno,workset3);
    killsetdata(n_gno,workset1);
    if (!debug)
    {
        killsetdata(n_gno,padded_set);
        killsetdata(n_gno,fft_original);
        killsetdata(n_gno,filtered_data);
        killsetdata(n_gno,workset4);
    }
    else//debug
    {
        //sprintf(dummy,"%d %d %d %d",padded_set,fft_original,workset4,filtered_data);
        //qDebug(dummy);
        strcpy(fstr,QObject::tr("Set restricted, extended or interpolated to power of 2").toLocal8Bit().constData());
        if (inhibit_set_legend==0)
        set_legend_string(n_gno,padded_set,fstr);
        setcomment(n_gno,padded_set,fstr);
        strcpy(fstr,QObject::tr("Fourier-transformation of original set").toLocal8Bit().constData());
        if (inhibit_set_legend==0)
        set_legend_string(n_gno,fft_original,fstr);
        setcomment(n_gno,fft_original,fstr);
        strcpy(fstr,QObject::tr("Cutoff/filter-function").toLocal8Bit().constData());
        if (inhibit_set_legend==0)
        set_legend_string(n_gno,workset4,fstr);
        setcomment(n_gno,workset4,fstr);
        strcpy(fstr,QObject::tr("filtered data vs. frequency").toLocal8Bit().constData());
        if (inhibit_set_legend==0)
        set_legend_string(n_gno,filtered_data,fstr);
        setcomment(n_gno,filtered_data,fstr);
    }
    copysetdata(n_gno, workset0, n_gno, n_sno);//copy data to destination
    setcomment(n_gno, n_sno, filter_name.toLocal8Bit().constData());
    g[o_gno].p[o_sno].hidden=sav_orig_vis;
//qDebug() << "filter_name=" << filter_name;
    //delete[] filter_name;
    if (workset0!=n_sno)
        killset(n_gno,workset0);
    XCFREE(rarray);
    if (real_data!=NULL)
    {
        delete[] real_data;
        delete[] imag_data;
        delete[] cutoff_function;
        delete[] cut_r;
        delete[] cut_i;
    }
    if (error==1)
    {
        return RETURN_FAILURE;
    }
    if (o_gno!=n_gno || o_sno!=n_sno) g[n_gno].p[n_sno].linepen.color=color;
    //appendTextToLegendString(n_gno,n_sno,QObject::tr("(filtered)"));
    return RETURN_SUCCESS;
}

int generate_x_mesh_from_formula(int gno,int sno,double start,double stop,int npts,char * formula,int type)
{
    int res;
    grarr * t;
    t = get_parser_arr_by_name(dollar_t);
    if (t == NULL)
    {
        t = define_parser_arr(dollar_t);
        if (t == NULL)
        {
            errmsg(QObject::tr("Internal error").toLocal8Bit().constData());
            return RETURN_FAILURE;
        }
    }
    if (t->length != 0)
    {
        xfree(t->data);
        t->length = 0;
    }
    t->data = allocate_mesh(start, stop, npts);
    if (t->data == NULL)
    {
        errmsg(QObject::tr("Internal error").toLocal8Bit().constData());
        return RETURN_FAILURE;
    }
    t->length = npts;
    set_dataset_type(gno, sno, type);
    set_set_hidden(gno, sno, FALSE);
    if (setlength(gno, sno, npts) != RETURN_SUCCESS)
    {
        killset(gno, sno);
        XCFREE(t->data);
        t->length = 0;
        errmsg(QObject::tr("Internal error").toLocal8Bit().constData());
        return RETURN_FAILURE;
    }
    set_parser_setno(gno, sno);
    char buf[32], *expr;
    /* preparing the expression */
    sprintf(buf, "GRAPH[%d].SET[%d].%s = ", gno, sno, dataset_colname(0));
    expr = copy_string(NULL, buf);
    expr = concat_strings(expr, formula);
    /* evaluate the expression */
    res = scanner(expr);
    xfree(expr);
    if (res != RETURN_SUCCESS)
    {
        killset(gno, sno);
        XCFREE(t->data);
        t->length = 0;
        errmsg(QObject::tr("Internal error").toLocal8Bit().constData());
        return RETURN_FAILURE;
    }
    XCFREE(t->data);
    t->length = 0;
    return RETURN_SUCCESS;
}

char * extract_single_parameter(char * command,char * parameter)//takes the command an extracts everything until the next separator is reached (like ; or }); returns the position of the separtor or the '\0'; parameter is copied in the parameter-array
{
int braket_counter=0;
int len=strlen(command);
int i;
for (i=0;i<len;i++)
{
    if (command[i]=='(') braket_counter++;
    else if (command[i]==')') braket_counter--;
    else if ((command[i]==',' || command[i]==';' || command[i]=='{' || command[i]=='}') && (braket_counter==0))
    {
    strncpy(parameter,command,i);
    parameter[i]='\0';
    break;
    }
}
if (i==len) parameter[0]='\0';
return command+i;
}

//comparator={0=none},{1='='},{2= '!=' = '<>'},{3='>'},{4='<'},{5='>='},{6='<='},{-1=ERROR}
void split_comparison(char * comparison, char * partA, char * partB, int & comparator,int & posA,int & posB)
{
int br_counter[3]={0,0,0};
int len=strlen(comparison);
int start_comp=-1,stop_comp=-1;
posA=posB=-1;
    for (int i=0;i<len;i++)
    {
        if (posA==-1 && !isspace(comparison[i])) posA=i;
        switch (comparison[i])
        {
        case '(':
        br_counter[0]++;
        break;
        case ')':
        br_counter[0]--;
        break;
        case '[':
        br_counter[1]++;
        break;
        case ']':
        br_counter[1]--;
        break;
        case '{':
        br_counter[2]++;
        break;
        case '}':
        br_counter[2]--;
        break;
        case '!':
        case '=':
        case '>':
        case '<':
            if (br_counter[0]==0 && br_counter[1]==0 && br_counter[2]==0)
            {
                if (start_comp==-1) start_comp=i;
                else if (stop_comp==-1) stop_comp=i;
            }
        break;
        default:
            if (posA==-1 && !isspace(comparison[i])) posA=i;
        ;//do nothing, just go on
        break;
        }
    }
strcpy(partA,comparison);
if (start_comp==-1 && stop_comp==-1)//no comparison - just a number
{
comparator=0;
posB=-1;
partB[0]='\0';
}
else if (start_comp>=0 && stop_comp==-1)//just one character as comparator
{
partA[start_comp]='\0';
strcpy(partB,comparison+start_comp+1);
posB=start_comp+1;
    switch (comparison[start_comp])
    {
    case '=':
    comparator=1;
    break;
    case '>':
    comparator=3;
    break;
    case '<':
    comparator=4;
    break;
    default:
    comparator=-1;
    break;
    }
}
else
{
partA[start_comp]='\0';
strcpy(partB,comparison+stop_comp+1);
posB=stop_comp+1;
    switch (comparison[start_comp])
    {
    case '!':
        if (comparison[stop_comp]=='=')
        {
        comparator=2;
        }
        else
        {
        comparator=-1;
        }
    break;
    case '>':
        if (comparison[stop_comp]=='=')
        {
        comparator=5;
        }
        else
        {
        comparator=-1;
        }
    break;
    case '<':
        if (comparison[stop_comp]=='=')
        {
        comparator=6;
        }
        else if (comparison[stop_comp]=='>')
        {
        comparator=2;
        }
        else
        {
        comparator=-1;
        }
    break;
    default:
    comparator=-1;
    break;
    }
}

}

//returns 1 if compl_com starts with "#if[] " and returns 0 otherwise, returns -1 if an error occured
//evaluates [] to be true or false or a number (0=false, 1=true) and returns 1 or 0 in result
//if command starts with "#if[] " real_com will have the actual command after the if-statement, otherwise it will be unchanged
int startIfStatement(char * compl_com,int & result,char * real_com)
{
QList<int> comp_pos;
QStringList comp_text;
int comparator;
int ret=split_if_statement(compl_com,comp_pos,comp_text,comparator);
double vA,vB;
char * partA,* partB;
int ret2;
partA=partB=NULL;
result=-1;
real_com[0]='\0';
//qDebug() << "startIfStatement:" << compl_com << "Parts:" << comp_pos.length();
//for (int i=0;i<comp_pos.length();i++) qDebug() << comp_pos.at(i) << "-->" << comp_text.at(i);
if (ret==RETURN_FAILURE || comp_pos.length()<3 || comp_text.length()<3) return -1;
else if (ret==RETURN_SUCCESS && comparator==-1) return 0;
//comparator={0=none},{1='='},{2= '!=' = '<>'},{3='>'},{4='<'},{5='>='},{6='<='},{-1=ERROR}
if (comparator==0)//just a number
{
partA=new char[2+2*comp_text.at(0).length()];
strcpy(partA,comp_text.at(0).toLocal8Bit().constData());
ret2=std_evalexpr(partA,&vA);

    if (vA==0) result=0;
    else result=1;

}
else if (comparator>0)//a real comparison
{
partA=new char[2+2*comp_text.at(0).length()];
strcpy(partA,comp_text.at(0).toLocal8Bit().constData());
ret2=std_evalexpr(partA,&vA);

partB=new char[2+2*comp_text.at(1).length()];
strcpy(partB,comp_text.at(1).toLocal8Bit().constData());
ret2=std_evalexpr(partB,&vB);

    switch (comparator)
    {
    default:
    case 1://'='
    result=(vA==vB?1:0);
    break;
    case 2://'!=' or '<>'
    result=(vA!=vB?1:0);
    break;
    case 3://'>'
    result=(vA>vB?1:0);
    break;
    case 4://'<'
    result=(vA<vB?1:0);
    break;
    case 5://'>='
    result=(vA>=vB?1:0);
    break;
    case 6://'<='
    result=(vA<=vB?1:0);
    break;
    }

}
strcpy(real_com,comp_text.at(2).toLocal8Bit().constData());
    if (partA!=NULL) delete[] partA;
    if (partB!=NULL) delete[] partB;
return 1;
}

int split_if_statement(char * compl_com,QList<int> & comp_pos,QStringList & comp_text,int & comparator)//comp_.. ={if_comparison1, if_comparison2, statement after #if[]}
{//returns RETURN_SUCCESS if splitting is ok | RETURN_FAILURE if it is no #if[]-statement or an error
char * start=NULL,*comp_start=NULL,*comp_end=NULL;
char * to_compare=NULL;
int len=0,counter=0,status=0,size=0;//,ret=-1;
int start_command_index=-1;
start=compl_com;
comparator=-1;
comp_pos.clear();
comp_text.clear();
while (start[0]!='\0' && isspace(start[0])) start++;//looking for first character that is not a space
char if_cmp[5];
for (int i=0;i<4;i++)
if_cmp[i]=toupper(start[i]);//convert first characters to upper case for comparison
if_cmp[4]='\0';
//qDebug() << "if_cmp=" << if_cmp;
if (strcmp(if_cmp,"#IF[")!=0) return RETURN_SUCCESS;//no "#if " --> return unchanged
len=strlen(start);
char * real_com=new char[len+2];
counter=0;
status=0;
for (int i=0;i<len;i++)
{
    if (status==0)//we look for the comparison
    {
        if (start[i]=='[')
        {
        counter++;
            if (counter==1)
            {
            comp_start=start+i+1;
            }
        }
        else if (start[i]==']')
        {
        counter--;
            if (counter==0)
            {
            comp_end=start+i-1;
            status=1;
            }
        }
    }
    else//we look for the command after the "#if[]"
    {
        if (!isspace(start[i]))
        {
        strcpy(real_com,start+i);
        start_command_index=i+(start-compl_com);
        status=2;
        break;
        }
    }
}
//qDebug() << "Status=" << status;
if (status>0)//we found #if[]
{
size=comp_end-comp_start+2;
to_compare=new char[size+2];
strncpy(to_compare,comp_start,size-1);
to_compare[size-1]='\0';
int len2=strlen(to_compare);
char * partA=new char[len2+2];
char * partB=new char[len2+2];
int posA,posB;
posA=posB=-1;
//comparator={0=none},{1='='},{2= '!=' = '<>'},{3='>'},{4='<'},{5='>='},{6='<='},{-1=ERROR}
split_comparison(to_compare,partA,partB,comparator,posA,posB);
//qDebug() << "to_compare=" << to_compare << "posA=" << posA << "posB=" << posB << "comparator=" << comparator;
    if (comparator==-1)
    {
        delete[] partA;
        delete[] partB;
        return RETURN_FAILURE;//something is wrong
    }
    else
    {
        comp_text << QString(partA) << QString(partB);
        //comp_pos << comp_start-compl_com << (start_command_index<0?-1:start_command_index);
        comp_pos << posA+(comp_start-compl_com) << posB+(comp_start-compl_com);
    }
delete[] partA;
delete[] partB;
}

if (status==0)//no if found --> this means the commands begins with "#if[", but the closing "]" is missing
{
return RETURN_FAILURE;
}
else if (status==1)
{
    comp_text << QString("");
    comp_pos << -1;
}
else
{
    comp_text << QString(real_com);
    comp_pos << start_command_index;
//qDebug() << "We found everything: Compare:" << to_compare << "Command:" << real_com;
//ret=std_evalexpr(partA,&vA);
/*if (ret==RETURN_FAILURE || comparator==-1)
{

return -1;//error --> undefined
}

if (comparator==0)//no comparator
{
;//result=(vA==0?0:1);
}
else//there is one
{
ret=std_evalexpr(partB,&vB);
        if (ret==RETURN_FAILURE)
        {
        delete[] partA;
        delete[] partB;
        return -1;//error --> undefined
        }*/
    /*switch (comparator)
    {
    default:
    case 1://'='
    result=(vA==vB?1:0);
    break;
    case 2://'!=' or '<>'
    result=(vA!=vB?1:0);
    break;
    case 3://'>'
    result=(vA>vB?1:0);
    break;
    case 4://'<'
    result=(vA<vB?1:0);
    break;
    case 5://'>='
    result=(vA>=vB?1:0);
    break;
    case 6://'<='
    result=(vA<=vB?1:0);
    break;
    }
}*/
/*delete[] partA;
delete[] partB;*/
}
return RETURN_SUCCESS;
}

int containsSpecialCommand(char * com,char ** parameters)
{
    char ts2[MAX_STRING_LENGTH];
    char operation[MAX_STRING_LENGTH],operand[MAX_STRING_LENGTH];
    static char para[MAX_STRING_LENGTH];
    int counter=0;
    while (com[counter]!='\0' && isspace(com[counter])) counter++;
//qDebug() << "TestForSpecial=" << com;
    if (com[counter]=='#' && toupper(com[counter+1])=='I' && toupper(com[counter+2])=='F' && com[counter+3]=='[') return SPECIAL_IF;
    strncpy(ts2,com+counter,16);
    ts2[16]='\0';
    if (strcmp(ts2,"#QTGRACE_SPECIAL") != 0) return SPECIAL_NONE;//no special command
    *parameters=para;
//qDebug() << "Contains Special Command? #" << com << "#";
    sscanf(com,"%s %s %s",operation,operand,para);
//qDebug() << "#"<< operation << "#" << operand << "#" << para << "#";
    if ( strcmp(operand,"FILTER_SET") == 0 )
        return SPECIAL_FILTER;
    else if ( strcmp(operand,"REGRESSION") == 0 )
        return SPECIAL_REGRESSION;
    else if ( strcmp(operand,"REMEMBER") == 0 )
        return SPECIAL_REMEMBER;
    else if ( strcmp(operand,"ADD") == 0 )
        return SPECIAL_ADD;
    else if ( strcmp(operand,"MINUS") == 0 )
        return SPECIAL_MINUS;
    else if ( strcmp(operand,"DIVIDE") == 0 )
        return SPECIAL_DIVIDE;
    else if ( strcmp(operand,"MULTIPLY") == 0 )
        return SPECIAL_MULTIPLY;
    else if ( strcmp(operand,"USE") == 0 )
        return SPECIAL_USE;
    else if ( strcmp(operand,"EXTRACT") == 0 )
        return SPECIAL_EXTRACT;
    else if ( strcmp(operand,"FORMULA") == 0 )
        return SPECIAL_FORMULA;
    else if ( strcmp(operand,"APPEND") == 0 )
        return SPECIAL_APPEND;
    else if ( strcmp(operand,"FIT2D") == 0 )
        return SPECIAL_FIT2D;
    else
        return SPECIAL_NONE;
}

int ParseExtractCommand(char * com,char * arg)
{
int brakets,endpos;
arg[0]=arg[1]=arg[2]='\0';
//qDebug() << "ParseExtractCommand: com=#" << com << "#";
    if (strncmp(com,"MEDIAN",6)==0)
    {
        brakets=1;
        endpos=strlen(com)-1;
        for (unsigned int i=7;i<strlen(com);i++)
        {
        if (com[i]=='(') brakets++;
        else if (com[i]==')') brakets--;
        if (brakets==0) endpos=i;
        }
        get_text_from_to(com,6,endpos,arg);
        /*arg[0]=toupper(com[7]);
        if (isdigit(com[8]))
        {
        arg[1]=com[8];
        }*/
    return FEATURE_Y_MEDIAN;//median (also used for 9 and other Y-values Y1-Y4)
    }
    else if (strncmp(com,"FREQUENCY",9)==0)
    {
    return FEATURE_FREQUENCY;//no arguments
    }
    else if (strncmp(com,"PERIOD",6)==0)
    {
    return FEATURE_PERIOD;//no arguments
    }
    else if (strncmp(com,"ZERO_CROSSING",13)==0)
    {
    return FEATURE_ZERO_CROSSING;//no arguments
    }
    else if (strncmp(com,"RISE_TIME",9)==0)
    {
    return FEATURE_RISE_TIME;//no arguments
    }
    else if (strncmp(com,"FALL_TIME",9)==0)
    {
    return FEATURE_FALL_TIME;//no arguments
    }
    else if (strncmp(com,"SLOPE",5)==0)
    {
    return FEATURE_SLOPE;//no arguments
    }
    else if (strncmp(com,"Y_INTERCEPTION",14)==0)
    {
    return FEATURE_Y_INTERCEPT;//no arguments
    }
    else if (strncmp(com,"SET_LENGTH",10)==0)
    {
    return FEATURE_SET_LENGTH;//no arguments
    }
    else if (strncmp(com,"HALF_MAX_WIDTH",14)==0)
    {
    return FEATURE_HALF_MAX_WIDTH;//no arguments
    }
    else if (strncmp(com,"BARYCENTER_X",12)==0)
    {
    return FEATURE_BARYCENTER_X;//no arguments
    }
    else if (strncmp(com,"BARYCENTER_Y",12)==0)
    {
    return FEATURE_BARYCENTER_Y;//no arguments
    }
    else if (strncmp(com,"Y_VALUE_CROSSING",16)==0)
    {
        strcpy(arg,com+17);
        for (int i=strlen(arg)-1;i>=0;i++)
        {
            if (arg[i]==')')
            {
            arg[i]='\0';
            break;
            }
        }
    return FEATURE_VALUE_CROSSING;
    }
    else if (strncmp(com,"X_VALUE_CROSSING",16)==0)
    {
        strcpy(arg,com+17);
        for (int i=strlen(arg)-1;i>=0;i++)
        {
            if (arg[i]==')')
            {
            arg[i]='\0';
            break;
            }
        }
    return FEATURE_VALUE_CROSSING2;
    }
return -1;
}

int ParseSpecialFormula(char * com,char * arg)
{
    (void)com;
    (void)arg;
return 0;
}

void ParseFit2D(char * com,int & type,int & gno,int & sno,int & t_set,double & x0,double & y0,double & r1,double & r2,double & angle,double & phi0,double & phi1,int & n_phi,int & region,int & reg_inv)
{
sscanf(com,"{%d",&type);
if (type==0)//circle
{
sscanf(com,"{%d;%d;%d;%d;%lf;%lf;%lf;%d;%d;%lf;%lf;%d}",&type,&gno,&sno,&t_set,&x0,&y0,&r1,&region,&reg_inv,&phi0,&phi1,&n_phi);
//#QTGRACE_SPECIAL FIT2D 0 | Graph-ID | Set-ID | target-set | x0 | y0 | r | restriction | invert restriction | start_angle | stop_angle | nr_of_points
}
else//ellipse
{
sscanf(com,"{%d;%d;%d;%d;%lf;%lf;%lf;%lf;%lf;%d;%d;%lf;%lf;%d}",&type,&gno,&sno,&t_set,&x0,&y0,&r1,&r2,&angle,&region,&reg_inv,&phi0,&phi1,&n_phi);
//#QTGRACE_SPECIAL FIT2D 1 | Graph-ID | Set-ID | target-set | x0 | y0 | a | b | alpha | restriction | invert | start_angle | stop_angle | nr_of_points
}
//parameter_vals1[4]=sscanf(parameters,"%d;%d;%d;%d;%lf;%lf;%lf;%lf;%lf;%lf;%lf",parameter_vals1+0,parameter_vals1+1,parameter_vals1+2,parameter_vals1+3,parameter_vals2+0,parameter_vals2+1,parameter_vals2+2,parameter_vals2+3,parameter_vals2+4,parameter_vals2+5,parameter_vals2+6);
}

QString WriteFit2DString(int type,int gno,int sno,int t_set,double x0,double y0,double r1,double r2,double angle,double phi0,double phi1,int n_phi,int region,int reg_inv)
{
QString command=QString("#QTGRACE_SPECIAL FIT2D {");
char buffer[128];
if (type==0)//circle
{
command+=QString("0;")+QString::number(gno)+QString(";")+QString::number(sno)+QString(";")+QString::number(t_set)+QString(";");
sprintf(buffer,sformat,x0);
command+=QString(buffer)+QString(";");
sprintf(buffer,sformat,y0);
command+=QString(buffer)+QString(";");
sprintf(buffer,sformat,r1);
command+=QString(buffer)+QString(";");
command+=QString::number(region)+QString(";")+QString::number(reg_inv)+QString(";");
sprintf(buffer,sformat,phi0);
command+=QString(buffer)+QString(";");
sprintf(buffer,sformat,phi1);
command+=QString(buffer)+QString(";")+QString::number(n_phi);
//#QTGRACE_SPECIAL FIT2D 0 | Graph-ID | Set-ID | target-set | x0 | y0 | r | restriction | invert restriction | start_angle | stop_angle | nr_of_points
}
else//ellipse
{
command+=QString("1;")+QString::number(gno)+QString(";")+QString::number(sno)+QString(";")+QString::number(t_set)+QString(";");
sprintf(buffer,sformat,x0);
command+=QString(buffer)+QString(";");
sprintf(buffer,sformat,y0);
command+=QString(buffer)+QString(";");
sprintf(buffer,sformat,r1);
command+=QString(buffer)+QString(";");
sprintf(buffer,sformat,r2);
command+=QString(buffer)+QString(";");
sprintf(buffer,sformat,angle);
command+=QString(buffer)+QString(";");
command+=QString::number(region)+QString(";")+QString::number(reg_inv)+QString(";");
sprintf(buffer,sformat,phi0);
command+=QString(buffer)+QString(";");
sprintf(buffer,sformat,phi1);
command+=QString(buffer)+QString(";")+QString::number(n_phi);
//#QTGRACE_SPECIAL FIT2D 1 | Graph-ID | Set-ID | target-set | x0 | y0 | a | b | alpha | restriction | invert | start_angle | stop_angle | nr_of_points
}
command+=QString("}");
return command;
}

void ParseRegression(char * com,int & n_sets,int ** gnos,int ** snos,int & n_n_sets,int ** n_gnos,int ** n_snos,int & ideg,int & iresid,int & rno,int & invr,double & start,double & stop,int & points,int & rx,char * formula)
{//parses the commands after '#QTGRACE_SPECIAL REGRESSION '
    int index,i,j;
    //int counter;
    int len=strlen(com);
    //counter=0;
    //cout << "Parsing regression-command=#" << com << "#" << endl;
    double tmp_answer;
    char parameter[128];
    char * next_pos=extract_single_parameter(com,parameter);
    next_pos++;//we are now after the ','
    int retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) n_sets=(int)tmp_answer;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) n_n_sets=(int)tmp_answer;
    next_pos++;
    /// sscanf(com,"%d,%d",&n_sets,&n_n_sets);
//cout << "Einlesen: old_sets=" << n_sets << " new_sets=" << n_n_sets << endl;
    index=-1;
    (*gnos)=new int[1+n_sets];
    (*snos)=new int[1+n_sets];
    (*n_gnos)=new int[1+n_n_sets];
    (*n_snos)=new int[1+n_n_sets];
    for (i=0;i<len;i++)
    {
        if (com[i]=='{')
        {
            index=i+1;
            break;
        }
    }
    for (i=0;i<n_sets;i++)
    {
    next_pos=com+index;
        //cout << "A: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*gnos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "B: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*snos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "C: original: next_pos=" << next_pos << endl;
        //cout << "original: com-index=" << com+index << endl;
        /// sscanf(com+index,"%d,%d",(*gnos)+i,(*snos)+i);
        index=next_pos-com-1;
        for (j=0;j<len;j++)
        {
            if (com[j+index]==';' || com[j+index]=='}')
            {
                index+=j+1;
                break;
            }
        }
    }
    index++;
    next_pos=com+index;
    for (i=0;i<n_n_sets;i++)
    {
    next_pos=com+index;
        //cout << "A: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*n_gnos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "B: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*n_snos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "C: original: next_pos=" << next_pos << endl;
        //cout << "original: com-index=" << com+index << endl;
        //cout << "new: com-index=" << com+index << endl;
        /// sscanf(com+index,"%d,%d",(*n_gnos)+i,(*n_snos)+i);
        index=next_pos-com-1;
        for (j=0;j<len;j++)
        {
            if (com[j+index]==';' || com[j+index]=='}')
            {
                index+=j+1;
                break;
            }
        }
    }
    if (n_n_sets==0) index++;
    index++;
    next_pos=com+index;
/*cout << "source sets:" << endl;
for (i=0;i<n_sets;i++)
{
cout << "G" << (*gnos)[i] << ".S" << (*snos)[i] << endl;
}
cout << "target sets:" << endl;
for (i=0;i<n_n_sets;i++)
{
cout << "G" << (*n_gnos)[i] << ".S" << (*n_snos)[i] << endl;
}
cout << "Parameters:" << endl;*/
    //cout << "rest: com-index=" << com+index << endl;
    /// sscanf(com+index,"%d;%d;%d;%d;%d;%lf;%lf;%s",&ideg,&rno,&invr,&points,&rx,&start,&stop,formula);
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) ideg=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) rno=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) invr=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) points=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) rx=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) start=tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) stop=tmp_answer;
    next_pos++;
    sscanf(next_pos,"%s",formula);
/*cout << "ideg=" << ideg << endl;
cout << "rno=" << rno << endl;
cout << "invr=" << invr << endl;
cout << "points=" << points << endl;
cout << "rx=" << rx << endl;
cout << "start=" << start << endl;
cout << "stop=" << stop << endl;*/
    switch (rx)
    {
    case 0://fitted values
        iresid = 0;
        break;
    case 1://residuals
        iresid = 1;
        break;
    case 2://function
        iresid = 0;
        break;
    case 3://no new set for regression
        iresid = 2;
        break;
    }
    formula[strlen(formula)-1]='\0';
//cout << "formula=" << formula << endl;
}

void ParseFilterCommand(char * com,int & o_n_sets,int ** o_gnos,int ** o_snos,int & n_sets,int ** gnos,int ** snos,int & type,int & realization,double * limits,int * orders,char * x_formula,double & ripple,int & absolute,int & debug,int & point_extension,int & oversampling,int & rno,int & invr)
{//parses the commands after '#QTGRACE_SPECIAL FILTER_SET '
    int index,i,j;
    //int counter;
    int len=strlen(com);
    //counter=0;
    //cout << "Parsing filter-command=#" << com << "#" << endl;
    /// sscanf(com,"%d,%d",&o_n_sets,&n_sets);
n_sets=o_n_sets=-1;
    double tmp_answer;
    char parameter[128];
    char * next_pos=extract_single_parameter(com,parameter);
    next_pos++;//we are now after the ','

    int retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) o_n_sets=(int)tmp_answer;

//cout << "after first extract: com=#" << next_pos << "# parameter=#" << parameter << "# o_n_sets=" << o_n_sets << endl;

    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) n_sets=(int)tmp_answer;

//cout << "after second extract: com=#" << next_pos << "# parameter=#" << parameter << "# n_sets=" << n_sets << endl;

    index=-1;
    (*o_gnos)=new int[1+o_n_sets];
    (*o_snos)=new int[1+o_n_sets];
    (*gnos)=new int[1+n_sets];
    (*snos)=new int[1+n_sets];
    for (i=0;i<len;i++)
    {
        if (com[i]=='{')
        {
            index=i+1;
            break;
        }
    }
    for (i=0;i<o_n_sets;i++)
    {
    next_pos=com+index;
        //cout << "A: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*o_gnos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "B: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*o_snos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "C: original: next_pos=" << next_pos << endl;
        /// sscanf(com+index,"%d,%d",(*o_gnos)+i,(*o_snos)+i);
        index=next_pos-com-1;
        for (j=0;j<len;j++)
        {
            if (com[j+index]==';' || com[j+index]=='}')
            {
                index+=j+1;
                break;
            }
        }
    }
    index++;
    for (i=0;i<n_sets;i++)
    {
    next_pos=com+index;
        //cout << "A: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*gnos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "B: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*snos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "C: original: next_pos=" << next_pos << endl;
        //cout << "new: com-index=" << com+index << endl;
        /// sscanf(com+index,"%d,%d",(*gnos)+i,(*snos)+i);
        index=next_pos-com-1;
        for (j=0;j<len;j++)
        {
            if (com[j+index]==';' || com[j+index]=='}')
            {
                index+=j+1;
                break;
            }
        }
    }
    next_pos++;
    index++;
    //cout << "D: rest: next_pos=" << next_pos << endl;

    double d1=0.0,d2=0.0;
    int o1=1,o2=1;

    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) type=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) realization=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) o1=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) o2=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) absolute=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) debug=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) point_extension=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) oversampling=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) rno=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) invr=(int)tmp_answer;
    next_pos++;

    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) d1=tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) d2=tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) ripple=tmp_answer;
    next_pos++;
    sscanf(next_pos,"%s",x_formula);

    /// sscanf(com+index,"%d;%d;%d;%d;%d;%d;%d;%d;%d;%d;%lf;%lf;%lf;%s",&type,&realization,&o1,&o2,&absolute,&debug,&point_extension,&oversampling,&rno,&invr,&d1,&d2,&ripple,x_formula);
    x_formula[strlen(x_formula)-1]='\0';

    //cout << "d1=" << d1 << " o1=" << o1 << endl;
    //cout << "d2=" << d2 << " o2=" << o2 << endl;

/*cout << "original sets:" << endl;
for (i=0;i<o_n_sets;i++)
{
cout << "G" << (*o_gnos)[i] << ".S" << (*o_snos)[i] << endl;
}
cout << "target sets:" << endl;
for (i=0;i<n_sets;i++)
{
cout << "G" << (*gnos)[i] << ".S" << (*snos)[i] << endl;
}
cout << "type= " << type << endl;
cout << "realization= " << realization << endl;
cout << "o1= " << o1 << endl;
cout << "o2= " << o2 << endl;
cout << "absolute= " << absolute << endl;
cout << "debug= " << debug << endl;
cout << "point_extension= " << point_extension << endl;
cout << "oversampling= " << oversampling << endl;
cout << "rno= " << rno << endl;
cout << "invr= " << invr << endl;
cout << "d1= " << d1 << endl;
cout << "d2= " << d2 << endl;
cout << "ripple= " << ripple << endl;
cout << "x_formula= #" << x_formula << "#" << endl;*/

    limits[0]=d1;
    limits[1]=d2;
    orders[0]=o1;
    orders[1]=o2;
}

TestDialog::TestDialog(QWidget * parent):QWidget(parent)
{
QString home=QString(user_home_dir)+QDir::separator();

layout=new QGridLayout();
//layout->setMargin(STD_MARGIN);
layout->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
layout->setSpacing(STD_SPACING);

int number=number_of_devices();
QString entr[32];
    for (int i=0;i<number;i++)
    {
    entr[i]=get_device_name(i);
    }
devices_item=new StdSelector(this,tr("Output format:"),number,entr);

cmdSetExportName=new QPushButton(tr("set_exportname_external()"),this);
cmdSetDocName=new QPushButton(tr("set_docname_external()"),this);
cmdhardcopy=new QPushButton(tr("do_hardcopy()"),this);
cmdLoad=new QPushButton(tr("load_project_file()"),this);
cmdImportSin=new QPushButton(tr("Import Sinus via readDataFromClient()"),this);
cmdArrangeGr=new QPushButton(tr("Arrange Graphs"),this);
cmdCreatePolar2=new QPushButton(tr("Create Polar Graph v2"),this);
cmdTestExamples=new QPushButton(tr("Load All Examples"),this);
lenFile=new stdLineEdit(this,tr("FileName="));
lenExport=new stdLineEdit(this,tr("ExportName="));
lenDoc=new stdLineEdit(this,tr("DocName="));

lenFile->setText(home+QString("project.agr"));
lenDoc->setText(home+QString("project2.agr"));
lenExport->setText(home+QString("project3.png"));
lenDPI=new stdLineEdit(this,tr("DPI="));
lenDPI->setText("72");
lenSizeX=new stdLineEdit(this,tr("Width="));
lenSizeX->setText("792");
lenSizeY=new stdLineEdit(this,tr("Height="));
lenSizeY->setText("612");

lenFormulaTest=new stdLineEdit(this,tr("Formula with id to replace:"));
lenFormulaTest->setText("y=a0+a1*sin(a2*x+a3);fit formula \"y=a0+a1*x+a2*x^2\";formula2 \"x=2*x;y=3*x\" set;y1=exp(x*y+y2)");
lblReplacements=new QLabel(QString(""),this);
lblReplacedFormula=new QLabel(QString(""),this);
cmdReplacements=new QPushButton(tr("Set Replacements"),this);
cmdExecute=new QPushButton(tr("Execute Formula"),this);

lenTestString=new stdLineEdit(this,tr("Test-String:"));
lenTestString->setText("TestString:  - ");
lblReReadTest=new QLabel(QString(""),this);
cmdTestString=new QPushButton(tr("Test String Load/Save"),this);

int line=0;
layout->addWidget(cmdImportSin,line++,1);
layout->addWidget(lenFile,line,0);
layout->addWidget(cmdLoad,line++,1);
layout->addWidget(lenDoc,line,0);
layout->addWidget(cmdSetDocName,line++,1);
layout->addWidget(lenExport,line,0);
layout->addWidget(cmdSetExportName,line++,1);
layout->addWidget(devices_item,line++,0);
layout->addWidget(lenSizeX,line,0);
layout->addWidget(lenSizeY,line++,1);
layout->addWidget(lenDPI,line,0);
layout->addWidget(cmdhardcopy,line++,1);
layout->addWidget(cmdArrangeGr,line++,1);
layout->addWidget(cmdCreatePolar2,line++,1);
layout->addWidget(cmdTestExamples,line++,1);

layout->addWidget(lenFormulaTest,line++,0,1,2);
layout->addWidget(lblReplacements,line,0);
layout->addWidget(cmdReplacements,line++,1);
layout->addWidget(lblReplacedFormula,line,0);
layout->addWidget(cmdExecute,line++,1);

layout->addWidget(lenTestString,line++,0,1,2);
layout->addWidget(cmdTestString,line,0);
layout->addWidget(lblReReadTest,line++,1);

lenTextCodecTest=new stdLineEdit(this,tr("TextForCodecTest:"));
lenTextCodecTest->setText(tr("test   Test "));
lblTextCodecTest=new QLabel(tr(""),this);
cmdTextCodecTest=new QPushButton(tr("TextCodecTest"),this);

layout->addWidget(lenTextCodecTest,line,0,1,1);
layout->addWidget(lblTextCodecTest,line,1);
layout->addWidget(cmdTextCodecTest,line++,2);

setLayout(layout);

connect(cmdLoad,SIGNAL(clicked()),SLOT(doLoad()));
connect(cmdSetDocName,SIGNAL(clicked()),SLOT(doDocname()));
connect(cmdSetExportName,SIGNAL(clicked()),SLOT(doExport()));
connect(cmdhardcopy,SIGNAL(clicked()),SLOT(doHardcopy()));
connect(cmdImportSin,SIGNAL(clicked()),SLOT(doImportSin()));
connect(cmdArrangeGr,SIGNAL(clicked()),SLOT(doArrange()));
connect(cmdCreatePolar2,SIGNAL(clicked()),SLOT(doCreatePolar2()));
connect(cmdReplacements,SIGNAL(clicked()),SLOT(doSetReplacements()));
connect(cmdExecute ,SIGNAL(clicked()),SLOT(doExecuteFormula()));
connect(cmdTestExamples,SIGNAL(clicked()),SLOT(doTestExamples()));
connect(cmdTestString,SIGNAL(clicked()),SLOT(doStringSaveLoadTest()));
connect(cmdTextCodecTest,SIGNAL(clicked()),SLOT(doTextCodecTest()));
}

void TestDialog::doExport(void)
{
QString text=lenExport->text();
set_exportname_external(text.toLocal8Bit().constData());
}

void TestDialog::doDocname(void)
{
QString text=lenDoc->text();
set_docname_external(text.toLocal8Bit().constData());
}

void TestDialog::doHardcopy(void)
{
unsigned long w,h;
float dpi;
int dev_nr=devices_item->currentValue();
int sav_cur_file=curdevice;
int sav_hdevice=hdevice;
int sav_ptofile=get_ptofile();
set_ptofile(TRUE);

dpi=lenDPI->getDoubleValue();
w=lenSizeX->getIntValue();
h=lenSizeY->getIntValue();

Page_geometry pg,sav_pg;
sav_pg=get_page_geometry();
pg.dpi=dpi;
pg.height=h;
pg.width=w;

hdevice=dev_nr;
select_device(hdevice);
set_page_geometry(pg);

do_hardcopy();

hdevice=sav_hdevice;
select_device(sav_cur_file);
set_page_geometry(sav_pg);
set_ptofile(sav_ptofile);
mainWin->doDraw();
}

void TestDialog::doLoad(void)
{
QString text=lenFile->text();
int ret=load_project(text.toLocal8Bit().data());
    if (ret==RETURN_SUCCESS)
    QMessageBox::information(this,tr("Success"),tr("Project file loaded successfully."));
    else
    QMessageBox::information(this,tr("Failure"),tr("Failed to load project file. Sorry!"));
}

void TestDialog::doImportSin(void)
{
char * dataIn=new char[2048*64];
double x;
int offset=0;
for (int i=0;i<200;i++)
{
x=i/100.0;
sprintf(dataIn+offset,"%.5f %.5f\n",x,3.5*sin(2.0*3.1415927*x+0.2));
offset=strlen(dataIn);
}
//int ret=readDataFromClient(dataIn,LOAD_NXY,"Y=3.5*sin(2*PI*x+0.2)");
(void)readDataFromClient(dataIn,LOAD_NXY,"Y=3.5*sin(2*PI*x+0.2)");
delete[] dataIn;
mainWin->mainArea->completeRedraw();
}

void TestDialog::doArrange(void)
{
    int graphs[8];
    graphs[0]=0;
    graphs[1]=1;
    arrange_graphs(graphs, 2, 2, 1, 5, 1, 0.22, 0.08, 0.15, 0.15, 0.2, 0.2, FALSE, FALSE, TRUE, 0.0, 0.0, DEFAULT_TICK_PACK_X_INNER, DEFAULT_TICK_PACK_X_OUTER, DEFAULT_TICK_PACK_Y_INNER, DEFAULT_TICK_PACK_Y_OUTER,DEFAULT_TICK_PACK_X_INNER_DIR,DEFAULT_TICK_PACK_X_OUTER_DIR,DEFAULT_TICK_PACK_Y_INNER_DIR,DEFAULT_TICK_PACK_Y_OUTER_DIR);
    update_all();
}

void TestDialog::doCreatePolar2(void)
{
    //first: we just create a set for testing
int next_id=nextset(0);
(void)setlength(0,next_id,10);
g[0].p[next_id].data.ex[0][0]=-6.1515069e-18;
g[0].p[next_id].data.ex[1][0]=0.030733606;
g[0].p[next_id].data.ex[0][1]=0.6981317;
g[0].p[next_id].data.ex[1][1]=0.030733606;
g[0].p[next_id].data.ex[0][2]=1.3962634;
g[0].p[next_id].data.ex[1][2]=0.030733606;
g[0].p[next_id].data.ex[0][3]=2.0943951;
g[0].p[next_id].data.ex[1][3]=0.030733606;
g[0].p[next_id].data.ex[0][4]=2.7925268;
g[0].p[next_id].data.ex[1][4]=0.030733606;
g[0].p[next_id].data.ex[0][5]=-2.7925268;
g[0].p[next_id].data.ex[1][5]=0.030733606;
g[0].p[next_id].data.ex[0][6]=-2.0943951;
g[0].p[next_id].data.ex[1][6]=0.030544375;
g[0].p[next_id].data.ex[0][7]=-1.3962634;
g[0].p[next_id].data.ex[1][7]=0.030733606;
g[0].p[next_id].data.ex[0][8]=-0.6981317;
g[0].p[next_id].data.ex[1][8]=0.030733606;
g[0].p[next_id].data.ex[0][9]=-6.1515069e-18;
g[0].p[next_id].data.ex[1][9]=0.030733606;
    //second: set polar plot v2
set_graph_type(0,GRAPH_POLAR2);
    //third: set plot options (here arbitrary values: phi0=0.9 and roffset=12%)
set_parameters_polar_v2(0,0.9,0.12);
    //fourth: autoscale
autoscale_graph(0,AUTOSCALE_XY);
    //fifth: set nice graph settings
make_nice_polar_plot_v2(0);
    //redraw
mainWin->mainArea->completeRedraw();
}

void TestDialog::doSetReplacements(void)
{
g_lhs=g_rhs=s_lhs=s_rhs=-1;
bool ok;
g_lhs=QInputDialog::getInt(this,QString("Set Graph for LHS"),QString("Graph LHS"),0,0,100,1,&ok);
if (ok)
{
s_lhs=QInputDialog::getInt(this,QString("Set Set for LHS"),QString("Set LHS"),0,0,100,1,&ok);
    if (ok)
    {
    g_rhs=QInputDialog::getInt(this,QString("Set Graph for RHS"),QString("Graph RHS"),0,0,100,1,&ok);
        if (ok)
        {
        s_rhs=QInputDialog::getInt(this,QString("Set Set for RHS"),QString("Set RHS"),0,0,100,1,&ok);
            if (ok)
            {
            formula1.init_formula(lenFormulaTest->text());
            QString str_replacements;
            str_replacements=QString("G-LHS=") + QString::number(g_lhs) + QString(" S-LHS=") + QString::number(s_lhs) + QString(" G-RHS=") + QString::number(g_rhs) + QString(" S-RHS=") + QString::number(s_rhs);
            lblReplacements->setText(str_replacements);
            lblReplacedFormula->setText(QString(""));
            }
        }
    }
}
}

void TestDialog::doExecuteFormula(void)
{
int stdBut2=QMessageBox::question(this,tr("Replace?"),tr("Replace IDs?\nIf No, formula will just be completed (otherwise all ids will repaced)."),QMessageBox::Yes,QMessageBox::No);
int stdBut=QMessageBox::question(this,tr("Execute?"),tr("Execute the command?\nIf No, only the replaced formula will be shown."),QMessageBox::Yes,QMessageBox::No);
int return_value;
if (stdBut==QMessageBox::Yes)
{
    if (stdBut2==QMessageBox::Yes)
    lblReplacedFormula->setText(formula1.execute_formula(g_lhs,s_lhs,g_rhs,s_rhs,1,return_value));
    else
    lblReplacedFormula->setText(formula1.execute_formula(g_lhs,s_lhs,g_rhs,s_rhs,0,return_value));
    mainWin->mainArea->completeRedraw();
}
else
{
QString f;
    if (stdBut2==QMessageBox::Yes)
    formula1.return_replaced_formula(g_lhs,s_lhs,g_rhs,s_rhs,f);
    else
    formula1.return_completed_formula(g_lhs,s_lhs,g_rhs,s_rhs,f);
lblReplacedFormula->setText(f);
}
}

void TestDialog::doTestExamples(void)
{
    for (int i=0;i<mainWin->nr_of_Examples;i++)
    {
    mainWin->HelpOpenExample(i);
    force_redraw();
    mainWin->HelpOpenExample(36);
    force_redraw();
    }
}

void TestDialog::doStringSaveLoadTest(void)
{
char stored_string[512];
strcpy(stored_string,lenTestString->text().toUtf8().constData());
QString tmp_string;
tmp_string=QString::fromUtf8(stored_string);

//write string to file
QByteArray write_array;
write_array.clear();
//write_array.append(FileCodec->fromUnicode(tmp_string));
write_array.append(tmp_string.toUtf8());
int compr_succ=SaveByteArrayToFile(QString("D:\\old_data\\qtgrace_w_undo\\string_save_test_file.txt"),write_array);
//qDebug() << "compr_succ=" << compr_succ << "FileCodec=" << FileCodec->name();

//delete storage
stored_string[0]='\0';
write_array.clear();
tmp_string.clear();

//read string from file
compr_succ=LoadFileIntoByteArray(QString("D:\\old_data\\qtgrace_w_undo\\string_save_test_file.txt"),write_array);
//tmp_string=FileCodec->toUnicode(write_array);
tmp_string=QString::fromUtf8(write_array);
strcpy(stored_string,tmp_string.toUtf8().constData());
lblReReadTest->setText(QString::fromUtf8(stored_string));
}

void TestDialog::doTextCodecTest(void)
{
QString text=lenTextCodecTest->lenText->text();
char c_text[1024];
//qDebug() << "TextCodec=" << FileCodec->name();
qDebug() << "text read=" << text;
strcpy(c_text,text.toUtf8().constData());
qDebug() << "c_text in UTF8=" << c_text;
convert_single_string_from_UTF8_to_encoding_static(c_text);
qDebug() << "c_text in encoding=" << c_text;

}

SetupWizard::SetupWizard(QWidget * parent):QDialog(parent)
{
    setWindowTitle(tr("QtGrace Setup Wizard"));
    setWindowIcon(QIcon(*GraceIcon));
page_number=0;
max_pages=7;
lblPicture=new QLabel(this);
title1=new QLabel(tr("Initialize default settings for QtGrace"),this);
title1->setAlignment(Qt::AlignCenter);
QFont fo1=title1->font();
fo1.setPixelSize(fo1.pixelSize()*1.5);
title1->setFont(fo1);
title2=new QLabel(this);
    for (int i=0;i<MAX_SETUP_OPTIONS;i++)
    {
    optOptions[i]=new QRadioButton(QString("Option ")+QString::number(i));
    chkOptions[i]=new QCheckBox(QString("Check ")+QString::number(i));
    ledOptions[i]=new stdLineEdit(this,QString("Line Edit ")+QString::number(i));
    }
title3=new QLabel(tr("\nPlease select the settings that suit you best:"),this);
grid=new QGridLayout;
grid->setSpacing(STD_SPACING);
//grid->setMargin(STD_MARGIN);
grid->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
cmdPrev=new QPushButton(tr("Previous"),this);
cmdNext=new QPushButton(tr("Next"),this);
cmdCancel=new QPushButton(tr("Cancel"),this);
connect(cmdPrev,SIGNAL(clicked()),SLOT(doPrev()));
connect(cmdNext,SIGNAL(clicked()),SLOT(doNext()));
connect(cmdCancel,SIGNAL(clicked()),SLOT(doCancel()));
int index=0,index2;
grid->addWidget(title1,index++,0,1,4);
grid->addWidget(title2,index,1,1,3);
grid->addWidget(lblPicture,index++,0,2+2*MAX_SETUP_OPTIONS,1);
grid->addWidget(title3,index++,1,1,3);
index2=index;
    for (int i=0;i<MAX_SETUP_OPTIONS;i++)
    grid->addWidget(optOptions[i],index++,1,1,3);
index=index2;
    for (int i=0;i<MAX_SETUP_OPTIONS;i++)
    grid->addWidget(chkOptions[i],index++,1,1,3);
index=index2;
    for (int i=0;i<MAX_SETUP_OPTIONS;i++)
    grid->addWidget(ledOptions[i],index++,1,1,3);
QWidget * empty=new QWidget(this);
grid->addWidget(empty,index++,1,1,1);
grid->setRowStretch(index-1,3);
grid->addWidget(cmdPrev,index,1,1,1);
grid->addWidget(cmdNext,index,2,1,1);
grid->addWidget(cmdCancel,index++,3,1,1);
setLayout(grid);
reinitPage();
cmdCancel->setDefault(true);
resize(LastSize_Form_SetupWizard);
}

SetupWizard::~SetupWizard()
{
LastSize_Form_SetupWizard=this->size();
//qDebug() << "Close SetupWizard";
}

void SetupWizard::closeEvent( QCloseEvent * event )
{
int ret=QMessageBox::question(this,tr("Cancel Setup Wizard"),tr("Do you want to cancel the Setup-Wizard?\nIf 'yes', the default-values will be used for the settings."),QMessageBox::Yes|QMessageBox::No);
    if (ret==QMessageBox::No)
    {
    event->ignore();
    }
    else
    {
    event->accept();
    }
}

void SetupWizard::init(void)
{
    page_number=0;
    reinitPage();
}

void SetupWizard::doCancel(void)
{
int ret=QMessageBox::question(this,tr("Cancel Setup Wizard"),tr("Do you want to cancel the Setup-Wizard?\nIf 'yes', the default-values will be used for the settings."),QMessageBox::Yes|QMessageBox::No);
    if (ret==QMessageBox::No) return;
    hide();
}

void SetupWizard::doPrev(void)
{
    page_number--;
    reinitPage();
}

void SetupWizard::doNext(void)
{
    if (page_number==max_pages)
    {
    doApplySettings();
    hide();
    //qDebug() << "Finished SetupWizard";
    }
    else
    {
    page_number++;
    reinitPage();
    }
}

void SetupWizard::reinitPage(void)
{
static QString * entries=new QString[MAX_SETUP_OPTIONS];
static QString * entries2=new QString[MAX_SETUP_OPTIONS];
static QString * entries3=new QString[MAX_SETUP_OPTIONS];

    if (page_number>=max_pages)
    {
    page_number=max_pages;
    cmdNext->setText(tr("Apply Settings"));
    }
    else if (page_number<0)
    {
    page_number=0;
    }
    else
    {
    cmdNext->setText(tr("Next"));
    }

    if (page_number==0) cmdPrev->setEnabled(false);
    else cmdPrev->setEnabled(true);
    /*if (page_number==max_pages) cmdNext->setEnabled(false);
    else cmdNext->setEnabled(true);*/

    title2->setText(QString("Page ")+QString::number(page_number));

    switch (page_number)
    {
    case 0:
        title2->setText(tr("\nWelcome to the setup-wizard for QtGrace.\n\nIt seems, that you start this version of QtGrace for the first time.\nThis dialog shows you a few of the new features of QtGrace\nand helps you to select the default settings you like.\n\nIf you want to change the settings later,\nyou can find all settings in the 'Preferences'-dialog."));
        setNumberOfOptions(0,entries,0,entries2,0,entries3);
        break;
    case 1:
        title2->setText(tr("\nQtGrace offers an Undo/Redo-function.\nIf you do anything (e.g. changing set appearance, killing sets, transform a set)\nand find out that you did something wrong this function lets you reverse the operation.\n(This should work for most operations.) You find the list of reversable operations via the menu Edit->UndoList.\nIn the list-dialog you can also activate and deactivate the Undo-function.\nMost undo-list entries can also be used to generate script commands\n(do several operations, select them in the list and\nthe associated commands are transfered to the 'Commands'-dialog to be used as a script)."));
        entries[0]=tr("Activate Undo-function (useful to reverse a wrong operation)");
        entries[1]=tr("Deactivate Undo-function (if you work with very large sets the undo needs a lot of memory)");
        setNumberOfOptions(2,entries,0,entries2,0,entries3);
        break;
    case 2:
        title2->setText(tr("\nQtGrace shows existing sets in lists where they can be selected for operations.\nSometimes it is hard to find a specific set among a lot of sets.\nQtGrace offers several options to distinguish between the sets (apart from the set-ID)."));
        entries2[0]=tr("Show set icons (show a small icon in the list according the set appearance)");
        entries2[1]=tr("Show set comments");
        entries2[2]=tr("Show set legends");
        entries2[3]=tr("Show hidden sets (display sets that are currently not visible in a graph)");
        entries2[4]=tr("Show data-less sets (displays sets that have 0 datapoints which result from killing sets)");
        setNumberOfOptions(0,entries,5,entries2,0,entries3);
        break;
    case 3:
        setNumberOfOptions(0,entries,0,entries2,0,entries3);
        break;
    case 4:
        setNumberOfOptions(0,entries,0,entries2,0,entries3);
        break;
    case 5:
        setNumberOfOptions(0,entries,0,entries2,0,entries3);
        break;
    case 6:
        setNumberOfOptions(0,entries,0,entries2,0,entries3);
        break;
    case 7:
        title2->setText(tr("\nYou have set the most notable options now.\n\nIf you want to apply them to QtGrace please press the 'Apply Settings'-button below.\n\nAll settings are stored in an ini-file and will be applied every time you open QtGrace."));
        setNumberOfOptions(0,entries,0,entries2,0,entries3);
        break;
    }
}

void SetupWizard::setNumberOfOptions(int nr, QString * optentries,int nr2, QString * chkentries,int nr3, QString * ledentries)
{
    for (int i=0;i<nr;i++)
    {
    optOptions[i]->setVisible(true);
    optOptions[i]->setText(optentries[i]);
    }
    for (int i=nr;i<MAX_SETUP_OPTIONS;i++)
    {
    optOptions[i]->setVisible(false);
    }

    for (int i=0;i<nr2;i++)
    {
    chkOptions[i]->setVisible(true);
    chkOptions[i]->setText(chkentries[i]);
    }
    for (int i=nr2;i<MAX_SETUP_OPTIONS;i++)
    {
    chkOptions[i]->setVisible(false);
    }

    for (int i=0;i<nr3;i++)
    {
    ledOptions[i]->setVisible(true);
    ledOptions[i]->lblText->setText(ledentries[i]);
    }
    for (int i=nr3;i<MAX_SETUP_OPTIONS;i++)
    {
    ledOptions[i]->setVisible(false);
    }

    if (nr==0 && nr2==0)
    {
    title3->setVisible(false);
    }
    else
    {
    title3->setVisible(true);
    }
}

void SetupWizard::doApplySettings(void)
{
QMessageBox::information(this,tr("Setup Wizard finished"),tr("The setup is complete now. Your selected settings will be saved as default.\nYou can change them later via the 'Preferences'-dialog.\nYou can also summon this wizard again in the 'Miscellaneous'-tab there."));
/// here the settings should be applied to the defaults
}

//new setup-wizard
WizardIntroPage::WizardIntroPage(QWidget *parent):QWizardPage(parent)
{
setTitle(QObject::tr("Welcome"));
QString text;
text=QObject::tr("Welcome to the setup-wizard of QtGrace.\n\n");
if (setup_wizard_manual==FALSE)
text+=QObject::tr("It seems, that you start this version of QtGrace for the first time.\n");
text+=QObject::tr("This dialog shows you a few of the new features of QtGrace\nand helps you to select the default settings you like.\n\nIf you want to change the settings later,\nyou can find all settings in the 'Preferences'-dialog.\n\nBy clicking Cancel you may skip this Wizard for now,\nbut if you like to summon this Wizard again at a later time\nplease use the appropriate button in Preferences\\Miscellaneous.");
QLabel * label = new QLabel(text);
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
layout->addWidget(label);
setLayout(layout);
}

WizardUndoPage::WizardUndoPage(QWidget *parent):QWizardPage(parent)
{
setTitle(QObject::tr("Undo / Redo - function (01 / 20)"));
QLabel * label = new QLabel(QObject::tr("QtGrace has an option to undo most of the operations (like deleting sets).\nIn order to do so open Edit->UndoList.\n\nDo you want to activate the Undo-function?"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nIf Undo is activated the state before and after most operations is saved internally. Via the UndoList you may select to undo an operation or redo it again later. If you undo an operation the state before the operation is restored. If undo has already been done another undo will restore the state after the operation.\nIf you select more than one operation for undo the 'Undo'- and 'Redo'-buttons do the same think, but in different orders: Undo goes from the last operation upwards, Redo from the first operation downwards. If only one operation is to be made undone both do the same.\nTo save memory the number of actions that can be made undone is limited to the last ")+QString::number(MAX_UNDO_NODES)+QObject::tr(".\n\nGernerally having Undo active is a good thing, but if you are working with very large sets this function uses a lot of memory. When working with large data sets especially on 32-bit systems this means, that QtGrace will crash as soon as around 1.5GB of memory is used. In this case you may prefer to deactivate Undo (temporarily).\nPlease set your initial preference here. This setting will be used for the current session and every time QtGrace is started.\n\nIf you have to activate or deactivate Undo later open Edit->UndoList or Preferences->QtGrace-Behavior.\nIn the preferences the initial setting for Undo when QtGrace is started is separated from the current setting."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
QRadioButton * radYes=new QRadioButton(QObject::tr("Yes (activate undo)"),this);
QRadioButton * radNo =new QRadioButton(QObject::tr("No  (deactivate undo)"),this);
layout->addWidget(label);
layout->addWidget(radYes);
layout->addWidget(radNo);
layout->addWidget(explanation);
setLayout(layout);
registerField("undoActive", radYes);
    if (undo_active==TRUE)
    radYes->setChecked(true);
    else
    radNo->setChecked(true);
}

WizardImmediateUpdatePage::WizardImmediateUpdatePage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Immediate Updates (02 / 20)"));
QLabel * label = new QLabel(QObject::tr("In the original XmGrace / Grace the user has to press the 'Apply'-button to apply changes made in the GUI to the sets and graphs in a project.\nQtGrace has an option to apply every change in settings as soon as they are made in the GUI without the need of having to press 'Apply'. In the case of texts you have to press 'Return' or 'Enter' to accept text-changes and complete the editing.\n\nDo you want to activate the Immediate Updates function?"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther information:\n\nIf Undo is activated this may result in many additional steps in the UndoList if for example a slider is used. On the other hand this behavior resembles the behavior of other graphical user interfaces of modern programs and can be very convenient."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
QRadioButton * radYes=new QRadioButton(QObject::tr("Yes (automatically apply all changes)"),this);
QRadioButton * radNo =new QRadioButton(QObject::tr("No  (make changes only after 'Apply' is pressed)"),this);
layout->addWidget(label);
layout->addWidget(radYes);
layout->addWidget(radNo);
layout->addWidget(explanation);
setLayout(layout);
registerField("ImmUpdateActive", radYes);
    if (immediateUpdate==true)
    radYes->setChecked(true);
    else
    radNo->setChecked(true);
}

WizardDecSepPage::WizardDecSepPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Decimal Separator & Encoding (03 / 20)"));
QLabel * label = new QLabel(QObject::tr("QtGrace allows you to use '.' or ',' as decimal separator. \n\nFor the text (especially with the QtFonts) you may use non-ascii-characters. To save these non-ascii-characters in a project file a special encoding has to be used (the Grace-project format is usually ascii-text). Since v0.2.7 only UTF-8 is used as output-encoding.\n\nPlease select your preferences:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nDecimal separator:\nInternally '.' is used, for all GUI-inputs and the displays the selected separator is used. For data-import via drag-and-drop the number of '.' and ',' is counted and a suggestion made about what separator should be used for import accordingly. For data export the default separator of the operating system is used (this is useful for interaction with other software like spreadsheet-applications).\n\nEncoding:\nFor characters that are not part of the default-ascii-character-set a representation in files is needed since QtGrace (as well as XmGrace / Grace) uses text-files for the project file format. v0.2.7 is still able to read text in non-ascii-encoding. After this version only UTF-8 will be supported. For output only UTF-8 is used now. This way you should be able to read existing project files and save files in a way that will still be readable in the future."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
QLabel * label2 = new QLabel(QObject::tr("Decimal separator to use:"));
QLabel * label3 = new QLabel(QObject::tr("File text encoding:"));
QComboBox * cmbDecSep=new QComboBox(this);
cmbDecSep->addItem(QString("."));
cmbDecSep->addItem(QString(","));
QComboBox * cmbEncoding=new QComboBox(this);
    /*for (int i=0;i<avcod.length();i++)
    cmbEncoding->addItem(avcod.at(i));*/
    cmbEncoding->addItem(QString("UTF-8"));
    ///starting with v0.2.7 only UTF-8 is used
    cmbEncoding->setEnabled(false);
QCheckBox * chkWarningEncodingChange=new QCheckBox(QObject::tr("Display warning on encoding change"),this);
layout->addWidget(label,0,0,1,2);
layout->addWidget(label2,1,0,1,1);
layout->addWidget(cmbDecSep,1,1,1,1);
layout->addWidget(label3,2,0,1,1);
layout->addWidget(cmbEncoding,2,1,1,1);
layout->addWidget(chkWarningEncodingChange,3,0,1,2);
layout->addWidget(explanation,4,0,1,2);
setLayout(layout);
    if (warn_on_encoding_change)
    chkWarningEncodingChange->setChecked(true);
    else
    chkWarningEncodingChange->setChecked(false);
    if (DecimalPointToUse=='.')
    cmbDecSep->setCurrentIndex(0);
    else
    cmbDecSep->setCurrentIndex(1);
/*
int index=0;
for (int i=0;i<avcod.length();i++)
{
    if (FileCodec==QTextCodec::codecForName(avcod.at(i)))
    {
    index=i;
    break;
    }
}
cmbEncoding->setCurrentIndex(index);*/
cmbEncoding->setCurrentIndex(0);
///starting with v0.2.7 only UTF-8 is used
registerField("DecimalSeparator",cmbDecSep);
registerField("FileEncoding",cmbEncoding);
registerField("WarnOnEncodingChange",chkWarningEncodingChange);
}

WizardLatexPage::WizardLatexPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("LaTeX-Support (04 / 20)"));
QLabel * label = new QLabel(QObject::tr("For a more convenient input of formulas in text labels QtGrace is able to accept simple LaTeX-commands.\n\nDo you want to activate the LaTeX-support?"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nThis is done via a simple LaTeX-to-Grace-font-commands-translator. It is NOT a full LaTeX interpreter. To use the LaTeX-commands put them inside double '$'-characters like '$$\\alpha$$'. The offsets for the character glyphs have been optimized for the use with T1-fonts and may produce results that may not look perfect in the case of QtFont (see next page).\n\nIf you enter text containing LaTeX-commands in the GUI and want to fine-tune the resulting glyph commands click on the label left of the input-line where the commands have been entered. This will toggle between LaTeX-mode and Grace-input-mode. For example '$$\\alpha$$' is translated to '\\xa\\f{}'. If you edit the input in Grace-input-mode and press Enter the fine-tuned input will replace the LaTeX-command because a revers translation is not possible."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
QRadioButton * radYes=new QRadioButton(QObject::tr("Yes (simple LaTeX-commands are accepted)"),this);
QRadioButton * radNo =new QRadioButton(QObject::tr("No  (only Grace-font-commands are accepted - LaTeX-commands are not translated)"),this);
layout->addWidget(label);
layout->addWidget(radYes);
layout->addWidget(radNo);
layout->addWidget(explanation);
setLayout(layout);
registerField("LatexActive", radYes);
if (activateLaTeXsupport==true)
radYes->setChecked(true);
else
radNo->setChecked(true);
}

WizardQtFontsPage::WizardQtFontsPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("QtFonts (05 / 20)"));
QLabel * label = new QLabel(QObject::tr("The T1-fonts used in Grace / XmGrace mostly contain the ascii-characters and a few special characters. Only with special additions other characters can theoretically be used. In QtGrace you may also use characters from any other font you have installed on your system.\n\nDo you want to activate the QtFonts?"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nThis breaks the compatibility with the original Grace, but allows the usage of for example chinese characters. If QtFonts are activated the fonts are still accessed via numbers like in the original Grace and the first fonts are the same as in Grace / XmGrace. To add additional special fonts (on a project-specific basis) you have to click on the 'Font'-button left of every font-selector and select any font you like from the font-dialog (please note that the font size selected in the font-dialog is ignored). Please note that the font you want to use has to be present on any system you load the project file on. The T1-fonts are a guaranteed part of the QtGrace-/Grace-/XmGrace-installation.\n\nContrary to the T1-font every Qt-font contains the greek letters and special mathematical characters - but the placing in the character table is different. In order to use the symbol-font like in Grace the symbol font for the Qt-fonts has to be set as special. With this option the T1-characters of the symbol font are translated to their positions in the UTF-8-encoding. If the symbol font is not to be treated as special it is harder to access greek letters, but greek-letters can be displayed in any font (that has glyphs for them) in the same way."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
QRadioButton * radYes=new QRadioButton(QObject::tr("Yes (use Qt-fonts instead of T1-fonts)"),this);
QRadioButton * radNo =new QRadioButton(QObject::tr("No  (only Grace-T1-fonts are used)"),this);
QCheckBox * chkSpecial=new QCheckBox(QObject::tr("Symbol-font is special"));
layout->addWidget(label);
layout->addWidget(radYes);
layout->addWidget(radNo);
layout->addWidget(chkSpecial);
layout->addWidget(explanation);
setLayout(layout);
registerField("QtFontsActive", radYes);
registerField("SymbolFontSpecial", chkSpecial);
if (useQtFonts==true)
radYes->setChecked(true);
else
radNo->setChecked(true);
chkSpecial->setChecked(symbol_font_is_special);
}

WizardMouseWheelPage::WizardMouseWheelPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Usage of the Mouse Wheel (06 / 20)"));
QLabel * label = new QLabel(QObject::tr("If you want to zoom in with the mouse-wheel activate zooming and place the cursor at the position at which you want to zoom in and rotate the mouse wheel away from you. Rotation towards you will zoom out.\n\nYou may also use the mouse-wheel to resize different items in a plot.\n\nPlease select your preferences for the usage of the mouse-wheel:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nYou can increase or decrease the font sizes or the size of objects like boxes or lines. To change the font size of axis-tick-labels you have to use the mouse-wheel on the axis itself (not the axis-tick-labels); on all other texts using the mouse-wheel directly on the text changes the font size."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
QCheckBox * chkZoom=new QCheckBox(QObject::tr("Use mouse-wheel for zooming in and out of the graph"),this);
QCheckBox * chkSizeChange =new QCheckBox(QObject::tr("Use mouse-wheel to change font sizes and object sizes"),this);
layout->addWidget(label);
layout->addWidget(chkZoom);
layout->addWidget(chkSizeChange);
layout->addWidget(explanation);
setLayout(layout);
registerField("MouseWheelZoom", chkZoom);
registerField("MouseWheelSize", chkSizeChange);
    if (allow_wheel_zoom)
    chkZoom->setChecked(true);
    else
    chkZoom->setChecked(false);
    if (allow_wheel_changes)
    chkSizeChange->setChecked(true);
    else
    chkSizeChange->setChecked(false);
}

WizardTextEditPage::WizardTextEditPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Edit Text in Main Drawing Area (07 / 20)"));
QLabel * label = new QLabel(QObject::tr("In Grace / XmGrace to edit labels you have to open separate dialogs and press apply.\nIn QtGrace it is possible to directly enter and edit text in the main drawing area. \n\nDo you want to activate the Inline-Editing?"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nIf this option is activated just double-click on a text (like graph-title or -subtitle, set-legend, axis-label, custom-tick-label or text-annotation) and type your text. To accept your changes press 'Enter'/'Return'. To reject changes press 'Esc' or click outside the text.\n\nIf this inline-editing function is activated double click does not summon some of the dialogs any more but they can still be accessed via the Plot-menu or if you hold the CTRL-button while double clicking.\n\nTo save some resources the text-editing is done above the original text while the original text is still present in the background. It is therefore possible that some artefacts may be seen during editing."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
QRadioButton * radYes=new QRadioButton(QObject::tr("Yes (Edit text entries in main drawing area)"),this);
QRadioButton * radNo =new QRadioButton(QObject::tr("No  (text can only be edited via the dialogs like in Grace / XmGrace)"),this);
layout->addWidget(label);
layout->addWidget(radYes);
layout->addWidget(radNo);
layout->addWidget(explanation);
setLayout(layout);
registerField("TextEditInMain", radYes);
if (inline_editing==true)
radYes->setChecked(true);
else
radNo->setChecked(true);
}

WizardContextMenuPage::WizardContextMenuPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Context Menu in Main Drawing Area (08 / 20)"));
QLabel * label = new QLabel(QObject::tr("QtGrace offers the option to summon a context menu for a set in the main drawing area by right-clicking on one of the points in a set. \n\nDo you want to activate the context menu?"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nThis menu is the same as in the set-lists. You may use it to change the appearance of a set or hide it and you may also do simple data-set-operations (like sort). To make invisible sets visible again you still have to use context menues in set-lists."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
QRadioButton * radYes=new QRadioButton(QObject::tr("Yes (summon context menu for sets via a right-click)"),this);
QRadioButton * radNo =new QRadioButton(QObject::tr("No  (no context menu in main drawing area - context menus only in set-lists)"),this);
layout->addWidget(label);
layout->addWidget(radYes);
layout->addWidget(radNo);
layout->addWidget(explanation);
setLayout(layout);
registerField("ContextMenuInMain", radYes);
    if (context_menu_in_main==true)
    radYes->setChecked(true);
    else
    radNo->setChecked(true);
}

WizardHighlightPage::WizardHighlightPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Set Highlighting (09 / 20)"));
QLabel * label = new QLabel(QObject::tr("In QtGrace sets or graphs can be highlighted for better identifying one set among lots of set.\n\nPlease select your preferences for the highlighting:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nTo highlight something select it in a list and press 'h'. To stop the highlighting select something outside the list (list loses focus) or press 'h' again. There is also an option to automatically stop highlighting after a specified amount of time. All highlights are done in dashed lines with an increased linewidth in a predefined color. The highlighted sets or graphs blink. You may also set, that every time you change the selection in a list the new selection is to be highlighted automatically.\n\nThe drawback of the hightlighting is, that it can be very cpu-intensive if you have large sets - especially if you also highlight the errorbars and symbols. QtGrace will react very slowly then. Keep this in mind if you consider activating auto-highlighting."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
QComboBox * cmbHighlightTime = new QComboBox(this);
QString entr[6];
entr[0]=tr("No limit");
entr[1]=QString("1 s");
entr[2]=QString("2 s");
entr[3]=QString("3 s");
entr[4]=QString("4 s");
entr[5]=QString("5 s");
    for (int i=0;i<6;i++)
    cmbHighlightTime->addItem(entr[i]);
QLabel * label2 = new QLabel(QObject::tr("Maximum time for highlight:"));
QLabel * label3 = new QLabel(QObject::tr("Highlight-color:"));
QComboBox * colSel = new QComboBox(this);
    for (unsigned int i=0;i<number_of_colors();i++)
    colSel->addItem(QString(get_colorname(i)));
QCheckBox * chkAutoHighlight = new QCheckBox(tr("Auto-highlight new selection\n(every time a new set or graph is selected the new selection is highlighted)"),this);
QCheckBox * chkHighlighErrorBars = new QCheckBox(tr("Highlight error bars and symbols\n(only lines are highlighted if not activated)"),this);
layout->addWidget(label,0,0,1,2);
layout->addWidget(label2,1,0,1,1);
layout->addWidget(cmbHighlightTime,1,1,1,1);
layout->addWidget(label3,2,0,1,1);
layout->addWidget(colSel,2,1,1,1);
layout->addWidget(chkAutoHighlight,3,0,1,2);
layout->addWidget(chkHighlighErrorBars,4,0,1,2);
layout->addWidget(explanation,5,0,1,2);
setLayout(layout);

colSel->setCurrentIndex(highlight_color);
cmbHighlightTime->setCurrentIndex(highlight_time);
if (highlight_errorbars)
chkHighlighErrorBars->setChecked(true);
else
chkHighlighErrorBars->setChecked(false);
if (auto_highlight)
chkAutoHighlight->setChecked(true);
else
chkAutoHighlight->setChecked(false);

registerField("HighlightColor", colSel);
registerField("HighlightTime", cmbHighlightTime);
registerField("AutoHighlight", chkAutoHighlight);
registerField("HighlightErrorBars", chkHighlighErrorBars);
}

WizardAutoscalePage::WizardAutoscalePage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Extended autoscale options (10 / 20)"));
QLabel * label = new QLabel(QObject::tr("Grace / XmGrace ignore error bars for autoscaling and may position set points on the borders of a graph. QtGrace lets you choose to consider the errorbars for the autoscaling. You may also set a fraction of the range of X- and Y-axis around the borders of the graph that will stay empty after autoscaling.\n\nPlease set your preferences for the autoscaling:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nConcidering the errorbars for autoscaling makes sure the errorbars do not extend outside the graphs viewing area. Forcing a border around the data-points and errorbars to stay empty may give a more conveniant look to a graph. Example: Let us assume that you have data points between X=0 and 100. Using autoscale usually positions the first point on the Y-axis at X=0 and the last point on the Y-axis at X=100. If you set the minimum offset to 0.01 then an offset of 100*0.01=1 is used. This means that the autoscaling will assume that the X-values are between -1 and 101. Since autoscale uses 'nice' looking limits this will often result in larger empty areas around sets.\nPlease note: These settings only affect the autoscaling - you can still set any X- or Y-range for the axes manually."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
QCheckBox * chkErrorBarsForAutoscale = new QCheckBox(tr("Take error bars into account for autoscaling"),this);
QLabel * label2 = new QLabel(QObject::tr("Minimal offset from the borders as fraction of the axis-range:"));
spnAutoScaleRange = new QDoubleSpinBox(this);
spnAutoScaleRange->setRange(0.0,0.5);
spnAutoScaleRange->setDecimals(3);
spnAutoScaleRange->setSingleStep(0.01);
QLocale newLocale=(DecimalPointToUse=='.')?(*dot_locale):(*comma_locale);
spnAutoScaleRange->setLocale(newLocale);
spnAutoScaleRange->setValue(minAutoscaleBorderOffset);
if (useErrorbarsInAutoscale)
chkErrorBarsForAutoscale->setChecked(true);
else
chkErrorBarsForAutoscale->setChecked(false);

layout->addWidget(label,0,0,1,2);
layout->addWidget(chkErrorBarsForAutoscale,1,0,1,2);
layout->addWidget(label2,2,0,1,1);
layout->addWidget(spnAutoScaleRange,2,1,1,1);
layout->addWidget(explanation,3,0,1,2);
setLayout(layout);
registerField("AutoscaleIncludingErrorBars", chkErrorBarsForAutoscale);
//registerField("AutoscaleBorderOffset",spnAutoScaleRange);
}

WizardListIconsPage::WizardListIconsPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Additional Icons in Lists (11 / 20)"));
QLabel * label = new QLabel(QObject::tr("QtGrace allows the display of icons in some lists or on some buttons to better illustrate the purpose of the options.\n\nPlease select your prefered setting:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nThis setting is global for every dialog and is mainly meant for the color-selectors or the symbol-type.\nThe additional icons also affect the buttons in the Drawing-Objects-Dialog."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
int nr=3;
QString * entries=new QString[3];
entries[0]=tr("No Icons (just text)");
entries[1]=tr("Icons and text");
entries[2]=tr("Just icons (no text)");
StdSelector * selIcons=new StdSelector(this,QObject::tr("Icons on buttons and in lists:"),nr,entries);
layout->addWidget(label,0,0,1,1);
layout->addWidget(selIcons,1,0,1,1);
layout->addWidget(explanation,2,0,1,1);
setLayout(layout);
delete[] entries;
selIcons->setCurrentValue(icon_preferences);
registerField("IconPreferences",selIcons->cmbSelect);
}

WizardUniListSettingsPage::WizardUniListSettingsPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Display settings for Set-Lists (12 / 20)"));
QLabel * label = new QLabel(QObject::tr("In QtGrace the set-lists can display additional informations about data sets apart from the set-ID.\n\nSelect what to show:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nUsually a set is denoted by the set-ID like G1.S5 (set number 5 in graph number 1).\nThe list can as well display comment or legend for every set (the comment contains in most cases the origin of a data set - like the file it has been loaded from).\nThe list can also display icons showing a simplified representation of the set appearance (which can be very handy indeed).\n\nA list usually displays visible and hidden sets showing (+) for visible and (-) for invisible sets. To match a list with what is shown in the main drawing area just deactivate the \"Hidden\"-option (invisble sets are inaccessible then apart from the Edit/\"Explorer\"-dialog).\n\nUsually sets without data-points are not shown in the lists but after deleting a set the appearance-settings are retained if \"kill-data\" is used. If new data is imported the new data is stored in the next free set-ID (i.e. the next set-ID that has no data in it or a new ID). If you want to edit the set appearance before loading data you have to activate \"Show data-less sets\" (but this can sometimes be confusing as well)."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
QCheckBox * chkShowDataLess=new QCheckBox(tr("Data-less sets"),this);
QCheckBox * chkShowHidden=new QCheckBox(tr("Hidden sets"),this);
QCheckBox * chkShowComment=new QCheckBox(tr("Set comments"),this);
QCheckBox * chkShowLegend=new QCheckBox(tr("Set legends"),this);
QCheckBox * chkShowIcons=new QCheckBox(tr("Icons"),this);
layout->addWidget(label,0,0,1,2);
layout->addWidget(chkShowIcons,1,0,1,1);
layout->addWidget(chkShowHidden,1,1,1,1);
layout->addWidget(chkShowComment,2,0,1,1);
layout->addWidget(chkShowLegend,2,1,1,1);
layout->addWidget(chkShowDataLess,3,0,1,1);
layout->addWidget(explanation,4,0,1,2);
chkShowDataLess->setChecked(DefaultSetListShowDataless);
chkShowHidden->setChecked(DefaultSetListShowHidden);
chkShowComment->setChecked(DefaultSetListShowComments);
chkShowLegend->setChecked(DefaultSetListShowLegends);
chkShowIcons->setChecked(DefaultSetListShowIcons);

registerField("ListDataLess",chkShowDataLess);
registerField("ListHidden",chkShowHidden);
registerField("ListComment",chkShowComment);
registerField("ListLegend",chkShowLegend);
registerField("ListIcons",chkShowIcons);

setLayout(layout);
}

WizardLibFFTW3Page::WizardLibFFTW3Page(QWidget * parent):QWizardPage(parent)
{
    check_external_lib_usability();
setTitle(QObject::tr("FFTW3-library (13 / 20)"));
QString labeltext=QObject::tr("The FFTW3-library can be used in QtGrace for more efficient fourier-transformations.");
QString labeltext2=QObject::tr("FFTW3-library usable.");

#ifdef USE_STATIC_EXT_LIB_FFTW3
labeltext+=QObject::tr("\n\nThe FFTW3-library has been linked to your build of QtGrace statically and is therefore always available.");
labeltext+=QObject::tr("\n\nYou just have to choose whether you want to use it (or not).");
#else
labeltext+=QObject::tr("\n\nIf you have the FFTW3-library on your system and want to use it for all fourier-transformations you have to tell QtGrace the location of the library and activate it.");
labeltext2=QObject::tr("FFTW3-library NOT usable.");
#endif

/*have_fftw3
path_to_fftw3_lib*/

QLabel * label = new QLabel(labeltext);
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nInternally QtGrace uses a simple Fast-Fourier-algorithm for fourier transformations of sets with a number of points that is a power of 2. For other sets a discrete fourier transformation is used that is very slow. The fftw3-library is able to work efficiently with sets that have a size that is not a power of 2.\n\nThe fftw3-library is not part of QtGrace - it is included unaltered for convenience. See copyright-notice in the QtGrace-Extensions-html-file."));
lblUsable = new QLabel(labeltext2);
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
layout->addWidget(label,0,0,1,2);

ledLibraryPath=new stdLineEdit(this,QObject::tr("Library path:"));
ledLibraryPath->setText(path_to_fftw3_lib.fileName());
QPushButton * cmdBrowse=new QPushButton(QObject::tr("Browse"),this);
connect(cmdBrowse,SIGNAL(clicked()),SLOT(doBrowse()));

layout->addWidget(ledLibraryPath,1,0,1,1);
layout->addWidget(cmdBrowse,1,1,1,1);

QCheckBox * chkUseFFTW3=new QCheckBox(QObject::tr("Use FFTW3 for fourier-transformations"),this);
chkUseFFTW3->setChecked(use_fftw3);
layout->addWidget(lblUsable,2,0,1,2);
layout->addWidget(chkUseFFTW3,3,0,1,2);
registerField("UseFFTW3",chkUseFFTW3);
registerField("LibFFTW3Path",ledLibraryPath->lenText);

#ifdef USE_STATIC_EXT_LIB_FFTW3
ledLibraryPath->hide();
cmdBrowse->hide();
#else
bool usability=is_fftw3_lib_usable(ledLibraryPath->text());
    if (usability)
    {
    labeltext2=QObject::tr("FFTW3-library usable.");
    }
    else
    {
    labeltext2=QObject::tr("FFTW3-library NOT usable!");
    }
lblUsable->setText(labeltext2);
#endif
layout->addWidget(explanation,4,0,1,2);
setLayout(layout);
}

void WizardLibFFTW3Page::doBrowse(void)
{
QString suffix;
QString labeltext2=QObject::tr("FFTW3-library usable.");
#ifdef WINDOWS_SYSTEM
    suffix=QString("*.dll");
#endif
#ifdef MAC_SYSTEM
    suffix=QString("*.dylib");
#else
    #ifdef LINUX_SYSTEM
    suffix=QString("*.so");
    #endif
#endif
QString fileName = QFileDialog::getOpenFileName(this, QObject::tr("Select FFTW3-library file"),
                                                ledLibraryPath->text(),
                                                QObject::tr("Dynamic library (")+suffix+QString(")"));
    if (!fileName.isEmpty())
    {
    //qDebug() << "New File: " << fileName;
    bool usability=is_fftw3_lib_usable(fileName);
        if (usability==true)
        {
        ledLibraryPath->setText(fileName);
        labeltext2=QObject::tr("FFTW3-library usable.");
        }
        else
        {
        QMessageBox::warning(this,tr("Invalid file"),tr("The file you selected does not seem to contain a compatible version of the FFTW3-library."));
            if (is_fftw3_lib_usable(ledLibraryPath->text())==true)
            labeltext2=QObject::tr("FFTW3-library usable.");
            else
            labeltext2=QObject::tr("FFTW3-library NOT usable!");
        }
    lblUsable->setText(labeltext2);
    }
    //qDebug() << "Browse fftw3";
}

WizardLibHaruPage::WizardLibHaruPage(QWidget * parent):QWizardPage(parent)
{
    check_external_lib_usability();
setTitle(QObject::tr("Haru-pdf-library (14 / 20)"));
QString labeltext=QObject::tr("Grace / XmGrace can also use an external pdf-library. ");
QString labeltext2=QObject::tr("Haru-PDF-library usable.");

#ifdef USE_STATIC_EXT_LIB_HARU
labeltext+=QObject::tr("\n\nThe Haru-PDF-library has been linked to your build of QtGrace statically and is therefore always available.");
labeltext+=QObject::tr("\n\nYou just have to choose whether you want to use it (or not).");
#else
labeltext+=QObject::tr("\n\nIf you have the Haru-PDF-library on your system, you may use it in QtGrace.");
labeltext+=QObject::tr("\n\nIf you want to use it you have to tell QtGrace the location of the library and activate it.");
labeltext2=QObject::tr("Haru-PDF-library NOT usable.");
#endif
/*have_libHaru
path_to_libharu;*/

QLabel * label = new QLabel(labeltext);
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nFor the export of the project you can by default use formats like PNG, JPG or Postscript. Unfortunately the pdf-library used by XmGrace is not completely free for use in every case. Therefore QtGrace can use the Haru-PDF-library to export as pdf-files instead.\n\nTo actually export something as pdf you also have to choose PDF(Haru) as the output-format in the export-setup-dialog.\n\nPlease note, that there is also an internal pdf-export-function available that utilizes the pdf-export-capability of the Qt-library. If you use QtFonts and a Qt-version of at least 5.3 the internal pdf-export should produce nice pdf-files. On previous Qt-versions the pdf-files just contain a screenshot of the project (i.e. low quality). If Qt-fonts are not used, the Qt-PDF-export is unable to export text (yet). Sorry. Therefore without QtFonts or with a Qt-version lower than 5.3 the Haru-pdf-library is the best option for pdf-export. If you use QtFonts, the Haru-pdf-library will not be able to export text (sorry).\n\nSummary: If you are not using QtFonts you probably want the Haru-PDF-library to export pdf-files.\n\nThe Haru-PDF-library is not part of QtGrace. It is included unaltered for conveniance. For the 64bit-versions of QtGrace a static version of the library has been compiled into QtGrace because no precompiled library could be found. See copyright-notice in the QtGrace-Extensions-html-file."));
lblUsable = new QLabel(labeltext2);
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
layout->addWidget(label,0,0,1,2);

ledLibraryPath=new stdLineEdit(this,QObject::tr("Library path:"));
ledLibraryPath->setText(path_to_libharu.fileName());
QPushButton * cmdBrowse=new QPushButton(QObject::tr("Browse"),this);
connect(cmdBrowse,SIGNAL(clicked()),SLOT(doBrowse()));

layout->addWidget(ledLibraryPath,1,0,1,1);
layout->addWidget(cmdBrowse,1,1,1,1);

QCheckBox * chkUseLibHaru=new QCheckBox(QObject::tr("Enable the Haru-PDF-library for PDF-export"),this);
chkUseLibHaru->setChecked(use_libHaru);
layout->addWidget(lblUsable,2,0,1,2);
layout->addWidget(chkUseLibHaru,3,0,1,2);
registerField("UseLibHaru",chkUseLibHaru);
registerField("LibHaruPath",ledLibraryPath->lenText);

#ifdef USE_STATIC_EXT_LIB_HARU
ledLibraryPath->hide();
cmdBrowse->hide();
#else
bool usability=is_Haru_lib_usable(ledLibraryPath->text());
    if (usability)
    {
    labeltext2=QObject::tr("Haru-PDF-library usable.");
    }
    else
    {
    labeltext2=QObject::tr("Haru-PDF-library NOT usable!");
    }
lblUsable->setText(labeltext2);
#endif
layout->addWidget(explanation,4,0,1,2);
setLayout(layout);
}

void WizardLibHaruPage::doBrowse(void)
{
QString suffix;
QString labeltext2=QObject::tr("Haru-PDF-library usable.");
#ifdef WINDOWS_SYSTEM
    suffix=QString("*.dll");
#endif
#ifdef MAC_SYSTEM
    suffix=QString("*.dylib");
#else
    #ifdef LINUX_SYSTEM
    suffix=QString("*.so");
    #endif
#endif
QString fileName = QFileDialog::getOpenFileName(this, QObject::tr("Select HaruPDF-library file"),
                                                    ledLibraryPath->text(),
                                                    QObject::tr("Dynamic library (")+suffix+QString(")"));
    if (!fileName.isEmpty())
    {
    //qDebug() << "New File: " << fileName;
    bool usability=is_Haru_lib_usable(fileName);
        if (usability==true)
        {
        ledLibraryPath->setText(fileName);
        labeltext2=QObject::tr("Haru-PDF-library usable.");
        }
        else
        {
        QMessageBox::warning(this,tr("Invalid file"),tr("The file you selected does not seem to contain a compatible version of the Haru-PDF-library."));
            if (is_Haru_lib_usable(ledLibraryPath->text()))
            labeltext2=QObject::tr("Haru-PDF-library usable.");
            else
            labeltext2=QObject::tr("Haru-PDF-library NOT usable!");
        }
    lblUsable->setText(labeltext2);
    }
    //qDebug() << "Browse haru";
}

bool WizardLibHaruPage::validatePage()
{
outPage->initializePage();
return true;
}

WizardToolBarPage::WizardToolBarPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Tool bar contents (15 / 20)"));
QLabel * label = new QLabel(QObject::tr("The contents of the tool-bar on the left hand side of the main window are extended in QtGrace in comparison with Grace / XmGrace.\n\nChoose what should be displayed in the tool-bar:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nNot every one might need every button regularely. Therefore the contents of the tool-bar can be adjusted.\nThe options above activate or deactivate buttons or groups of buttons according to specific purposes.\nThe \"Pan\"-button allows you to click and drag the viewing area (i.e. shift the axis ranges up and down).\nThe \"Move\"-button allows you to click and move most things in the viewing area (like graph- or axis-labels, legends or objects). You can also click-and-drag the viewing area like with the \"Pan\"-button. Be aware, that althought the \"Move\"-button can do everything the \"Pan\"-button can and more, the \"Pan\"-button is saver in its use! The \"Move\"-button can change the positioning of labels from auto to specified without you noticing (if you click on the labels while \"Move\" is active - keep this in mind).\nThe graph-list is used to select more than one graph for simultaneous zooming and shifting of the contents.\n\nThe export button prints the current projects contents in a file as set in the export-setup-dialog. If nothing is set explicitly the file name is the same as the project file name with a different suffix according to the currently set export format.\nThe new icons are just a different / more colorful representation of the icons on the move- and zoom-buttons."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;

int index=3;
QString entries[3];
entries[0]=tr("Hide button");
entries[1]=tr("Show button");
entries[2]=tr("Always on");

QCheckBox * chkNewIcons=new QCheckBox(tr("Use new icons"),this);
QCheckBox * chkShowNavi=new QCheckBox(tr("Show navigation buttons"),this);
QCheckBox * chkShowGraph=new QCheckBox(tr("Show graph list"),this);
QCheckBox * chkShowSpecZoom=new QCheckBox(tr("Show special zoom buttons"),this);
//QCheckBox * chkShowViewp=new QCheckBox(tr("Show viewport stack"),this);
QCheckBox * chkShowPageZoom=new QCheckBox(tr("Show page zoom"),this);
QCheckBox * chkShowPrintB=new QCheckBox(tr("Show print button"),this);
QCheckBox * chkShowExportP=new QCheckBox(tr("Show export button"),this);

StdSelector * selPanB=new StdSelector(this,tr("Pan:"),index,entries);
StdSelector * selMoveB=new StdSelector(this,tr("Move:"),index,entries);

/*QCheckBox * chkShowPanB=new QComboBox(tr("Show pan button"),this);
QCheckBox * chkShowPickB=new QCheckBox(tr("Show move button"),this);*/

QCheckBox * chkShowUndoRedo=new QCheckBox(tr("Show Undo/Redo buttons"),this);

layout->addWidget(label,0,0,1,2);
layout->addWidget(chkNewIcons,1,0,1,1);
layout->addWidget(chkShowNavi,1,1,1,1);
layout->addWidget(chkShowGraph,2,0,1,1);
layout->addWidget(chkShowSpecZoom,2,1,1,1);
//layout->addWidget(chkShowViewp,3,0,1,1);
layout->addWidget(chkShowPageZoom,3,1,1,1);
layout->addWidget(chkShowPrintB,4,0,1,1);
layout->addWidget(chkShowExportP,4,1,1,1);
/*layout->addWidget(chkShowPanB,5,0,1,1);
layout->addWidget(chkShowPickB,5,1,1,1);*/
layout->addWidget(selPanB,5,0,1,1);
layout->addWidget(selMoveB,5,1,1,1);
layout->addWidget(chkShowUndoRedo,3,0,1,1);//was 6,0,1,1
layout->addWidget(explanation,6,0,1,2);
chkNewIcons->setChecked(use_new_icons);
chkShowNavi->setChecked(show_Navi_B);
chkShowGraph->setChecked(show_Graph_List);
chkShowSpecZoom->setChecked(show_special_Zoom);
//chkShowViewp->setChecked(show_Viewport_Stack);
chkShowPageZoom->setChecked(show_Page_Zoom);
chkShowPrintB->setChecked(show_Print_B);
chkShowExportP->setChecked(show_Export_B);
selPanB->setCurrentIndex(show_PanButton);
selMoveB->setCurrentIndex(show_PickButton);
/*chkShowPanB->setChecked(show_PanButton);
chkShowPickB->setChecked(show_PickButton);*/
chkShowUndoRedo->setChecked(show_UndoRedo_B);

registerField("ToolsNewIcons",chkNewIcons);
registerField("ToolsNavi",chkShowNavi);
registerField("ToolsGraph",chkShowGraph);
registerField("ToolsSpecZoom",chkShowSpecZoom);
//registerField("ToolsViewportStack",chkShowViewp);
registerField("ToolsPageZoom",chkShowPageZoom);
registerField("ToolsPrint",chkShowPrintB);
registerField("ToolsExport",chkShowExportP);
/*registerField("ToolsPan",chkShowPanB);
registerField("ToolsPick",chkShowPickB);*/
registerField("ToolsPan",selPanB->cmbSelect);
registerField("ToolsPick",selMoveB->cmbSelect);
registerField("ToolsUndo",chkShowUndoRedo);

setLayout(layout);

}

WizardToolBarPage2::WizardToolBarPage2(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Viewport-Stack (16 / 20)"));
QLabel * label = new QLabel(QObject::tr("In Grace/XmGrace the user has an option to store different viewports (that means different settings for X- and Y-axis representing different zoom stages).\n\nChoose how the viewport-stack should be accessed:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nIn Grace/XmGrace these viewports are numbered and organized in a stack that can be accessed via the tool bar (Push/Pop). The user may cycle through all viewports in the stack. The accessability is a bit limited and therefore QtGrace offers extended control.\n\nIn QtGrace you may name every viewport in the stack and randomly access any of the entries in the stack and also rearrange the order of the stack. You may cycle the stack in both directions."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;

int index=3;
QString entries[3];
entries[0]=tr("Hide controls");
entries[1]=tr("Simple controls (Grace/XmGrace)");
entries[2]=tr("Complete list (QtGace)");
StdSelector * selShowViewp=new StdSelector(this,tr("Viewport:"),index,entries);

layout->addWidget(label,0,0,1,2);
layout->addWidget(selShowViewp,1,0,1,1);
layout->addWidget(explanation,2,0,1,2);
selShowViewp->setCurrentIndex(show_Viewport_Stack);

registerField("ToolsViewportStack",selShowViewp->cmbSelect);
setLayout(layout);
}

WizardStartUpPage::WizardStartUpPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Start up file (17 / 20)"));
QLabel * label = new QLabel(QObject::tr("In Grace / XmGrace the file Default.agr in the bin-folder is loaded on startup and when 'New' is pressed. QtGrace now offers to use any Grace-project file in any folder on startup.\n\nPlease select a default startup file:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nYou may also choose to store the file-path relative to the templates-directory or absolute.\n\nThe default-path for startup-files is now the templates-subfolder in the QtGrace-directory."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
layout->addWidget(label,0,0,1,2);
lenAbsoluteFile=new stdLineEdit(this,QObject::tr("Absolute startup file path:"));

cmdBrowse=new QPushButton(QObject::tr("Browse"),this);
connect(cmdBrowse,SIGNAL(clicked()),SLOT(doBrowse()));
layout->addWidget(lenAbsoluteFile,1,0,1,1);
layout->addWidget(cmdBrowse,1,1,1,1);

radAbsolute=new QRadioButton(QObject::tr("Store file path absolute"),this);
radRelative=new QRadioButton(QObject::tr("Store file path relative to the templates-directory"),this);
connect(radAbsolute,SIGNAL(toggled(bool)),SLOT(changeSaving(bool)));

layout->addWidget(radAbsolute,2,0,1,2);
layout->addWidget(radRelative,3,0,1,2);
QLabel * lblLabel=new QLabel(QObject::tr("The following path-information will be stored:"),this);
lblResult=new QLabel(QObject::tr(""),this);

layout->addWidget(lblLabel,4,0,1,2);
layout->addWidget(lblResult,5,0,1,2);
layout->addWidget(explanation,6,0,1,2);
registerField("DefaultStartupFilePath",lblResult);

char dummy[1024];
QFileInfo fi1(QString::fromLocal8Bit(default_grace_file));
    if (fi1.isAbsolute()==true)
    {
    strcpy(dummy,default_grace_file);
    }
    else
    {
    sprintf(dummy,"%s/%s",qt_grace_templates_dir,default_grace_file);
    }
lenAbsoluteFile->setText(dummy);//default_grace_file);
    if (fi1.isAbsolute()==true)
    {
    radAbsolute->setChecked(true);
    }
    else
    {
    radRelative->setChecked(true);
    }
changeSaving(radAbsolute->isChecked());

setLayout(layout);
}

void WizardStartUpPage::doBrowse(void)
{
QString fileName = QFileDialog::getOpenFileName(this, QObject::tr("Select default project file"),
                                                lenAbsoluteFile->text(),
                                                QObject::tr("QtGrace Project file (*.agr)"));
    if (!fileName.isEmpty())
    {
    //qDebug() << "New File";
    lenAbsoluteFile->setText(fileName);
    changeSaving(radAbsolute->isChecked());
    }
    /*else
    {
    qDebug() << "No File selected";
    }*/
}

void WizardStartUpPage::changeSaving(bool t)
{
//qDebug() << "Change=" << t;
    if (t)//absolute
    {
    lblResult->setText(lenAbsoluteFile->text());
    }
    else
    {
    QFileInfo fi(lenAbsoluteFile->text());
    QString templ_dir=QString(qt_grace_templates_dir);
    QDir fi1(templ_dir);
    lblResult->setText(fi1.relativeFilePath(fi.absoluteFilePath()));
    }
}

WizardOutputPage::WizardOutputPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Default Output Format (18 / 20)"));
QLabel * label = new QLabel(QObject::tr("Please choose a file format to save images / hardcopies by default:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nQtGrace is able to export directly into files of different formats. If you load a project file the extension for the export is automatically set according to the export format and if you click on the Export button an output-file is automatically produced with the same name as the project file but with a different suffix.\n\nThe output format is used as it has been set in the export-setup-dialog. When QtGrace is opened the output-format will be set to a default format that can be set here.\n\nIf you select 'Last selection' the output format that was set when QtGrace is closed will be used as default when QtGrace is opened again.\n\nQtGrace is able to output images in several different file formats. Not every one of these file-types is useful for everyone. Therefore the different formats can be activated or deactivated in the Preferences (QtGrace-GUI, on the right hand side: 'Enable/Disable export formats')."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
layout->addWidget(label,0,0,1,2);

int nr=number_of_devices();
QString * entr=new QString[32+nr];
int * i_entr=new int[32+nr];

int useHaru=field("UseLibHaru").toInt();
if (have_libHaru==FALSE) useHaru=FALSE;

entr[0]=QObject::tr("Last selection");
i_entr[0]=-1;
for (int i=0;i<nr;i++)
{
    if ((i!=DEVICE_SCREEN && i!=DEVICE_PDF_HARU) || (i==DEVICE_PDF_HARU && useHaru==TRUE))
    {
    entr[i]=get_device_name(i);
    i_entr[i]=i;
    }
}
devices_item=new StdSelector(this,tr("Please select the default output format:"),nr,entr);
devices_item->setValues(i_entr);
delete[] i_entr;
delete[] entr;
layout->addWidget(devices_item,1,0,1,1);
layout->addWidget(explanation,2,0,1,2);
devices_item->setCurrentIndex(default_Print_Device);
registerField("DefaultOutputFormat",devices_item->cmbSelect);
setLayout(layout);
}

void WizardOutputPage::initializePage()
{
    int nr=number_of_devices(),counter;
    QString * entr=new QString[32+nr];
    int * i_entr=new int[32+nr];

    int useHaru=field("UseLibHaru").toInt();
    if (have_libHaru==FALSE) useHaru=FALSE;

    entr[0]=QObject::tr("Last selection");
    i_entr[0]=-1;
    counter=1;
    for (int i=0;i<nr;i++)
    {
        if ((i!=DEVICE_SCREEN && i!=DEVICE_PDF_HARU) || (i==DEVICE_PDF_HARU && useHaru==TRUE))
        {
        entr[i]=get_device_name(i);
        i_entr[i]=i;
        counter++;
        }
    }
devices_item->setNewEntries(counter,entr,i_entr);
devices_item->setCurrentIndex(default_Print_Device);
}

void WizardOutputPage::cleanupPage()
{
devices_item->cmbSelect->clear();
}

WizardBehaviorPage::WizardBehaviorPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("General Behavior (19 / 20)"));
QLabel * label = new QLabel(QObject::tr("You may choose between different behaviors of the general interface. You may choose to use QtGrace like Grace / XmGrace or you can choose a more modern behavior:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nWhen closing Grace / XmGrace while there are still unsaved changes a question is displayed: \"Exit loosing unsaved changes?\". You can answer with 'Yes', meaning just 'close without saving' or 'No', meaning 'don't close'. If you set the general behavior to be like 'Grace' the same question is asked in QtGrace but now with one addition: you may choose to save the project before closing ('Save' or 'Save As...').\n\nThe question mentioned above may not be easily understandable for useres that are not used to Grace / XmGrace. When choosing the general behavior to be like 'QtGrace' the question is formulated more detailed: \"Contents of current project changed. You may choose to save the current project now.\".\n\nThe behavior of QtGrace also implies to open the default file dialog or your operating system for saving and loading some of the files instead of the cumbersome file-dialog of Grace / XmGrace. Generally you may also open the default file dialog of the operating system from inside the Grace-file-dialog via the folder-button on the right hand side of the dialog. Regardless of what you select here, you may also open the other type of file-dialog by holding down the CTRL-key while choosing Load/Save.\nPlease keep in mind that the file-dialog of the operating system does not provide as many options for saving as the QtGrace-file-save-dialog. When the file dialog of the operating system is used many settings have to set beforehand in the preferences or in 'Plot/Plot appearance...'."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
layout->addWidget(label,0,0,1,1);
int nr=2;
QString * entries=new QString[2];
entries[0]=tr("Grace / XmGrace");
entries[1]=tr("QtGrace");
StdSelector * selIcons=new StdSelector(this,tr("General behavior like:"),nr,entries);
selIcons->setCurrentIndex(general_behavior);
registerField("GeneralBehavior",selIcons->cmbSelect);
delete[] entries;
layout->addWidget(selIcons,1,0,1,1);
layout->addWidget(explanation,2,0,1,1);
setLayout(layout);
}

WizardCompressionPage::WizardCompressionPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("File Compression (20 / 20)"));
QLabel * label = new QLabel(QObject::tr("In QtGrace it is possible to save project files in a partly compressed form (to save space):"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nIn Grace / XmGrace it is possible to automatically pass every file that is saved or loaded through a compression program. This program does compression or decompression on-the-fly.\nIn QtGrace there is now a similar option: You may choose to compress the data of all sets in a project file via the compression algorithm that is included in the Qt-Library (actually zlib). You may also select the level of compression. A value of 0 means actually no compression. A value of -1 means the default value of the internal compression algorithm. Values around 2 or 3 should be a good tradeoff between saved space and time needed.\n\nIf a project file is compressed only the data of the set(s) is compressed, the header that contains all the settings is still saved in plain ascii-text. This type of compression is not compatible with the method used in Grace / XmGrace!\nThere is an additional program in the Compression_Decompression-subfolder that can be used to compress and decompress project files independent of QtGrace. This is useful for bulk-compression of files e.g. for archiving purposes. Or you may decompress files if you need to use them with the original Grace / XmGrace.\n\nThe settings here are the default settings. You may alter these settings for every project file you save separately in the QtGrace-save-file-dialog. You will not see this setting in the default save-dialog of the operating system if you have set the general behavior to 'QtGrace'. In this case the default settings that are set here or in the preferences are used for every file."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
layout->addWidget(label,0,0,1,1);
int nr=2;
QString * entries=new QString[2];
entries[0]=tr("No compression");
entries[1]=tr("Qt-internal compression");
StdSelector * selIcons=new StdSelector(this,tr("File compression:"),nr,entries);
    if (default_compress_data==COMPRESSION_NONE)
    selIcons->setCurrentIndex(0);
    else
    selIcons->setCurrentIndex(1);
stdIntSelector * selValue=new stdIntSelector(this,tr("Compression level:"),-1,9);
selValue->setValue(default_compression_level);
registerField("CompressionType",selIcons->cmbSelect);
registerField("CompressionLevel",selValue->spnInt);
delete[] entries;
layout->addWidget(selIcons,1,0,1,1);
layout->addWidget(selValue,2,0,1,1);
layout->addWidget(explanation,3,0,1,1);
setLayout(layout);
}

WizardFinishPage::WizardFinishPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Setup finished!"));
QLabel * label = new QLabel(QObject::tr("The setup of QtGrace has been finished. If you accept/finish this Wizard-Dialog your choices will be used as the preferences for QtGrace and will be stored in an ini-file when QtGrace is closed regularely.\n\nIf you want to reactivate this Setup-Wizard go to Preferences->Miscellaneous.\n\nAll settings in this Wizard-Dialog can also be altered via the Preferences-Dialog.\n\nHave fun using QtGrace."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
layout->addWidget(label);
setLayout(layout);
}

InitQtGraceWizard::InitQtGraceWizard(QWidget * parent):QWizard(parent)
{
setWindowTitle(tr("Setup Wizard"));
setOption(QWizard::IndependentPages,true);
addPage(new WizardIntroPage);//0
addPage(new WizardUndoPage);//1
addPage(new WizardImmediateUpdatePage);//2
addPage(new WizardDecSepPage);//3
addPage(new WizardLatexPage);//4
addPage(new WizardQtFontsPage);//5
addPage(new WizardMouseWheelPage);//6
addPage(new WizardTextEditPage);//7
addPage(new WizardContextMenuPage);//8
addPage(new WizardHighlightPage);//9
//addPage(new WizardAutoscalePage);//10
autoscale=new WizardAutoscalePage();//10
addPage(autoscale);
addPage(new WizardListIconsPage);//11
addPage(new WizardUniListSettingsPage);//12
addPage(new WizardLibFFTW3Page);//13
WizardLibHaruPage * lharu=new WizardLibHaruPage();
addPage(lharu);//14
addPage(new WizardToolBarPage);//15
addPage(new WizardToolBarPage2);//16
startuppage=new WizardStartUpPage();
addPage(startuppage);//17
WizardOutputPage * outpage=new WizardOutputPage();
addPage(outpage);//18
lharu->outPage=outpage;
addPage(new WizardBehaviorPage);//19
addPage(new WizardCompressionPage);//20
addPage(new WizardFinishPage);//21(End)
connect(this,SIGNAL(currentIdChanged(int)),this,SLOT(PageChanged(int)));
setOption(QWizard::NoCancelButton,false);
setMinimumSize(800,680);
resize(LastSize_Form_InitWizard);
}

InitQtGraceWizard::~InitQtGraceWizard()
{
    LastSize_Form_InitWizard=this->size();
    delete autoscale;
}

void InitQtGraceWizard::initAllPages(void)
{
//setField("undoActive", !undo_active);
//setField("ImmUpdateActive", immediateUpdate);
}

void InitQtGraceWizard::setGlobalsToWizardValues(void)
{
start_with_undo_active=undo_active=field("undoActive").toInt();
immediateUpdate=field("ImmUpdateActive").toBool();
activateLaTeXsupport=field("LatexActive").toBool();
useQtFonts=field("QtFontsActive").toBool();
symbol_font_is_special=field("SymbolFontSpecial").toBool();

inline_editing=field("TextEditInMain").toInt();
context_menu_in_main=field("ContextMenuInMain").toInt();

auto_highlight=field("AutoHighlight").toInt();
highlight_errorbars=field("HighlightErrorBars").toInt();
highlight_color=field("HighlightColor").toInt();
highlight_time=field("HighlightTime").toInt();

useErrorbarsInAutoscale=field("AutoscaleIncludingErrorBars").toInt();
minAutoscaleBorderOffset=autoscale->spnAutoScaleRange->value();

allow_wheel_zoom=field("MouseWheelZoom").toInt();
allow_wheel_changes=field("MouseWheelSize").toInt();

icon_preferences=field("IconPreferences").toInt();

use_new_icons=field("ToolsNewIcons").toInt();
show_Navi_B=field("ToolsNavi").toInt();
show_Graph_List=field("ToolsGraph").toInt();
show_special_Zoom=field("ToolsSpecZoom").toInt();
show_Viewport_Stack=field("ToolsViewportStack").toInt();
show_Page_Zoom=field("ToolsPageZoom").toInt();
show_Print_B=field("ToolsPrint").toInt();
show_Export_B=field("ToolsExport").toInt();
show_PanButton=field("ToolsPan").toInt();
show_PickButton=field("ToolsPick").toInt();
show_UndoRedo_B=field("ToolsUndo").toInt();

DefaultSetListShowDataless=field("ListDataLess").toInt();
DefaultSetListShowHidden=field("ListHidden").toInt();
DefaultSetListShowComments=field("ListComment").toInt();
DefaultSetListShowLegends=field("ListLegend").toInt();
DefaultSetListShowIcons=field("ListIcons").toInt();

general_behavior=field("GeneralBehavior").toInt();

default_compress_data=field("CompressionType").toInt();
default_compression_level=field("CompressionLevel").toInt();

use_libHaru=field("UseLibHaru").toInt();
use_fftw3=field("UseFFTW3").toInt();

path_to_fftw3_lib.setFileName(field("LibFFTW3Path").toString());
path_to_libharu.setFileName(field("LibHaruPath").toString());

default_Print_Device=field("DefaultOutputFormat").toInt();

warn_on_encoding_change=field("WarnOnEncodingChange").toInt();
int dc=field("DecimalSeparator").toInt();
if (dc==0) DecimalPointToUse='.';
else DecimalPointToUse=',';
dc=field("FileEncoding").toInt();

//FileCodec=QTextCodec::codecForName(avcod.at(dc));

strcpy(default_grace_file,startuppage->lblResult->text().toLocal8Bit().constData());
//strcpy(default_grace_file,field("DefaultStartupFilePath").toString().toLocal8Bit().constData());
    if (Form_Preferences==NULL)
    {
    Form_Preferences=new frm_Preferences(mainWin);
    Form_Preferences->init();
    Form_Preferences->hide();
    }
    else
    {
    Form_Preferences->init();
    }
    Form_Preferences->doApply();
}

void InitQtGraceWizard::PageChanged(int p)
{
(void)p;
int id=currentId();
//qDebug() << "id=" << id;
    switch (id)
    {
    case 0:
        break;
    case 1:
        //setField("undoActive", undo_active);
        break;
    case 2:
        //setField("ImmUpdateActive", immediateUpdate);
        break;
    case 3:
        break;
    default:
        break;
    }
}

void InitQtGraceWizard::done(int result)
{
//qDebug() << "Result=" << result;
    if (result)
    {
    setGlobalsToWizardValues();
    update_all();
    }
    else
    {
    QMessageBox::information(this,tr("Close Setup-Wizard"),tr("You are about to close the setup-wizard.\n\nYour choices will NOT be transferred to the settings.\n\nIf you want to change any settings later please go to the Preferences-dialog.\nYou may also summon this setup-dialog again via the Miscellaneous-tab therein."));
    }
QWizard::done(result);
}

void InitQtGraceWizard::closeEvent(QCloseEvent * e)
{
    e->accept();
//qDebug() << "cancel";
    done(0);
}

graphicTestWidget::graphicTestWidget(QWidget * parent):QWidget(parent)
{
setWindowTitle(QString("GraphicsTestWidget"));
resize(550,420);

lbltest=new QLabel(this);

lenEdit=new QLineEdit(QString("Text"),0);
lenEdit->setFrame(false);

//lenEdit->setAlignment(Qt::AlignHCenter | Qt::AlignVCenter);
lenEdit->setAlignment(Qt::AlignLeft | Qt::AlignVCenter);

g_view=new QGraphicsView(this);
g_scene=new QGraphicsScene(this);
g_proxy = g_scene->addWidget(lenEdit);
g_view->setScene(g_scene);

transpPalette=this->palette();
transpPalette.setColor(QPalette::Base,Qt::transparent);//for testing
transpPalette.setColor(QPalette::AlternateBase,Qt::transparent);
transpPalette.setColor(QPalette::Window,Qt::transparent);
transpPalette.setColor(QPalette::Button,Qt::transparent);
transpPalette.setColor(QPalette::Text,Qt::black);
//transpPalette.setColor(QPalette::Base,Qt::green);
g_scene->setPalette(transpPalette);
g_view->setPalette(transpPalette);
//transpPalette.setColor(QPalette::Base,Qt::yellow);
transpPalette.setColor(QPalette::Base,Qt::transparent);
lenEdit->setPalette(transpPalette);
//transpPalette.setColor(QPalette::Base,Qt::green);
//g_proxy->setPalette(transpPalette);
//transpPalette.setColor(QPalette::Base,Qt::yellow);
//this->setPalette(transpPalette);

//g_scene->setSceneRect(0,0,540,340);
//g_view->setGeometry(this->rect());
g_view->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
g_view->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

lenEdit->resize(620,25);
g_proxy->setPos(00.0,00.0);
g_view->centerOn(g_proxy);
g_view->hide();
g_view->setFocus();
g_proxy->setFocus();
lenEdit->setFocus(Qt::MouseFocusReason);

points[0].setX(100);//Position von oben links aus
points[0].setY(100);
points[1].setX(200);
points[1].setY(220);
points[2].setX(340);
points[2].setY(230);

QPixmap * pix=new QPixmap(500,300);
QPen pen;
QPainter * paint=new QPainter(pix);
pen=paint->pen();
pen.setWidth(1);//3
paint->setPen(pen);
paint->setBrush(Qt::white);
paint->drawRect(0,0,500-1,300-1);//-3
    for (int i=0;i<3;i++)
    paint->drawPoint(points[i]);
/*paint->drawPoint(100,100);
paint->drawPoint(200,220);
paint->drawPoint(340,230);*/
paint->end();

lbltest->setPixmap(*pix);
lbltest->setGeometry(0,0,500,300);

lblTitles[4]=new QLabel(tr("FontSize:"),this);
spnKoords[3]=new QSpinBox(this);
lblTitles[4]->setGeometry(0*120,300,120,30);
spnKoords[3]->setGeometry(1*120,300,120,30);

lblTitles[0]=new QLabel(tr("Rotation:"),this);
lblTitles[1]=new QLabel(tr("x_shift:"),this);
lblTitles[2]=new QLabel(tr("y_shift:"),this);
lblTitles[3]=new QLabel(tr("Alignment:"),this);
    for (int i=0;i<4;i++)
    {
    lblTitles[i]->setGeometry(i*120,330,120,30);
    }
spnKoords[0]=new QSpinBox(this);
spnKoords[1]=new QSpinBox(this);
spnKoords[2]=new QSpinBox(this);
for (int i=0;i<4;i++)
spnKoords[i]->setRange(-100,100);
spnKoords[0]->setValue(0);
spnKoords[1]->setValue(14);
spnKoords[2]->setValue(-2);
spnKoords[3]->setValue(12);

    for (int i=0;i<3;i++)
    {
    spnKoords[i]->setGeometry(i*120,360,120,30);
    }

cmbAlign=new QComboBox(this);
cmbAlign->setGeometry(3*120,360,120,30);
cmbAlign->addItem(tr("Left"));
cmbAlign->addItem(tr("Center"));
cmbAlign->addItem(tr("Right"));

push1=new QPushButton(tr("Show"),this);
push2=new QPushButton(tr("Reposition"),this);
push1->setGeometry(0,390,100,25);
push2->setGeometry(120,390,100,25);

connect(push1,SIGNAL(clicked()),SLOT(doPush1()));
connect(push2,SIGNAL(clicked()),SLOT(doPush2()));

for (int i=0;i<4;i++)
{
connect(spnKoords[i],SIGNAL(valueChanged(int)),SLOT(value_changed(int)));
}

ppoint=0;
}

void graphicTestWidget::doPush1(void)
{
//qDebug() << "Push 1";
    g_view->setGeometry(lbltest->rect());
    g_scene->setSceneRect(lbltest->rect());
    g_view->show();
    g_view->centerOn(g_proxy);
//qDebug() << lenEdit->pos();
    lenEdit->setText("Ag_Test_Text_New_gA");
position_text(points[ppoint].x(),points[ppoint].y());
}

void graphicTestWidget::doPush2(void)
{
//qDebug() << "Push 2";
    ppoint++;
    if (ppoint>=3) ppoint=0;
//position_text(points[ppoint].x(),points[ppoint].y());
doPush1();
}

void graphicTestWidget::value_changed(int i)
{
(void)i;
doPush1();
}

void graphicTestWidget::position_text(int xp,int yp)
{
//double rot=QInputDialog::getDouble(this,QString("Test"),QString("Rotation(degrees)="));
    int x_shift,y_shift,rot;
    double sa;//=sin(rot*M_PI/180.0);
    double ca;//=cos(rot*M_PI/180.0);
    double tmp1,tmp2;

#ifdef MAC_SYSTEM
    #if QT_VERSION >= 0x050000
    x_shift=0;
    y_shift=-1;
    #else
    x_shift=14;
    y_shift=-2;
    #endif
#endif
#ifdef WINDOWS_SYSTEM
    x_shift=2;
    y_shift=0;
#endif
#ifdef LINUX_SYSTEM
    x_shift=2;
    y_shift=0;
#endif

rot=spnKoords[0]->value();
x_shift=spnKoords[1]->value();
y_shift=spnKoords[2]->value();

switch (spnKoords[3]->value())
{
case 0://left
lenEdit->setAlignment(Qt::AlignVCenter | Qt::AlignLeft);
break;
case 1://center
lenEdit->setAlignment(Qt::AlignVCenter | Qt::AlignHCenter);
break;
case 2://right
lenEdit->setAlignment(Qt::AlignVCenter | Qt::AlignRight);
break;
}

QFont f1=lenEdit->font();
f1.setPixelSize(spnKoords[3]->value());
lenEdit->setFont(f1);
lenEdit->resize(lbltest->width(),f1.pixelSize()*2);

QRect rec=lenEdit->style()->itemTextRect(lenEdit->fontMetrics(),lenEdit->rect(),lenEdit->alignment(),true,lenEdit->text());
//qDebug() << "rec.x=" << rec.x() << " y=" << rec.y() << " w=" << rec.width() << " h=" << rec.height() << " baseline=" << baseline;
x_shift+=rec.x();
y_shift+=(lenEdit->height()-rec.height())/2+rec.height()-lenEdit->fontMetrics().descent();

/*
QPoint rec2=lenEdit->mapToParent(QPoint(rec.x(),rec.y()));
QPointF rec3=g_proxy->mapToParent(QPoint(rec2.x(),rec2.y()));
qDebug() << "rec2=" << rec2 << " rec3=" << rec3;
rec=lenEdit->style()->itemTextRect(lenEdit->fontMetrics(),QRect(0,0,10,10),lenEdit->alignment(),true,lenEdit->text());
qDebug() << "rec.x=" << rec.x() << " y=" << rec.y() << " w=" << rec.width() << " h=" << rec.height() << " baseline=" << baseline;
*/

/*
qDebug() << "proxy  =" << g_proxy->rect();
qDebug() << "lenEdit=" << lenEdit->rect();
qDebug() << "frameGeometry=" << lenEdit->frameGeometry();
qDebug() << "Geometry=" << lenEdit->geometry();
qDebug() << "frameSize=" << lenEdit->frameSize();
*/

g_proxy->resetTransform();
g_proxy->setRotation(-rot);
//g_proxy->moveBy(xp-g_proxy->x(),yp-g_proxy->y());

sa=sin(rot*M_PI/180.0);
ca=cos(rot*M_PI/180.0);

tmp1=ca*x_shift+sa*y_shift;
tmp2=-sa*x_shift+ca*y_shift;

x_shift=rint_2(tmp1);
y_shift=rint_2(tmp2);

//qDebug() << "x_shift=" << x_shift << " y_shift=" << y_shift;
g_proxy->moveBy(xp-g_proxy->x()-x_shift,yp-g_proxy->y()-y_shift);
}

frmGroupTestWidget::frmGroupTestWidget(QWidget * parent):QWidget(parent)
{
    grp_1=new QGroupBox(tr("Group 1"),this);
    layout1=new QGridLayout();
    //layout1->setMargin(STD_MARGIN);
    layout1->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
        for (int i=0;i<4;i++)
        {
        lbltest1[i]=new QLabel(tr("1: Test ")+QString::number(i),this);
        lentest1[i]=new QLineEdit(QString(""),this);
        layout1->addWidget(lbltest1[i],i,0);
        layout1->addWidget(lentest1[i],i,1);
        layout1->setRowStretch(i,1);
        }
        layout1->setRowStretch(4,10);
    grp_1->setLayout(layout1);

    grp_2=new QGroupBox(tr("Group 2"),this);
    layout2=new QGridLayout();
    //layout2->setMargin(STD_MARGIN);
    layout2->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout2->setSpacing(STD_SPACING);
    layout2->setRowStretch(0,1);
    //nix
    grp_2->setLayout(layout2);

    grp_3=new QGroupBox(tr("Group 3"),this);
    layout3=new QGridLayout();
    //layout3->setMargin(STD_MARGIN);
    layout3->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout3->setSpacing(STD_SPACING);
        for (int i=0;i<4;i++)
        {
        lbltest3[i]=new QLabel(tr("3: Test ")+QString::number(i),this);
        lentest3[i]=new QLineEdit(QString(""),this);
        layout3->addWidget(lbltest3[i],i,0);
        layout3->addWidget(lentest3[i],i,1);
        layout3->setRowStretch(i,1);
        }
        layout3->setRowStretch(4,10);
    grp_3->setLayout(layout3);

    grp_4=new QGroupBox(tr("Group 4"),this);
    layout4=new QGridLayout();
    //layout4->setMargin(STD_MARGIN);
    layout4->setContentsMargins(STD_MARGIN,STD_MARGIN,STD_MARGIN,STD_MARGIN);
    layout4->setSpacing(STD_SPACING);
        for (int i=0;i<4;i++)
        {
        lbltest4[i]=new QLabel(tr("4: Test ")+QString::number(i),this);
        lentest4[i]=new QLineEdit(QString(""),this);
        layout4->addWidget(lbltest4[i],i,0);
        layout4->addWidget(lentest4[i],i,1);
        layout4->setRowStretch(i,1);
        }
        layout4->setRowStretch(4,10);
    grp_4->setLayout(layout4);

layout=new QVBoxLayout();
push=new QPushButton(tr("Push"),this);
connect(push,SIGNAL(clicked()),SLOT(doClick()));
layout->addWidget(grp_1);
layout->addWidget(grp_2);
layout->addWidget(grp_3);
layout->addWidget(grp_4);
layout->addWidget(push);
layout->addStretch(10);
this->setLayout(layout);
delta=0;
}

void frmGroupTestWidget::doClick(void)
{
    if (lbltest3[0]->isVisible())
    {
        delta=this->height()-push->height()-push->y();
        for (int i=0;i<4;i++)
        {
        lbltest3[i]->setVisible(false);
        lentest3[i]->setVisible(false);
        }
        qApp->processEvents();
        delta-=this->height()-push->height()-push->y();
        //qDebug() << "delta=" << delta;
        this->resize(this->width(),this->height()+delta);
    }
    else
    {
        for (int i=0;i<4;i++)
        {
        lbltest3[i]->setVisible(true);
        lentest3[i]->setVisible(true);
        }
        //this->resize(this->width(),this->height()-delta);
        qApp->processEvents();
    }
}


